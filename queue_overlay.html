<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Cola de Pedidos - Zero FM</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap');

    :root {
      /* Variables Configurables */
      --queue-width: 350px;
      --queue-bg-color: rgba(0, 0, 0, 1);
      --queue-bg-color-transparent: rgba(0, 0, 0, 0.6);
      --queue-bg-color-tertiary: rgba(0, 0, 0, 0.3);
      --queue-accent-color: #00e5ff;
      --queue-text-color: #ffffff;
      --queue-font-family: 'Montserrat', sans-serif;
      --queue-font-size: 16px;
      --queue-item-spacing: 15px;
      --queue-border-radius: 6px;
      --queue-item-min-height: 80px;
      --queue-padding: 15px;
      --queue-text-gap: 4px;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: transparent; /* Importante para OBS */
      overflow: hidden;
      font-family: var(--queue-font-family);
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center; /* Centrado horizontal */
      justify-content: flex-start; /* Lista vertical desde arriba */
    }

    #queue-container {
      margin: 20px;
      width: var(--queue-width);
      display: flex;
      flex-direction: column;
      gap: var(--queue-item-spacing);
    }

    .queue-item {
      background: transparent;
      margin-bottom: var(--queue-item-spacing); /* Gap */
      display: flex;
      flex-direction: column;
      /* Animaci√≥n de layout (colapso al salir) */
      transition: max-height 0.8s cubic-bezier(0.4, 0, 0.2, 1), 
                  margin-bottom 0.8s cubic-bezier(0.4, 0, 0.2, 1), 
                  opacity 0.5s ease;
      max-height: 200px; /* Aumentado para permitir alturas mayores */
      overflow: visible; /* Importante para ver el elemento salir volando */
    }

    /* Caja visual interna */
    .queue-item-inner {
      box-sizing: border-box; /* Incluir padding en el c√°lculo de altura */
      background: var(--queue-bg-color);
      border-left: 5px solid var(--queue-accent-color); 
      border-radius: var(--queue-border-radius);
      min-height: var(--queue-item-min-height);
      padding: var(--queue-padding);
      color: var(--queue-text-color);
      box-shadow: 0 5px 15px rgba(0,0,0,0.4);
      display: flex;
      flex-direction: column;
      justify-content: center; /* Centrar verticalmente si la altura es grande */
      
      /* Animaci√≥n de Entrada Base */
      opacity: 0;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    /* Estilos para tarjetas en cola (2¬™) */
    .queue-item:nth-child(2) .queue-item-inner {
      background: var(--queue-bg-color-transparent, var(--queue-bg-color));
    }

    /* Estilos para tarjetas en cola (3¬™ en adelante) */
    .queue-item:nth-child(n+3) .queue-item-inner {
      background: var(--queue-bg-color-tertiary, var(--queue-bg-color-transparent));
    }

    /* Estado Vac√≠o */
    #empty-state {
      display: none;
      color: var(--queue-text-color);
      opacity: 0.7;
      text-align: center;
      margin-top: 50px;
      font-weight: 300;
      background: var(--queue-bg-color-tertiary);
      padding: 20px;
      border-radius: var(--queue-border-radius);
      width: 100%;
      box-sizing: border-box;
    }
    #empty-state.visible {
      display: block;
      animation: fadeIn 0.5s ease;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 0.7; } }

    .queue-item:nth-child(n+2) .item-header {
      display: none !important;
    }

    /* Variantes de Entrada (se aplican con .show) */
    
    /* 1. Slide Left (Original/Default: translateX(-30px)) */
    .anim-entry-slide-left .queue-item-inner { transform: translateX(-30px); }
    .anim-entry-slide-left .queue-item.show .queue-item-inner { opacity: 1; transform: translateX(0); }

    /* 2. Slide Up */
    .anim-entry-slide-up .queue-item-inner { transform: translateY(30px); }
    .anim-entry-slide-up .queue-item.show .queue-item-inner { opacity: 1; transform: translateY(0); }

    /* 3. Fade */
    .anim-entry-fade .queue-item-inner { transform: scale(1); }
    .anim-entry-fade .queue-item.show .queue-item-inner { opacity: 1; }

    /* 4. Zoom In */
    .anim-entry-zoom .queue-item-inner { transform: scale(0.5); }
    .anim-entry-zoom .queue-item.show .queue-item-inner { opacity: 1; transform: scale(1); }


    /* Variantes de Salida (se aplican con .removing) */
    /* Nota: .removing en el wrapper colapsa height/margin. La animaci√≥n visual va en inner */
    .queue-item.removing {
      max-height: 0;
      margin-bottom: 0;
      /* Delay layout collapse to allow exit animation to play first */
      transition-delay: 0.5s;
    }

    /* FIX: Usar transiciones en lugar de animaciones para asegurar consistencia con la entrada */
    /* La clase .queue-item-inner ya tiene transition: all 0.5s cubic-bezier(...) definida arriba */

    /* 1. Slide Right (Original/Default) */
    .anim-exit-slide-right .queue-item.removing .queue-item-inner { 
      transform: translateX(0) !important;
      opacity: 1 !important;
    }
    .anim-exit-slide-right .queue-item.removing.removing-active .queue-item-inner { 
      transform: translateX(100%) !important;
      opacity: 0 !important;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    }

    /* 2. Slide Down */
    .anim-exit-slide-down .queue-item.removing .queue-item-inner { 
      transform: translateY(0) !important;
      opacity: 1 !important;
    }
    .anim-exit-slide-down .queue-item.removing.removing-active .queue-item-inner { 
      transform: translateY(50px) !important;
      opacity: 0 !important;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    }

    /* 3. Fade Out */
    .anim-exit-fade .queue-item.removing .queue-item-inner { 
      opacity: 1 !important;
    }
    .anim-exit-fade .queue-item.removing.removing-active .queue-item-inner { 
      opacity: 0 !important;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    }

    /* 4. Zoom Out */
    .anim-exit-zoom .queue-item.removing .queue-item-inner { 
      transform: scale(1) !important;
      opacity: 1 !important;
    }
    .anim-exit-zoom .queue-item.removing.removing-active .queue-item-inner { 
      transform: scale(0.5) !important;
      opacity: 0 !important;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    }


    /* Keyframes - Ya no se usan para salida, pero se mantienen por si acaso se reusan para otra cosa */
    @keyframes slideOutRight {
      from { opacity: 1; transform: translateX(0); }
      to { opacity: 0; transform: translateX(100%); }
    }
    @keyframes slideOutDown {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(50px); }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    @keyframes zoomOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.5); }
    }

    .item-header {
      font-size: calc(var(--queue-font-size) * 0.7); /* 11px relativo a 16px */
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--queue-accent-color);
      font-weight: 800;
      margin-bottom: var(--queue-text-gap);
      display: flex;
      justify-content: space-between;
    }
    .hide-header .item-header { display: none !important; }

    .item-song {
      font-size: calc(var(--queue-font-size) * 1.125); /* 18px */
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: calc(var(--queue-text-gap) * 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .item-artist {
      font-size: calc(var(--queue-font-size) * 0.875); /* 14px */
      color: rgba(255,255,255,0.7); /* Usar opacidad para adaptarse al color de texto base */
      margin-bottom: var(--queue-text-gap);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .hide-artist .item-artist { display: none !important; }

    .item-user {
      font-size: calc(var(--queue-font-size) * 0.7); /* 11px */
      color: rgba(255,255,255,0.5);
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .hide-user .item-user { display: none !important; }

    .user-badge {
      background: #333;
      padding: 1px 6px;
      border-radius: 3px;
      color: #fff;
      font-weight: 600;
    }

    /* Animaci√≥n de posici√≥n */
    .queue-pos-1 .queue-item-inner { border-left-color: var(--queue-accent-color); }
    .queue-pos-2 .queue-item-inner { border-left-color: var(--queue-accent-color); opacity: 0.9; filter: brightness(0.8); }
    .queue-pos-3 .queue-item-inner { border-left-color: var(--queue-accent-color); opacity: 0.8; filter: brightness(0.6); }

    /* Panel de Configuraci√≥n */
    #settings-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10001;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.2);
      color: white;
      border-radius: 50%;
      cursor: grab;
      font-size: 20px;
      transition: background 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
      
      width: 50px;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      opacity: 0.2;
    }
    #settings-btn:active {
      cursor: grabbing;
    }
    #settings-btn:hover { 
      opacity: 1; 
      background: rgba(0,0,0,0.8);
    }

    #settings-panel {
      position: fixed;
      top: 70px;
      left: 20px;
      transform: none;
      transform-origin: top left;
      background: #1a1a1a;
      color: white;
      padding: 20px;
      border-radius: 10px;
      width: 300px;
      z-index: 10002;
      box-shadow: 0 10px 40px rgba(0,0,0,0.8);
      display: none;
      max-height: 80vh;
      overflow-y: auto;
      font-family: sans-serif;
    }
    #settings-panel.open { 
      display: block; 
      animation: menu-pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    @keyframes menu-pop {
      from { opacity: 0; transform: scale(0.5); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .settings-group { margin-bottom: 15px; }
    .settings-group label { display: block; margin-bottom: 5px; font-size: 14px; color: #ccc; }
    .settings-group input[type="text"],
    .settings-group input[type="number"], 
    .settings-group select {
      width: 100%;
      padding: 8px;
      background: #333;
      border: 1px solid #444;
      color: white;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .settings-group input[type="color"] {
      width: 100%;
      height: 40px;
      border: none;
      background: none;
      cursor: pointer;
    }
    .settings-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    /* Tab Navigation Styles */
    .tab-nav {
      display: flex;
      border-bottom: 1px solid #444;
      margin-bottom: 20px;
    }
    .tab-btn {
      flex: 1;
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: #aaa;
      padding: 10px 5px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }
    .tab-btn:hover { color: #fff; }
    .tab-btn.active {
      color: var(--queue-accent-color, #00e5ff);
      border-bottom-color: var(--queue-accent-color, #00e5ff);
      font-weight: bold;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; animation: fadeInTab 0.3s ease; }
    @keyframes fadeInTab { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    .btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    .btn-save { background: #00e5ff; color: #000; }
    .btn-reset { background: #444; color: #fff; }

  </style>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
</head>
<body>

  <div id="queue-container">
    <div id="empty-state">
      <div style="font-size: 40px; margin-bottom: 10px;">üéµ</div>
      <div>Esperando solicitudes...</div>
    </div>
    <!-- Items se inyectar√°n aqu√≠ -->
  </div>

  <!-- Bot√≥n de Configuraci√≥n -->
  <button id="settings-btn" title="Configurar Overlay">‚öôÔ∏è</button>
  
  <!-- Indicador de Duraci√≥n Total -->
  <div id="total-duration-indicator" style="
      position: fixed; 
      bottom: 20px; 
      right: 20px; 
      background: rgba(0,0,0,0.7); 
      color: white; 
      padding: 8px 15px; 
      border-radius: 20px; 
      font-size: 14px; 
      font-weight: bold; 
      border: 1px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
      display: none;
      z-index: 9999;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
  ">
    ‚è≥ Tiempo Total: <span id="total-time-val">0m</span>
  </div>

  <!-- Panel de Configuraci√≥n -->
  <div id="settings-panel">
    <h3 style="margin-top:0; border-bottom: 1px solid #333; padding-bottom: 10px;">Configuraci√≥n</h3>
    
    <div class="tab-nav">
      <button class="tab-btn active" onclick="switchTab('general')">General</button>
      <button class="tab-btn" onclick="switchTab('appearance')">Apariencia</button>
      <button class="tab-btn" onclick="switchTab('animations')">Animaci√≥n</button>
      <button class="tab-btn" onclick="switchTab('data')">Datos/API</button>
    </div>

    <!-- TAB: GENERAL -->
    <div id="tab-general" class="tab-content active">
        <div class="settings-group">
          <label>Ancho de Tarjeta (px)</label>
          <input type="number" id="inp-width" value="350">
        </div>

        <div class="settings-group">
          <label>Alto M√≠nimo de Tarjeta (px)</label>
          <input type="number" id="inp-minHeight" value="80" min="0">
        </div>

        <div class="settings-group">
          <label>Espacio entre Tarjetas (px)</label>
          <input type="number" id="inp-spacing" value="15" min="0">
        </div>

        <div class="settings-group">
          <label>Radio de Borde (px)</label>
          <input type="number" id="inp-borderRadius" value="6">
        </div>

        <div class="settings-group">
          <label>Relleno (Padding) (px)</label>
          <input type="number" id="inp-padding" value="15" min="0">
        </div>

        <div class="settings-group">
          <label>Espaciado Textos (Gap) (px)</label>
          <input type="number" id="inp-textGap" value="4" min="0">
        </div>
        
        <div class="settings-group">
          <label>Simulaci√≥n</label>
          <div style="display: flex; gap: 10px;">
            <button class="btn" style="background: #333;" onclick="simulateQueueRequest()">+ Pedido</button>
            <button class="btn" style="background: #333;" onclick="simulateToggleFirst()">Next</button>
          </div>
        </div>
    </div>

    <!-- TAB: APARIENCIA -->
    <div id="tab-appearance" class="tab-content">
        <div class="settings-group" style="display: flex; gap: 10px; flex-wrap: wrap;">
           <label style="width: 100%;">Visibilidad de Elementos</label>
           <label style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
             <input type="checkbox" id="inp-showHeader" checked> Cabecera
           </label>
           <label style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
             <input type="checkbox" id="inp-showArtist" checked> Artista
           </label>
           <label style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
             <input type="checkbox" id="inp-showUser" checked> Usuario
           </label>
           <label style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
             <input type="checkbox" id="inp-showEmpty" checked> Mensaje Vac√≠o
           </label>
        </div>

        <div class="settings-group">
          <label>Fuente</label>
          <select id="inp-font">
            <option value="'Montserrat', sans-serif">Montserrat</option>
            <option value="'Roboto', sans-serif">Roboto</option>
            <option value="'Open Sans', sans-serif">Open Sans</option>
            <option value="'Lato', sans-serif">Lato</option>
            <option value="sans-serif">System Default</option>
          </select>
        </div>

        <div class="settings-group">
          <label>Tama√±o de Fuente Base (px)</label>
          <input type="number" id="inp-fontSize" value="16">
        </div>

        <div class="settings-group">
          <label>Color de Acento</label>
          <input type="color" id="inp-accent" value="#00e5ff">
        </div>

        <div class="settings-group">
          <label>Color de Fondo</label>
          <input type="color" id="inp-bg" value="#000000">
        </div>

        <div class="settings-group">
          <label>Color de Texto</label>
          <input type="color" id="inp-text" value="#ffffff">
        </div>

        <div class="settings-group">
          <label>Opacidad Tarjeta Principal</label>
          <input type="range" id="inp-primaryOpacity" min="0" max="100" value="100" oninput="document.getElementById('primary-opacity-val').innerText = this.value + '%'">
          <span id="primary-opacity-val" style="float: right; margin-top: -30px; margin-right: 10px; font-size: 12px; color: #aaa;">100%</span>
        </div>

        <div class="settings-group">
          <label>Opacidad Tarjetas Cola</label>
          <input type="range" id="inp-secondaryOpacity" min="0" max="100" value="60" oninput="document.getElementById('opacity-val').innerText = this.value + '%'">
          <span id="opacity-val" style="float: right; margin-top: -30px; margin-right: 10px; font-size: 12px; color: #aaa;">60%</span>
        </div>
    </div>

    <!-- TAB: ANIMACIONES -->
    <div id="tab-animations" class="tab-content">
        <div class="settings-group">
          <label>Animaci√≥n de Entrada</label>
          <select id="inp-animEntry">
            <option value="anim-entry-slide-left">Slide Left (Default)</option>
            <option value="anim-entry-slide-up">Slide Up</option>
            <option value="anim-entry-fade">Fade In</option>
            <option value="anim-entry-zoom">Zoom In</option>
          </select>
        </div>

        <div class="settings-group">
          <label>Animaci√≥n de Salida</label>
          <select id="inp-animExit">
            <option value="anim-exit-slide-right">Slide Right (Default)</option>
            <option value="anim-exit-slide-down">Slide Down</option>
            <option value="anim-exit-fade">Fade Out</option>
            <option value="anim-exit-zoom">Zoom Out</option>
          </select>
        </div>
    </div>

    <!-- TAB: DATA/API (NUEVO) -->
    <div id="tab-data" class="tab-content">
        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-autocorrect"> 
             <div>
               <strong>üß† Autocorregir Nombres</strong><br>
               <small style="color:#aaa;">Usa Apple Music para corregir t√≠tulos</small>
             </div>
           </label>
        </div>

        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-showAlbumArt"> 
             <div>
               <strong>üé® Portadas HQ</strong><br>
               <small style="color:#aaa;">Muestra car√°tula del √°lbum (600x600)</small>
             </div>
           </label>
        </div>

        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-showWaitTime"> 
             <div>
               <strong>‚è±Ô∏è Tiempo de Espera</strong><br>
               <small style="color:#aaa;">Muestra "Siguiente" o "en X min"</small>
             </div>
           </label>
        </div>

        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-showTotalDuration"> 
             <div>
               <strong>üìä Duraci√≥n Total Cola</strong><br>
               <small style="color:#aaa;">Indicador flotante del tiempo total</small>
             </div>
           </label>
        </div>

        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-syncAppleMusic"> 
             <div>
               <strong>üéµ Sincronizar Apple Music</strong><br>
               <small style="color:#aaa;">Marca canciones como reproducidas (Req. Cider/Widget)</small>
             </div>
           </label>
        </div>
    </div>

    <div class="settings-actions">
      <button class="btn btn-reset" onclick="resetSettings()">Reset</button>
      <button class="btn btn-save" onclick="saveSettings()">Guardar</button>
    </div>
  </div>

  <!-- Controles de Depuraci√≥n -->
   <div id="debug-controls" style="position: fixed; bottom: 20px; left: 20px; opacity: 0.2; transition: opacity 0.3s; z-index: 10000;">
     <button onclick="simulateQueueRequest()" style="padding: 10px; cursor: pointer;">‚ûï Simular Pedido</button>
     <button onclick="simulateToggleFirst()" style="padding: 10px; cursor: pointer;">‚úÖ Marcar como Reproducida</button>
     <button onclick="toggleDebugBorders()" style="padding: 10px; cursor: pointer;">üñºÔ∏è Ver Bordes</button>
   </div>

  <script>
    // --- Apple Music / Cider Variables (Global) ---
    let ciderSocket = null;
    let lastAutoMarkedSong = ""; 

    function toggleDebugBorders() {
      const container = document.getElementById('queue-container');
      if (container.style.border) {
        container.style.border = '';
        container.style.background = '';
      } else {
        container.style.border = '5px solid red';
        container.style.background = 'rgba(255, 0, 0, 0.2)';
      }
    }
    
    // --- Configuraci√≥n / Settings Logic ---
    function switchTab(tabName) {
      // Buttons
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.innerText.toLowerCase().includes(tabName) || 
            (tabName === 'data' && btn.innerText.includes('Datos'))) {
           // Simple check based on text or click handler
        }
      });
      // But simpler: just use event.target or match logic
      const tabs = ['general', 'appearance', 'animations', 'data'];
      tabs.forEach(t => {
        const content = document.getElementById('tab-' + t);
        if (content) {
            content.classList.toggle('active', t === tabName);
        }
      });
      
      // Update buttons visual state
      const btns = document.querySelectorAll('.tab-btn');
      btns.forEach(btn => {
         // Check if this button corresponds to tabName
         const onclick = btn.getAttribute('onclick');
         if (onclick && onclick.includes(`'${tabName}'`)) {
             btn.classList.add('active');
         } else {
             btn.classList.remove('active');
         }
      });
    }

    const defaultSettings = {
      width: 350,
      minHeight: 80,
      spacing: 15,
      padding: 15,
      textGap: 4,
      borderRadius: 6,
      showHeader: true,
      showArtist: true,
      showUser: true,
      showEmpty: true,
      animEntry: 'anim-entry-slide-left',
      animExit: 'anim-exit-slide-right',
      font: "'Montserrat', sans-serif",
      fontSize: 16,
      accent: "#00e5ff",
      bg: "#000000",
      primaryOpacity: 100,
      secondaryOpacity: 60,
      text: "#ffffff",
      // New Data/API Settings
      autocorrect: false,
      showAlbumArt: false,
      showWaitTime: true,
      showTotalDuration: true,
      syncAppleMusic: true
    };

    window.appliedSettings = { ...defaultSettings };

    function loadSettings() {
      const saved = localStorage.getItem('queue_overlay_settings');
      // Merge saved with default to ensure new keys exist
      const settings = saved ? { ...defaultSettings, ...JSON.parse(saved) } : defaultSettings;
      
      // Ensure animEntry is valid
      if (!settings.animEntry) settings.animEntry = defaultSettings.animEntry;
      if (!settings.animExit) settings.animExit = defaultSettings.animExit;
      
      applySettings(settings);
      
      // Update Inputs
      document.getElementById('inp-width').value = settings.width;
      document.getElementById('inp-minHeight').value = settings.minHeight;
      document.getElementById('inp-spacing').value = settings.spacing !== undefined ? settings.spacing : 15;
      document.getElementById('inp-padding').value = settings.padding !== undefined ? settings.padding : 15;
      document.getElementById('inp-textGap').value = settings.textGap !== undefined ? settings.textGap : 4;
      document.getElementById('inp-borderRadius').value = settings.borderRadius;
      
      document.getElementById('inp-showHeader').checked = settings.showHeader !== undefined ? settings.showHeader : true;
      document.getElementById('inp-showArtist').checked = settings.showArtist !== undefined ? settings.showArtist : true;
      document.getElementById('inp-showUser').checked = settings.showUser !== undefined ? settings.showUser : true;
      document.getElementById('inp-showEmpty').checked = settings.showEmpty !== undefined ? settings.showEmpty : true;

      document.getElementById('inp-animEntry').value = settings.animEntry;
      document.getElementById('inp-animExit').value = settings.animExit;
      
      document.getElementById('inp-font').value = settings.font;
      document.getElementById('inp-fontSize').value = settings.fontSize;
      document.getElementById('inp-accent').value = settings.accent;
      document.getElementById('inp-bg').value = settings.bg;
      
      const primaryOpacityVal = settings.primaryOpacity !== undefined ? settings.primaryOpacity : 100;
      document.getElementById('inp-primaryOpacity').value = primaryOpacityVal;
      document.getElementById('primary-opacity-val').innerText = primaryOpacityVal + '%';

      const opacityVal = settings.secondaryOpacity !== undefined ? settings.secondaryOpacity : 60;
      document.getElementById('inp-secondaryOpacity').value = opacityVal;
      document.getElementById('opacity-val').innerText = opacityVal + '%';

      document.getElementById('inp-text').value = settings.text;
      
      // New Inputs
      document.getElementById('inp-autocorrect').checked = settings.autocorrect !== undefined ? settings.autocorrect : false;
      document.getElementById('inp-showAlbumArt').checked = settings.showAlbumArt !== undefined ? settings.showAlbumArt : false;
      document.getElementById('inp-showWaitTime').checked = settings.showWaitTime !== undefined ? settings.showWaitTime : false;
      document.getElementById('inp-showTotalDuration').checked = settings.showTotalDuration !== undefined ? settings.showTotalDuration : false;
      document.getElementById('inp-syncAppleMusic').checked = settings.syncAppleMusic !== undefined ? settings.syncAppleMusic : false;
    }

    function applySettings(s) {
      window.appliedSettings = s;
      const root = document.documentElement;
      root.style.setProperty('--queue-width', s.width + 'px');
      root.style.setProperty('--queue-item-min-height', s.minHeight + 'px');
      root.style.setProperty('--queue-item-spacing', (s.spacing !== undefined ? s.spacing : 15) + 'px');
      root.style.setProperty('--queue-padding', (s.padding !== undefined ? s.padding : 15) + 'px');
      root.style.setProperty('--queue-text-gap', (s.textGap !== undefined ? s.textGap : 4) + 'px');
      root.style.setProperty('--queue-border-radius', s.borderRadius + 'px');
      
      // Set Global Animation Classes on Container
      const container = document.getElementById('queue-container');
      // Limpiar clases de animaci√≥n previas
      container.className = ''; 
      // A√±adir las seleccionadas
      container.classList.add(s.animEntry);
      container.classList.add(s.animExit);
      
      // Toggle visibility classes
      container.classList.toggle('hide-header', s.showHeader === false);
      container.classList.toggle('hide-artist', s.showArtist === false);
      container.classList.toggle('hide-user', s.showUser === false);

      // Empty State visibility logic moved to renderQueue or handled here via CSS class if needed
      // But renderQueue controls the DOM, so we store the setting in a global var or dataset
      container.dataset.showEmpty = s.showEmpty;
      const emptyState = document.getElementById('empty-state');
      if (emptyState) {
         // Si se debe mostrar el mensaje de vac√≠o y no hay elementos visibles en la cola
         // Verificamos si hay elementos .queue-item en el contenedor
         const hasItems = container.querySelectorAll('.queue-item:not(.removing)').length > 0;
         
         if (s.showEmpty && !hasItems) { 
             emptyState.classList.add('visible');
         } else {
             emptyState.classList.remove('visible');
         }
      }

      root.style.setProperty('--queue-font-family', s.font);
      root.style.setProperty('--queue-font-size', s.fontSize + 'px');
      root.style.setProperty('--queue-accent-color', s.accent);
      root.style.setProperty('--queue-text-color', s.text);
      
      const r = parseInt(s.bg.substr(1,2), 16);
      const g = parseInt(s.bg.substr(3,2), 16);
      const b = parseInt(s.bg.substr(5,2), 16);
      
      const primaryOpacity = (s.primaryOpacity !== undefined ? s.primaryOpacity : 100) / 100;
      const opacity = (s.secondaryOpacity !== undefined ? s.secondaryOpacity : 60) / 100;
      const tertiaryOpacity = Math.max(0, opacity * 0.5); // 50% de la opacidad secundaria
      
      root.style.setProperty('--queue-bg-color', `rgba(${r},${g},${b},${primaryOpacity})`);
      root.style.setProperty('--queue-bg-color-transparent', `rgba(${r},${g},${b},${opacity})`);
      root.style.setProperty('--queue-bg-color-tertiary', `rgba(${r},${g},${b},${tertiaryOpacity})`);
      
      // Force render queue to update empty state based on new settings if needed
      if (typeof renderQueue === 'function' && window.allRequests) {
        renderQueue(); 
      }

      // Cider Connection
      if (s.syncAppleMusic) {
        connectCider();
      }
    }

    function getSettingsFromInputs() {
      return {
        width: document.getElementById('inp-width').value,
        minHeight: document.getElementById('inp-minHeight').value,
        spacing: document.getElementById('inp-spacing').value,
        padding: document.getElementById('inp-padding').value,
        textGap: document.getElementById('inp-textGap').value,
        borderRadius: document.getElementById('inp-borderRadius').value,
        showHeader: document.getElementById('inp-showHeader').checked,
        showArtist: document.getElementById('inp-showArtist').checked,
        showUser: document.getElementById('inp-showUser').checked,
        showEmpty: document.getElementById('inp-showEmpty').checked,
        animEntry: document.getElementById('inp-animEntry').value,
        animExit: document.getElementById('inp-animExit').value,
        font: document.getElementById('inp-font').value,
        fontSize: document.getElementById('inp-fontSize').value,
        accent: document.getElementById('inp-accent').value,
        bg: document.getElementById('inp-bg').value,
        primaryOpacity: document.getElementById('inp-primaryOpacity').value,
        secondaryOpacity: document.getElementById('inp-secondaryOpacity').value,
        text: document.getElementById('inp-text').value,
        // New inputs
        autocorrect: document.getElementById('inp-autocorrect').checked,
        showAlbumArt: document.getElementById('inp-showAlbumArt').checked,
        showWaitTime: document.getElementById('inp-showWaitTime').checked,
        showTotalDuration: document.getElementById('inp-showTotalDuration').checked,
        syncAppleMusic: document.getElementById('inp-syncAppleMusic').checked
      };
    }

    function previewSettings() {
      const settings = getSettingsFromInputs();
      applySettings(settings);
    }

    function saveSettings() {
      const settings = getSettingsFromInputs();
      localStorage.setItem('queue_overlay_settings', JSON.stringify(settings));
      applySettings(settings);

      // Sync to Firestore
      if (db) {
        db.collection('userSettings').doc('global_queue_config').set(settings)
          .then(() => console.log("Configuraci√≥n guardada en la nube"))
          .catch(err => console.error("Error guardando configuraci√≥n:", err));
      }

      toggleSettings(); // close panel
    }
    
    // Listeners para vista previa en tiempo real
    document.addEventListener('DOMContentLoaded', () => {
        // Text/Number inputs
        ['inp-width', 'inp-minHeight', 'inp-spacing', 'inp-padding', 'inp-textGap', 'inp-borderRadius', 'inp-animEntry', 'inp-animExit', 
         'inp-font', 'inp-fontSize', 'inp-accent', 'inp-bg', 'inp-primaryOpacity', 'inp-secondaryOpacity', 'inp-text'].forEach(id => {
           const el = document.getElementById(id);
           if(el) {
             el.addEventListener('input', previewSettings);
             el.addEventListener('change', previewSettings);
           }
        });
        
        // Checkboxes - Visual Only
        ['inp-showHeader', 'inp-showArtist', 'inp-showUser', 'inp-showEmpty'].forEach(id => {
           const el = document.getElementById(id);
           if(el) {
             el.addEventListener('change', previewSettings);
           }
        });

        // Checkboxes - Data/Structure (Requires Re-render)
        ['inp-autocorrect', 'inp-showAlbumArt', 'inp-showWaitTime', 'inp-showTotalDuration', 'inp-syncAppleMusic'].forEach(id => {
           const el = document.getElementById(id);
           if(el) {
             el.addEventListener('change', () => {
                previewSettings();
                renderQueue(); // Force re-render to apply data changes
             });
           }
        });
    });

    function resetSettings() {
      if(confirm('¬øRestablecer valores por defecto?')) {
        applySettings(defaultSettings);
        localStorage.removeItem('queue_overlay_settings');
        loadSettings(); // reload inputs
        toggleSettings();
      }
    }

    function toggleSettings() {
      const panel = document.getElementById('settings-panel');
      panel.classList.toggle('open');
    }

    // Inicializar settings
    loadSettings();

    // Configuraci√≥n de Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyA6c3EaIvuPEfM6sTV0YHqCBHuz35ZmNIU",
      authDomain: "zero-strom-web.firebaseapp.com",
      projectId: "zero-strom-web",
      storageBucket: "zero-strom-web.firebasestorage.app",
      messagingSenderId: "758369466349",
      appId: "1:758369466349:web:f2ced362a5a049c70b59e4"
    };

    let db = null;
    try {
      if (typeof firebase !== 'undefined' && firebase.apps) {
        if (!firebase.apps.length) {
          firebase.initializeApp(firebaseConfig);
        }
        db = firebase.firestore();
      } else {
        console.warn('Firebase SDK not loaded');
      }
    } catch (e) {
      console.error('Error initializing Firebase:', e);
      try {
        db = firebase.firestore();
      } catch (_) {}
    }

    if (db) {
      db.collection('userSettings').doc('global_queue_config')
        .onSnapshot((doc) => {
          if (doc.exists) {
            console.log("Configuraci√≥n remota recibida");
            const remoteSettings = doc.data();
            const settings = { ...defaultSettings, ...remoteSettings };
            
            // Guardar localmente y aplicar
            localStorage.setItem('queue_overlay_settings', JSON.stringify(settings));
            applySettings(settings);
            
            // Actualizar inputs si existen
            if (document.getElementById('inp-width')) {
              document.getElementById('inp-width').value = settings.width;
              document.getElementById('inp-minHeight').value = settings.minHeight;
              document.getElementById('inp-spacing').value = settings.spacing !== undefined ? settings.spacing : 15;
              document.getElementById('inp-padding').value = settings.padding !== undefined ? settings.padding : 15;
              document.getElementById('inp-textGap').value = settings.textGap !== undefined ? settings.textGap : 4;
              document.getElementById('inp-borderRadius').value = settings.borderRadius;
              
              document.getElementById('inp-showHeader').checked = settings.showHeader !== undefined ? settings.showHeader : true;
              document.getElementById('inp-showArtist').checked = settings.showArtist !== undefined ? settings.showArtist : true;
              document.getElementById('inp-showUser').checked = settings.showUser !== undefined ? settings.showUser : true;
              document.getElementById('inp-showEmpty').checked = settings.showEmpty !== undefined ? settings.showEmpty : true;

              document.getElementById('inp-animEntry').value = settings.animEntry;
              document.getElementById('inp-animExit').value = settings.animExit;
              
              document.getElementById('inp-font').value = settings.font;
              document.getElementById('inp-fontSize').value = settings.fontSize;
              document.getElementById('inp-accent').value = settings.accent;
              document.getElementById('inp-bg').value = settings.bg;
              
              const primaryOpacityVal = settings.primaryOpacity !== undefined ? settings.primaryOpacity : 100;
              document.getElementById('inp-primaryOpacity').value = primaryOpacityVal;
              document.getElementById('primary-opacity-val').innerText = primaryOpacityVal + '%';

              const opacityVal = settings.secondaryOpacity !== undefined ? settings.secondaryOpacity : 60;
              document.getElementById('inp-secondaryOpacity').value = opacityVal;
              document.getElementById('opacity-val').innerText = opacityVal + '%';

              document.getElementById('inp-text').value = settings.text;
            }
          }
        }, (error) => {
           console.warn("No se pudo sincronizar configuraci√≥n remota:", error);
        });
    } else {
      console.warn("Firestore no inicializado. No se cargar√° configuraci√≥n remota.");
    }

    const container = document.getElementById('queue-container');
    
    // Estado local
    let allRequests = []; // Todas las solicitudes del d√≠a
    let playedSongIds = new Set(); // IDs de canciones ya reproducidas
    let playedSongsLoaded = false; // Evitar "ghost cards" antes de cargar lista negra
    let visibleQueue = []; // Las 3 canciones actualmente mostradas
    let currentManualOrder = []; // Orden manual compartido

    // Utilidad: Obtener clave de fecha local (YYYY-MM-DD)
    function getLocalDateKey(ts) {
      const d = ts ? new Date(ts) : new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${dd}`;
    }

    // Utilidad: Generar ID de canci√≥n (debe coincidir con lista.html)
    function generateSongId(req) {
      // 1. Preferir ID compuesto ya existente (generado por el bot/lista)
      if (req.id && String(req.id).includes('-') && String(req.id).split('-').length >= 3) {
        return req.id;
      }

      // 2. Fallback: Reconstruir ID si falta (l√≥gica legacy)
      // Necesitamos recrear el formato HH:MM desde el timestamp
      let d;
      if (req.ts && typeof req.ts.toDate === 'function') {
        d = req.ts.toDate();
      } else if (req.ts) {
        d = new Date(req.ts);
      } else {
        d = new Date();
      }
      
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const hora = `${hh}:${mm}`;
      
      // Usar hora del objeto si ya viene pre-formateada
      const finalHora = req.hora || hora;
      
      const usuario = req.usuario || req.user || req.username || '';
      const cancion = req.cancion || req.songName || req.song || req.name || '';
      const artista = req.artista || req.artistName || req.artist || '';
      return `${usuario}-${cancion}-${artista}-${finalHora}`.replace(/[^a-zA-Z0-9-]/g, '');
    }

    // Orden manual: aplicar
    console.log("Queue Overlay v2.5-firebase-reload-fix loaded");

    function applyOrder(items, order) {
      try {
        if (!Array.isArray(order) || !order.length) return items;

        const inOrderSet = new Set(order);

        // Elementos presentes en 'order' respetando ese orden
        const ordered = [];
        order.forEach((sid) => {
          const found = items.find((it) => generateSongId(it) === sid);
          if (found) ordered.push(found);
        });

        // Nuevos (no presentes en 'order') abajo (para mantener FIFO)
        const notInOrder = items.filter((it) => !inOrderSet.has(generateSongId(it)));

        return [...ordered, ...notInOrder];
      } catch {
        return items;
      }
    }

    // --- Data & API Logic ---
    const songDataCache = {}; // Key: "Artist - Song", Value: { artworkUrl, durationMs, correctTitle, correctArtist }
    let isFetching = false;

    function normalizeText(input) {
      return String(input || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^\w\s-]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function tokenizeText(input) {
      const t = normalizeText(input);
      if (!t) return [];
      return t.split(' ').filter(Boolean);
    }

    async function fetchSongData(artist, song) {
      const query = `${artist} ${song}`.trim();
      const cacheKey = query.toLowerCase();
      
      if (songDataCache[cacheKey]) return songDataCache[cacheKey];

      try {
        // Aumentamos el l√≠mite para filtrar resultados no deseados
        const res = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=song&limit=10`);
        const data = await res.json();
        
        if (data.resultCount > 0) {
          const reqArtist = normalizeText(artist);
          const reqSong = normalizeText(song);
          if (!reqArtist || !reqSong) return null;
          const reqArtistTokens = tokenizeText(reqArtist);
          const reqSongTokens = tokenizeText(reqSong);
          const avoidKeywords = ['karaoke', 'tribute', 'cover', 'instrumental', 'remix', 'lullaby', 'rendition', 'slowed', 'reverb'];

          const candidates = (data.results || []).filter(t => {
            const lowerName = normalizeText(t.trackName || '');
            const lowerArtist = normalizeText(t.artistName || '');
            const lowerCollection = normalizeText(t.collectionName || '');
            const hasBadWord = avoidKeywords.some(kw =>
              lowerName.includes(kw) ||
              lowerArtist.includes(kw) ||
              lowerCollection.includes(kw)
            );
            return !hasBadWord;
          });

          let best = null;
          let bestScore = -1;
          const scoreTrack = (t) => {
            const trackName = normalizeText(t.trackName || '');
            const artistName = normalizeText(t.artistName || '');
            if (!trackName || !artistName) return -1;

            let score = 0;
            let songHits = 0;
            let artistHits = 0;

            if (trackName.includes(reqSong)) score += 3;
            if (artistName.includes(reqArtist)) score += 3;

            reqSongTokens.forEach(tok => {
              if (tok.length < 2) return;
              if (trackName.includes(tok)) { score += 1; songHits += 1; }
            });
            reqArtistTokens.forEach(tok => {
              if (tok.length < 2) return;
              if (artistName.includes(tok)) { score += 1; artistHits += 1; }
            });

            if (songHits === 0 || artistHits === 0) return -1;
            return score;
          };

          candidates.forEach((t) => {
            const s = scoreTrack(t);
            if (s > bestScore) { bestScore = s; best = t; }
          });

          const threshold = Math.max(5, Math.ceil((reqSongTokens.length + reqArtistTokens.length) * 0.75));
          const track = bestScore >= threshold ? best : null;
          if (!track) return null;

          const result = {
            artworkUrl: track.artworkUrl100.replace('100x100', '600x600'),
            durationMs: track.trackTimeMillis,
            correctTitle: track.trackName,
            correctArtist: track.artistName
          };
          songDataCache[cacheKey] = result;
          return result;
        }
      } catch (e) {
        console.warn("iTunes API Error:", e);
      }
      return null;
    }

    function formatDuration(ms) {
      if (!ms) return "";
      const minutes = Math.floor(ms / 60000);
      const seconds = ((ms % 60000) / 1000).toFixed(0);
      return `${minutes}:${seconds.padStart(2, '0')}`;
    }

    function formatWaitTime(mins) {
      if (mins === 0) return "Siguiente";
      if (mins < 60) return `en ${Math.round(mins)} min`;
      const h = Math.floor(mins / 60);
      const m = Math.round(mins % 60);
      return `en ${h}h ${m}m`;
    }

    // --- Core Render Logic ---

    function createQueueItem(req, index) {
      const cancion = req.cancion || req.songName || req.song || req.name || '';
      const artista = req.artista || req.artistName || req.artist || '';
      const usuario = req.usuario || req.user || req.username || '';
      const div = document.createElement('div');
      // Wrapper con clases de posici√≥n
      div.className = `queue-item queue-pos-${index + 1}`; 
      div.dataset.songId = generateSongId(req);
      if (req.id) div.dataset.docId = req.id;
      
      // Structure for optional Album Art and Wait Time
      div.innerHTML = `
        <div class="queue-item-inner" style="flex-direction: row; align-items: center; gap: 15px;">
           <img class="item-art" src="" style="display:none; width: 60px; height: 60px; object-fit: cover; border-radius: 4px; flex-shrink: 0;">
           
           <div style="flex: 1; min-width: 0; display: flex; flex-direction: column;">
               <div class="item-header">
                  <span>#${index + 1}</span>
                  <span>En cola</span>
               </div>
               <div class="item-song">${cancion}</div>
               <div class="item-artist">${artista}</div>
               <div class="item-user">
                  Pedido por <span class="user-badge">${usuario}</span>
               </div>
               <div class="item-wait" style="font-size: 11px; color: var(--queue-accent-color); margin-top: 4px; font-weight: bold; display:none;"></div>
           </div>
        </div>
      `;
      return div;
    }

    function renderQueue() {
      // Evitar renderizado si no hemos cargado la lista de reproducidas (evita flash de ghost cards)
      if (!playedSongsLoaded && db) {
        console.log("Esperando lista de reproducidas...");
        return;
      }

      console.log("renderQueue called. Pending requests:", allRequests.length);
      const now = Date.now();
      
      // 1. Filtrar solicitudes que NO est√°n en playedSongIds
      let pendingRequests = allRequests.filter(req => {
        const id = generateSongId(req);
        if (playedSongIds.has(id)) {
            // console.log("Filtered played:", id); // Debug
            return false;
        }
        return true;
      });

      // 1.5 Aplicar orden manual si existe
      pendingRequests = applyOrder(pendingRequests, currentManualOrder);

      // 2. Tomar las primeras 3 (o settings limit)
      // Hardcoded to 3 for now based on visibleQueue logic, but could be dynamic
      const itemsToShow = pendingRequests.slice(0, 3);
      
      // 3. Diffing Inteligente: Solo animar elementos NUEVOS
      const container = document.getElementById('queue-container');
      
      // Mapa de elementos actuales (Array para manejar duplicados de ID)
      const existingMap = new Map();
      container.querySelectorAll('.queue-item:not(.removing)').forEach(el => {
          const id = el.dataset.docId || el.dataset.songId;
          if (id) {
             if (!existingMap.has(id)) existingMap.set(id, []);
             existingMap.get(id).push(el);
          }
      });
      
      // Procesar items a mostrar
      itemsToShow.forEach((req, index) => {
        const reqId = req.id || generateSongId(req);
        let itemEl = null;

        // Intentar recuperar un elemento existente
        if (existingMap.has(reqId)) {
            const list = existingMap.get(reqId);
            if (list.length > 0) {
                itemEl = list.shift(); // Tomar el primero disponible
            }
        }

        if (itemEl) {
            // CASO 1: El elemento YA EXISTE
            // Ya lo sacamos de la lista, si la lista queda vac√≠a, el map se limpia solo al final
            
            // Actualizar clase de posici√≥n si cambi√≥
            const newPosClass = `queue-pos-${index + 1}`;
            // Limpiar clases de posici√≥n antiguas
            itemEl.className = itemEl.className.replace(/queue-pos-\d+/g, '').trim();
            itemEl.classList.add(newPosClass);
            
            // Asegurar que sea visible (sin animaci√≥n de entrada)
            if (!itemEl.classList.contains('show')) itemEl.classList.add('show');
            
        } else {
            // CASO 2: El elemento es NUEVO
            itemEl = createQueueItem(req, index);
            const emptyEl = document.getElementById('empty-state');
            if (emptyEl && emptyEl.parentNode === container) container.insertBefore(itemEl, emptyEl);
            else container.appendChild(itemEl);
            
            // Animar entrada SOLO para este nuevo elemento
            void itemEl.offsetWidth; // Trigger reflow
            itemEl.classList.add('show');
        }
      });

      // 4. Eliminar elementos que ya no est√°n (los que quedaron en existingMap)
      existingMap.forEach((list) => {
          list.forEach(el => {
            // el.classList.remove('show'); // Mantener .show para evitar parpadeo o desaparici√≥n inmediata
            el.classList.add('removing');
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                if (el && el.isConnected) el.classList.add('removing-active');
              });
            });
            
            // Eliminar del DOM despu√©s de la animaci√≥n y el colapso
            // Animaci√≥n: 0.8s | Delay colapso: 0.6s | Colapso: 0.8s 
            // Total visual: ~1.4s. Damos 1.5s de margen.
            setTimeout(() => {
                if (el.parentNode) el.parentNode.removeChild(el);
            }, 1500);
          });
      });

      // 5. Empty State Logic
      let empty = document.getElementById('empty-state');
      if (itemsToShow.length === 0) {
         if (!empty) {
             empty = document.createElement('div');
             empty.id = 'empty-state';
             empty.innerHTML = `<div style="font-size: 40px; margin-bottom: 10px;">üéµ</div><div>Esperando solicitudes...</div>`;
             container.appendChild(empty);
         }
         const s = window.appliedSettings || getSettingsFromInputs(); // Get current settings for visibility
         if (s.showEmpty) empty.classList.add('visible');
         else empty.classList.remove('visible');
      } else {
         if (empty) empty.classList.remove('visible');
      }

      // 6. Hydrate Data (Autocorrect, Art, Times)
      hydrateQueueItems(itemsToShow);
      
      // 7. Update Total Duration
      updateTotalDuration(pendingRequests);
    }

    async function hydrateQueueItems(items) {
      const settings = window.appliedSettings || getSettingsFromInputs();
      if (!settings.autocorrect && !settings.showAlbumArt && !settings.showWaitTime) return;

      const container = document.getElementById('queue-container');
      const itemEls = Array.from(container.querySelectorAll('.queue-item:not(.removing)'));
      const elBySongId = new Map();
      itemEls.forEach((el) => {
        const sid = el.dataset.songId;
        if (sid && !elBySongId.has(sid)) elBySongId.set(sid, el);
      });
      
      let accumulatedTime = 0; // minutes

      for (const req of items) {
         if (!req) continue;
         const songId = generateSongId(req);
         const el = elBySongId.get(songId);
         if (!el) continue;

         const songEl = el.querySelector('.item-song');
         const artistEl = el.querySelector('.item-artist');
         const artEl = el.querySelector('.item-art');
         const waitEl = el.querySelector('.item-wait');

         // Check Cache or Fetch
         if (settings.autocorrect || settings.showAlbumArt || settings.showWaitTime) {
             const artist = String(req.artista || req.artistName || req.artist || '').trim();
             const song = String(req.cancion || req.songName || req.song || req.name || '').trim();
             const data = await fetchSongData(artist, song);
             
             if (data) {
                 if (settings.autocorrect) {
                     songEl.innerText = data.correctTitle;
                     artistEl.innerText = data.correctArtist;
                 }
                 
                 if (settings.showAlbumArt && data.artworkUrl) {
                     artEl.src = data.artworkUrl;
                     artEl.style.display = 'block';
                 } else if (artEl) {
                     artEl.style.display = 'none';
                 }

                 if (settings.showWaitTime && data.durationMs) {
                     waitEl.style.display = 'block';
                     waitEl.innerText = formatWaitTime(accumulatedTime);
                     accumulatedTime += (data.durationMs / 60000);
                 }
             } else {
                 // Fallback for wait time if no data found (assume 3:30 min)
                 if (settings.showWaitTime) {
                     waitEl.style.display = 'block';
                     waitEl.innerText = formatWaitTime(accumulatedTime);
                     accumulatedTime += 3.5; 
                 }
                 if (artEl) artEl.style.display = 'none';
             }
         }
      }
    }

    async function updateTotalDuration(allPending) {
      const settings = window.appliedSettings || getSettingsFromInputs();
      const indicator = document.getElementById('total-duration-indicator');
      const valEl = document.getElementById('total-time-val');

      if (!settings.showTotalDuration || allPending.length === 0) {
        indicator.style.display = 'none';
        return;
      }

      indicator.style.display = 'block';
      
      let totalMs = 0;
      let unknownCount = 0;

      // Batch fetch or use cache
      // Note: fetching all might be heavy. We'll rely on cache + defaults.
      for (const req of allPending) {
         const artist = String(req.artista || req.artistName || req.artist || '').trim();
         const song = String(req.cancion || req.songName || req.song || req.name || '').trim();
         const cacheKey = `${artist} ${song}`.trim().toLowerCase();
         if (songDataCache[cacheKey]) {
             totalMs += songDataCache[cacheKey].durationMs;
         } else {
             unknownCount++;
         }
      }

      // Estimate unknowns as 3.5 mins
      totalMs += (unknownCount * 3.5 * 60000);

      const h = Math.floor(totalMs / 3600000);
      const m = Math.round((totalMs % 3600000) / 60000);
      
      valEl.innerText = h > 0 ? `${h}h ${m}m` : `${m}m`;
    }

    // --- Apple Music / Cider Integration ---
    // Variables moved to top of script to avoid ReferenceError

    // Global variable to store current playback state
    let currentCiderTrack = null;

    // Function to check current playing track against the queue
    function checkCurrentTrackAgainstQueue() {
      if (!currentCiderTrack || !currentCiderTrack.artist || !currentCiderTrack.song) return;

      const artist = currentCiderTrack.artist;
      const song = currentCiderTrack.song;
      
      const key = `${artist}-${song}`;
      if (lastAutoMarkedSong === key) return; // Already handled this track
      
      // Normalize for comparison: remove accents, special chars, lowercase
      const normalize = (str) => {
          if (!str) return "";
          return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^a-z0-9]/g, "");
      };
      
      const targetArtist = normalize(artist);
      const targetSong = normalize(song);

      // Guard Clause: Prevent matching empty/short strings (fixes "match everything" bug)
      // User reported logic worked before 8:40, so we keep this minimal but safe
      if (targetArtist.length < 2 || targetSong.length < 2) {
          // console.warn("‚ö†Ô∏è Cider track data too short to match safely:", artist, "-", song);
          return;
      }

      // Filter unplayed requests using generateSongId for accurate check
      const candidates = allRequests.filter(req => {
          const id = generateSongId(req);
          return !playedSongIds.has(id);
      });

      for (const req of candidates) {
        // Use correct Firestore field names: artista, cancion
        const reqArtist = normalize(req.artista);
        const reqSong = normalize(req.cancion);

        // Robust Matching Logic (Restored & Verified):
        // 1. Standard Match: Artist matches Artist AND Song matches Song
        const matchStandard = 
            (reqArtist.includes(targetArtist) || targetArtist.includes(reqArtist)) &&
            (reqSong.includes(targetSong) || targetSong.includes(reqSong));

        // 2. Swapped Match: Artist matches Song AND Song matches Artist (User swapped fields)
        const matchSwapped = 
            (reqArtist.includes(targetSong) || targetSong.includes(reqArtist)) &&
            (reqSong.includes(targetArtist) || targetArtist.includes(reqSong));
            
        // 3. Combined Match: Song field contains BOTH Artist and Song (User put everything in Song field)
        const matchCombined = 
            reqSong.includes(targetArtist) && reqSong.includes(targetSong);

        if (matchStandard || matchSwapped || matchCombined) {
          console.log(`‚ú® Auto-marking song as played: ${req.artista} - ${req.cancion}`);
          
          // Use generateSongId to match the ID expected by renderQueue
          const generatedId = generateSongId(req);
          markSongAsPlayed(generatedId);
          
          lastAutoMarkedSong = key;
          
          break; // Mark only the first match
        }
      }
    }

    function connectCider() {
      if (ciderSocket) return; // Already connected
      if (!window.io) {
        console.warn("Socket.io not loaded");
        return;
      }

      console.log("Intentando conectar a Cider (localhost:10767)...");
      // Cider uses port 10767 by default
      ciderSocket = io("http://localhost:10767/", {
        transports: ['websocket'],
        reconnectionAttempts: 5
      });

      ciderSocket.on("connect", () => {
        console.log("‚úÖ Conectado a Cider/Apple Music Widget!");
        // Request current playback status immediately
        ciderSocket.emit("get-playback");
      });

      ciderSocket.on("disconnect", () => {
        console.log("‚ùå Desconectado de Cider");
        ciderSocket = null;
      });

      ciderSocket.on("API:Playback", (event) => {
        // data structure: { data: { name, artistName, ... }, type: "..." }
        const { data, type } = event;
        
        // Log para depuraci√≥n
        console.log("üéµ Cider Event:", type, data?.name);

        // Aceptar cambio de canci√≥n O cambio de estado (play/pause) O respuesta inicial
        if (type === "playbackStatus.nowPlayingItemDidChange" || type === "playbackStatus.playbackStateDidChange") {
             // Soportar artistName (Cider) o artist (iTunes)
             const artist = data.artistName || data.artist;
             
             if (data && data.name && artist) {
                 console.log("üéµ Cider Now Playing:", artist, "-", data.name);
                 currentCiderTrack = { artist: artist, song: data.name };
                 checkCurrentTrackAgainstQueue();
             }
        }
      });
    }

    // Wrapper for compatibility (redirects to new logic)
    function autoMarkPlayed(artist, song) {
        currentCiderTrack = { artist, song };
        checkCurrentTrackAgainstQueue();
    }

    function markSongAsPlayed(id) {
      if (!id) return;
      try {
        playedSongIds.add(id);
        playedSongsLoaded = true;
        renderQueue();
      } catch (_) {}
      if (!db) return;
      db.collection('playedSongs').doc(currentDay).set({
        songs: firebase.firestore.FieldValue.arrayUnion(id),
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true })
      .then(() => console.log("Song marked as played:", id))
      .catch(err => console.error("Error marking song as played:", err));
    }

    const currentDay = getLocalDateKey();
    console.log("Queue Overlay v2.2 - Fix Empty Match. Listening for day:", currentDay);

    if (db) {
      db.collection('solicitudes')
        .where('day', '==', currentDay)
        // .orderBy('ts', 'asc') // Removing to avoid index requirement errors causing empty results
        .onSnapshot((snapshot) => {
          const temp = [];
          snapshot.forEach(doc => {
            const data = doc.data();
            const item = { ...data };
            if (!item.id) item.id = doc.id;
            temp.push(item);
          });
          
          // Sort in memory (Oldest First / FIFO)
          temp.sort((a, b) => {
             const tA = a.ts && a.ts.toMillis ? a.ts.toMillis() : (new Date(a.ts).getTime() || 0);
             const tB = b.ts && b.ts.toMillis ? b.ts.toMillis() : (new Date(b.ts).getTime() || 0);
             return tA - tB;
          });

          console.log(`Loaded ${temp.length} requests for day ${currentDay}`);
          allRequests = temp;
          renderQueue();
          checkCurrentTrackAgainstQueue();
        }, (error) => {
          console.error("Error en solicitudes:", error);
        });

      db.collection('playedSongs').doc(currentDay)
        .onSnapshot((doc) => {
          if (doc.exists) {
            const data = doc.data();
            const songs = data.songs || data.list || [];
            playedSongIds = new Set(songs);
          } else {
            playedSongIds = new Set();
          }
          playedSongsLoaded = true; // Marcar como cargado para habilitar renderizado
          renderQueue();
        }, (error) => {
          console.error("Error en playedSongs:", error);
          // En caso de error, permitir renderizar igual para no bloquear la UI
          playedSongsLoaded = true; 
          renderQueue();
        });

      db.collection('manualOrders').doc(currentDay)
        .onSnapshot((doc) => {
          if (doc.exists) {
            currentManualOrder = Array.isArray(doc.data().order) ? doc.data().order : [];
          } else {
            currentManualOrder = [];
          }
          renderQueue();
        }, (error) => {
          console.error("Error en manualOrders:", error);
        });
    } else {
      console.warn("Firestore no disponible. Cola no podr√° sincronizarse.");
      renderQueue();
    }

    // --- L√≥gica de Simulaci√≥n ---
    const debugControls = document.getElementById('debug-controls');
    debugControls.addEventListener('mouseenter', () => debugControls.style.opacity = '1');
    debugControls.addEventListener('mouseleave', () => debugControls.style.opacity = '0.2');

    function simulateQueueRequest() {
      const artists = ["Bad Bunny", "Karol G", "Feid", "Rauw Alejandro", "Shakira", "Daddy Yankee", "Rosal√≠a"];
      const songs = ["Tit√≠ Me Pregunt√≥", "Provenza", "Classy 101", "Todo de Ti", "Bzrp Music Sessions, Vol. 53", "Gasolina", "Despech√°"];
      
      const randomIndex = Math.floor(Math.random() * artists.length);
      const randomArtist = artists[randomIndex];
      const randomSong = songs[randomIndex];
      const randomUser = "Prueba";
      
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const hora = `${hh}:${mm}`;
      const uniqueId = Date.now().toString(36); // Timestamp base36 para unicidad
      const tsValue = (typeof firebase !== 'undefined' && firebase?.firestore?.Timestamp?.fromDate)
        ? firebase.firestore.Timestamp.fromDate(now)
        : now;
      const req = {
        id: `${randomUser}-${randomSong}-${randomArtist}-${hora}-${uniqueId}`.replace(/[^a-zA-Z0-9-]/g, ''),
        usuario: randomUser,
        cancion: randomSong,
        artista: randomArtist,
        ts: tsValue,
        day: getLocalDateKey(now),
        hora,
        status: 'pending',
        isSimulation: true
      };

      // Enviar a Firebase para que se refleje en OBS
      console.log("Enviando simulaci√≥n a Firebase:", req);
      if (!db) {
        allRequests.push(req);
        renderQueue();
        return;
      }
      db.collection('solicitudes').add(req)
        .then(() => console.log("Simulaci√≥n enviada con √©xito"))
        .catch(err => {
          console.error("Error enviando simulaci√≥n:", err);
          try { allRequests.push(req); renderQueue(); } catch (_) {}
        });
    }

    function simulateToggleFirst() {
      // Identificar el primer elemento PENDIENTE (no el primero de allRequests, sino el primero visible)
      const pendingRequests = allRequests.filter(req => {
        const id = generateSongId(req);
        return !playedSongIds.has(id);
      });

      if (pendingRequests.length > 0) {
        const toToggle = pendingRequests[0];
        const id = generateSongId(toToggle);
        
        console.log("Simulando toggle para:", id);
        markSongAsPlayed(id);

      } else {
        alert("No hay canciones pendientes para marcar.");
      }
    }

    // Modo de prueba autom√°tico: ?test=true
    /* 
    // DESACTIVADO para evitar spam al recargar si la URL se queda guardada
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('test') === 'true') {
      setTimeout(() => {
        console.log("Iniciando modo de prueba autom√°tico...");
        // Simular 3 pedidos para llenar la cola
        simulateQueueRequest();
        setTimeout(simulateQueueRequest, 500);
        setTimeout(simulateQueueRequest, 1000);
      }, 1000);
    } 
    */
    // Start Cider connection immediately
    setTimeout(connectCider, 2000);
    
    // --- Drag & Drop Logic for Settings Button ---
    const settingsBtn = document.getElementById('settings-btn');
    const settingsBtnPosKey = `widget_btn_pos:${location.pathname}:settings-btn`;
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let hasMoved = false;

    try {
      const saved = localStorage.getItem(settingsBtnPosKey);
      if (saved) {
        const pos = JSON.parse(saved);
        if (pos && typeof pos.left === 'number' && typeof pos.top === 'number') {
          settingsBtn.style.left = `${pos.left}px`;
          settingsBtn.style.top = `${pos.top}px`;
        }
      }
    } catch (_) {}

    settingsBtn.addEventListener('mousedown', (e) => {
        isDragging = true;
        hasMoved = false;
        const rect = settingsBtn.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        settingsBtn.style.cursor = 'grabbing';
        
        // Disable transitions during drag for responsiveness
        settingsBtn.style.transition = 'none';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        hasMoved = true;
        e.preventDefault();
        
        const x = e.clientX - dragOffsetX;
        const y = e.clientY - dragOffsetY;
        
        settingsBtn.style.left = `${x}px`;
        settingsBtn.style.top = `${y}px`;
    });

    document.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        
        isDragging = false;
        settingsBtn.style.cursor = 'grab';
        
        // Restore transitions
        settingsBtn.style.transition = 'background 0.3s ease, transform 0.3s ease, opacity 0.3s ease';

        if (hasMoved) {
          const rect = settingsBtn.getBoundingClientRect();
          const left = Math.max(0, Math.min(rect.left, window.innerWidth - rect.width));
          const top = Math.max(0, Math.min(rect.top, window.innerHeight - rect.height));
          settingsBtn.style.left = `${left}px`;
          settingsBtn.style.top = `${top}px`;
          try {
            localStorage.setItem(settingsBtnPosKey, JSON.stringify({ left, top }));
          } catch (_) {}
        }
    });
    
    // Handle click manually to avoid triggering when dragging
    settingsBtn.addEventListener('click', (e) => {
        if (!hasMoved) {
            toggleSettings();
        }
    });
  </script>
</body>
</html>
