<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Cola de Pedidos - Zero FM</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap');

    :root {
      /* Variables Configurables */
      --queue-width: 350px;
      --queue-bg-color: rgba(0, 0, 0, 1);
      --queue-bg-color-transparent: rgba(0, 0, 0, 0.6);
      --queue-bg-color-tertiary: rgba(0, 0, 0, 0.3);
      --queue-accent-color: #00e5ff;
      --queue-text-color: #ffffff;
      --queue-font-family: 'Montserrat', sans-serif;
      --queue-font-size: 16px;
      --queue-item-spacing: 15px;
      --queue-border-radius: 6px;
      --queue-item-min-height: 80px;
      --queue-padding: 15px;
      --queue-text-gap: 4px;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: transparent; /* Importante para OBS */
      overflow: hidden;
      font-family: var(--queue-font-family);
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center; /* Centrado horizontal */
      justify-content: flex-start; /* Lista vertical desde arriba */
    }

    #queue-container {
      margin: 20px;
      width: var(--queue-width);
      display: flex;
      flex-direction: column;
      gap: var(--queue-item-spacing);
    }

    .queue-item {
      background: transparent;
      margin-bottom: var(--queue-item-spacing); /* Gap */
      display: flex;
      flex-direction: column;
      /* Animaci√≥n de layout (colapso al salir) */
      transition: max-height 0.8s cubic-bezier(0.4, 0, 0.2, 1), 
                  margin-bottom 0.8s cubic-bezier(0.4, 0, 0.2, 1), 
                  opacity 0.5s ease;
      max-height: 200px; /* Aumentado para permitir alturas mayores */
      overflow: visible; /* Importante para ver el elemento salir volando */
    }

    /* Caja visual interna */
    .queue-item-inner {
      box-sizing: border-box; /* Incluir padding en el c√°lculo de altura */
      background: var(--queue-bg-color);
      border-left: 5px solid var(--queue-accent-color); 
      border-radius: var(--queue-border-radius);
      min-height: var(--queue-item-min-height);
      padding: var(--queue-padding);
      color: var(--queue-text-color);
      box-shadow: 0 5px 15px rgba(0,0,0,0.4);
      display: flex;
      flex-direction: column;
      justify-content: center; /* Centrar verticalmente si la altura es grande */
      
      /* Animaci√≥n de Entrada Base */
      opacity: 0;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    /* Estilos para tarjetas en cola (2¬™) */
    .queue-item:nth-child(2) .queue-item-inner {
      background: var(--queue-bg-color-transparent, var(--queue-bg-color));
    }

    /* Estilos para tarjetas en cola (3¬™ en adelante) */
    .queue-item:nth-child(n+3) .queue-item-inner {
      background: var(--queue-bg-color-tertiary, var(--queue-bg-color-transparent));
    }

    /* Estado Vac√≠o */
    #empty-state {
      display: none;
      color: var(--queue-text-color);
      opacity: 0.7;
      text-align: center;
      margin-top: 50px;
      font-weight: 300;
      background: var(--queue-bg-color-tertiary);
      padding: 20px;
      border-radius: var(--queue-border-radius);
      width: 100%;
      box-sizing: border-box;
    }
    #empty-state.visible {
      display: block;
      animation: fadeIn 0.5s ease;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 0.7; } }

    .queue-item:nth-child(n+2) .item-header {
      display: none !important;
    }

    /* Variantes de Entrada (se aplican con .show) */
    
    /* 1. Slide Left (Original/Default: translateX(-30px)) */
    .anim-entry-slide-left .queue-item-inner { transform: translateX(-30px); }
    .anim-entry-slide-left .queue-item.show .queue-item-inner { opacity: 1; transform: translateX(0); }

    /* 2. Slide Up */
    .anim-entry-slide-up .queue-item-inner { transform: translateY(30px); }
    .anim-entry-slide-up .queue-item.show .queue-item-inner { opacity: 1; transform: translateY(0); }

    /* 3. Fade */
    .anim-entry-fade .queue-item-inner { transform: scale(1); }
    .anim-entry-fade .queue-item.show .queue-item-inner { opacity: 1; }

    /* 4. Zoom In */
    .anim-entry-zoom .queue-item-inner { transform: scale(0.5); }
    .anim-entry-zoom .queue-item.show .queue-item-inner { opacity: 1; transform: scale(1); }


    /* Variantes de Salida (se aplican con .removing) */
    /* Nota: .removing en el wrapper colapsa height/margin. La animaci√≥n visual va en inner */
    .queue-item.removing {
      max-height: 0;
      margin-bottom: 0;
      /* Delay layout collapse to allow exit animation to play first */
      transition-delay: 0.5s;
    }

    /* FIX: Usar transiciones en lugar de animaciones para asegurar consistencia con la entrada */
    /* La clase .queue-item-inner ya tiene transition: all 0.5s cubic-bezier(...) definida arriba */

    /* 1. Slide Right (Original/Default) */
    .anim-exit-slide-right .queue-item.removing .queue-item-inner { 
      transform: translateX(0) !important;
      opacity: 1 !important;
    }
    .anim-exit-slide-right .queue-item.removing.removing-active .queue-item-inner { 
      transform: translateX(100%) !important;
      opacity: 0 !important;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    }

    /* 2. Slide Down */
    .anim-exit-slide-down .queue-item.removing .queue-item-inner { 
      transform: translateY(0) !important;
      opacity: 1 !important;
    }
    .anim-exit-slide-down .queue-item.removing.removing-active .queue-item-inner { 
      transform: translateY(50px) !important;
      opacity: 0 !important;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    }

    /* 3. Fade Out */
    .anim-exit-fade .queue-item.removing .queue-item-inner { 
      opacity: 1 !important;
    }
    .anim-exit-fade .queue-item.removing.removing-active .queue-item-inner { 
      opacity: 0 !important;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    }

    /* 4. Zoom Out */
    .anim-exit-zoom .queue-item.removing .queue-item-inner { 
      transform: scale(1) !important;
      opacity: 1 !important;
    }
    .anim-exit-zoom .queue-item.removing.removing-active .queue-item-inner { 
      transform: scale(0.5) !important;
      opacity: 0 !important;
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    }


    /* Keyframes - Ya no se usan para salida, pero se mantienen por si acaso se reusan para otra cosa */
    @keyframes slideOutRight {
      from { opacity: 1; transform: translateX(0); }
      to { opacity: 0; transform: translateX(100%); }
    }
    @keyframes slideOutDown {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(50px); }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    @keyframes zoomOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.5); }
    }

    .item-header {
      font-size: calc(var(--queue-font-size) * 0.7); /* 11px relativo a 16px */
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--queue-accent-color);
      font-weight: 800;
      margin-bottom: var(--queue-text-gap);
      display: flex;
      justify-content: space-between;
    }
    .hide-header .item-header { display: none !important; }

    .item-song {
      font-size: calc(var(--queue-font-size) * 1.125); /* 18px */
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: calc(var(--queue-text-gap) * 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .item-artist {
      font-size: calc(var(--queue-font-size) * 0.875); /* 14px */
      color: rgba(255,255,255,0.7); /* Usar opacidad para adaptarse al color de texto base */
      margin-bottom: var(--queue-text-gap);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .hide-artist .item-artist { display: none !important; }

    .item-user {
      font-size: calc(var(--queue-font-size) * 0.7); /* 11px */
      color: rgba(255,255,255,0.5);
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .hide-user .item-user { display: none !important; }

    .user-badge {
      background: #333;
      padding: 1px 6px;
      border-radius: 3px;
      color: #fff;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      max-width: 100%;
    }

    .user-name {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .user-insignia {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 1px 6px;
      border-radius: 9999px;
      font-weight: 700;
      font-size: 10px;
      line-height: 1;
      background: rgba(255,255,255,0.12);
      color: #fff;
      flex: 0 0 auto;
    }
    .user-insignia.vip { background: #000; color: #fff; }
    .user-insignia.z0-vip { background: #e91e63; color: #fff; }
    .user-insignia.donador { background: #ffa500; color: #fff; }
    
    /* Nuevas insignias de donador */
    .user-insignia.donador-oro { 
      background: #ffd700; 
      color: #000; 
      border: 1px solid #b8860b; 
      box-shadow: 0 0 4px rgba(255, 215, 0, 0.6);
    }
    .user-insignia.donador-plata { 
      background: #e5e7eb; 
      color: #374151; 
      border: 1px solid #9ca3af; 
    }
    .user-insignia.donador-bronce { 
      background: #cd7f32; 
      color: #fff; 
      border: 1px solid #8b4513; 
    }

    .user-insignia.z0-fan {
      background: #ffffff;
      color: #000000;
      border: 1px solid rgba(0,0,0,0.12);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.06), 0 2px 4px rgba(0,0,0,0.08);
    }
    .user-insignia.z0-platino {
      background: linear-gradient(135deg, #c0c0c0, #e6e6e6 50%, #b3b3b3);
      color: #333333;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      background-size: 200% 200%;
    }

    /* Animaci√≥n de posici√≥n */
    .queue-pos-1 .queue-item-inner { border-left-color: var(--queue-accent-color); }
    .queue-pos-2 .queue-item-inner { border-left-color: var(--queue-accent-color); opacity: 0.9; filter: brightness(0.8); }
    .queue-pos-3 .queue-item-inner { border-left-color: var(--queue-accent-color); opacity: 0.8; filter: brightness(0.6); }

    /* Panel de Configuraci√≥n */
    
    /* Notificaciones Toast */
    #notification-container {
      position: fixed;
      top: 100px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 20000;
      pointer-events: none;
    }

    .notification-toast {
      background: rgba(0, 0, 0, 0.85);
      border-left: 5px solid #00e5ff;
      border-radius: 8px;
      padding: 15px 20px;
      color: #fff;
      font-family: 'Montserrat', sans-serif;
      box-shadow: 0 5px 15px rgba(0,0,0,0.5);
      min-width: 250px;
      animation: slideInRight 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .notification-toast.points { border-left-color: #ffd700; }
    
    .notification-icon { font-size: 24px; }
    .notification-content { display: flex; flex-direction: column; }
    .notification-title { font-weight: bold; font-size: 14px; opacity: 0.8; text-transform: uppercase; margin-bottom: 2px; }
    .notification-msg { font-weight: bold; font-size: 18px; }

    @keyframes slideInRight {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes fadeOutRight {
      to { transform: translateX(100%); opacity: 0; }
    }

    #roulette-btn {
      position: fixed;
      top: 20px;
      left: 80px;
      z-index: 10001;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.2);
      color: white;
      border-radius: 50%;
      cursor: grab;
      font-size: 24px;
      transition: background 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
      width: 50px;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      opacity: 0.2;
    }
    #roulette-btn:active { cursor: grabbing; }
    #roulette-btn:hover { opacity: 1; background: rgba(0,0,0,0.8); }

    #settings-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10001;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.2);
      color: white;
      border-radius: 50%;
      cursor: grab;
      font-size: 20px;
      transition: background 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
      
      width: 50px;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      opacity: 0.2;
    }
    #settings-btn:active {
      cursor: grabbing;
    }
    #settings-btn:hover { 
      opacity: 1; 
      background: rgba(0,0,0,0.8);
    }

    #settings-panel {
      position: fixed;
      top: 70px;
      left: 20px;
      transform: none;
      transform-origin: top left;
      background: #1a1a1a;
      color: white;
      padding: 20px;
      border-radius: 10px;
      width: 300px;
      z-index: 10002;
      box-shadow: 0 10px 40px rgba(0,0,0,0.8);
      display: none;
      max-height: 80vh;
      overflow-y: auto;
      font-family: sans-serif;
    }
    #settings-panel.open { 
      display: block; 
      animation: menu-pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    @keyframes menu-pop {
      from { opacity: 0; transform: scale(0.5); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .settings-group { margin-bottom: 15px; }
    .settings-group label { display: block; margin-bottom: 5px; font-size: 14px; color: #ccc; }
    .settings-group input[type="text"],
    .settings-group input[type="number"], 
    .settings-group select {
      width: 100%;
      padding: 8px;
      background: #333;
      border: 1px solid #444;
      color: white;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .settings-group input[type="color"] {
      width: 100%;
      height: 40px;
      border: none;
      background: none;
      cursor: pointer;
    }
    .settings-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    /* Tab Navigation Styles */
    .tab-nav {
      display: flex;
      border-bottom: 1px solid #444;
      margin-bottom: 20px;
    }
    .tab-btn {
      flex: 1;
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: #aaa;
      padding: 10px 5px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }
    .tab-btn:hover { color: #fff; }
    .tab-btn.active {
      color: var(--queue-accent-color, #00e5ff);
      border-bottom-color: var(--queue-accent-color, #00e5ff);
      font-weight: bold;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; animation: fadeInTab 0.3s ease; }
    @keyframes fadeInTab { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    .btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    .btn-save { background: #00e5ff; color: #000; }
    .btn-reset { background: #444; color: #fff; }

  </style>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
</head>
<body>

  <div id="queue-container">
    <div id="empty-state">
      <div style="font-size: 40px; margin-bottom: 10px;">üéµ</div>
      <div>Esperando solicitudes...</div>
    </div>
    <!-- Items se inyectar√°n aqu√≠ -->
  </div>

  <!-- Bot√≥n de Configuraci√≥n -->
  <div id="notification-container"></div>
  <button id="settings-btn" title="Configurar Overlay">‚öôÔ∏è</button>
  <button id="roulette-btn" title="Ruleta de Selecci√≥n">üé°</button>
  
  <!-- Indicador de Duraci√≥n Total -->
  <div id="total-duration-indicator" style="
      position: fixed; 
      bottom: 20px; 
      right: 20px; 
      background: rgba(0,0,0,0.7); 
      color: white; 
      padding: 8px 15px; 
      border-radius: 20px; 
      font-size: 14px; 
      font-weight: bold; 
      border: 1px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
      display: none;
      z-index: 9999;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
  ">
    ‚è≥ Tiempo Total: <span id="total-time-val">0m</span>
  </div>

  <!-- Roulette View (Replaces Queue) -->
  <div id="roulette-view" style="display: none; width: 95vw; height: 90vh; background: rgba(0,0,0,0.9); border-radius: 12px; flex-direction: row; align-items: center; justify-content: space-between; padding: 20px; box-sizing: border-box; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); margin: 20px;">
    
    <!-- Left: Participants Panel -->
    <div id="roulette-participants-panel" style="position: relative; height: 100%; display: flex; flex-direction: column; width: 250px; min-width: 250px; border-right: 1px solid rgba(255,255,255,0.1); padding-right: 20px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">
        
        <!-- Content Wrapper -->
        <div id="roulette-participants-content" style="flex: 1; display: flex; flex-direction: column; gap: 10px; overflow: hidden; opacity: 1; transition: opacity 0.2s; white-space: nowrap;">
            
            <!-- Mode Switcher -->
            <div style="display: flex; gap: 5px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 6px;">
                <button id="mode-btn-list" onclick="setRouletteMode('list')" style="flex: 1; border: none; background: var(--queue-accent-color); color: #000; padding: 5px; border-radius: 4px; font-size: 12px; font-weight: bold; cursor: pointer;">De la lista</button>
                <button id="mode-btn-new" onclick="setRouletteMode('new')" style="flex: 1; border: none; background: transparent; color: #aaa; padding: 5px; border-radius: 4px; font-size: 12px; font-weight: bold; cursor: pointer;">Ruleta nueva</button>
            </div>

            <h3 style="color: var(--queue-accent-color); margin: 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px;">
                Participantes <span id="participant-count" style="font-size: 12px; background: #333; padding: 2px 6px; border-radius: 4px; color: #fff;">0</span>
            </h3>
            <div id="participants-list" style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 5px;"></div>
            <div style="display: flex; gap: 5px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                <input type="text" id="add-participant-input" placeholder="Nombre..." style="flex: 1; padding: 8px; background: #222; border: 1px solid #444; color: white; border-radius: 4px;">
                <button id="add-participant-btn" style="background: var(--queue-accent-color); color: #000; border: none; padding: 0 15px; border-radius: 4px; font-weight: bold; cursor: pointer;">+</button>
            </div>
        </div>
        
        <!-- Toggle Tab -->
        <div id="participants-toggle-tab" onclick="toggleParticipantsPanel()" style="position: absolute; right: -20px; top: 50%; transform: translateY(-50%); width: 20px; height: 60px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.2); border-left: none; border-radius: 0 8px 8px 0; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #fff; font-size: 14px; z-index: 100; backdrop-filter: blur(5px);">
            ‚Äπ
        </div>

    </div>

    <!-- Right Section: Wheel Area + Bottom Controls -->
    <div style="flex: 3; display: flex; flex-direction: column; height: 100%; position: relative;">
        
        <!-- Winner Display (Hidden) -->
        <div id="winner-display" style="display: none; font-size: 40px; font-weight: 900; color: var(--queue-accent-color); text-align: center; min-height: 60px; text-shadow: 0 0 20px rgba(0,229,255,0.4); margin-bottom: 10px; z-index: 10; padding-top: 10px;"></div>

        <!-- Wheel Play Area -->
        <div id="roulette-play-area" style="flex: 1; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center;">
            
            <!-- Draggable & Resizable Wheel Wrapper -->
            <div id="roulette-wheel-wrapper" style="position: absolute; width: 500px; height: 500px; cursor: grab; user-select: none; display: flex; align-items: center; justify-content: center;">
                <!-- Canvas -->
                <canvas id="roulette-canvas" width="600" height="600" style="width: 100%; height: 100%; object-fit: contain; pointer-events: none;"></canvas>
                
                <!-- Winner Label (Center) -->
                <div id="winner-label" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 5px 15px; border-radius: 20px; font-weight: bold; font-size: 20px; pointer-events: none; display: none; z-index: 5; border: 2px solid var(--queue-accent-color); text-align: center; max-width: 80%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></div>

                <!-- Arrow -->
                <div style="position: absolute; top: 50%; right: 0; transform: translateY(-50%); width: 0; height: 0; border-top: 25px solid transparent; border-bottom: 25px solid transparent; border-right: 50px solid white; filter: drop-shadow(0 0 5px rgba(0,0,0,0.8)); pointer-events: none;"></div>

                <!-- Resize Handles -->
                <div class="resize-handle nw" data-handle="nw" style="position: absolute; top: -8px; left: -8px; width: 16px; height: 16px; background: var(--queue-accent-color); border: 2px solid white; cursor: nw-resize; z-index: 20; border-radius: 50%;"></div>
                <div class="resize-handle ne" data-handle="ne" style="position: absolute; top: -8px; right: -8px; width: 16px; height: 16px; background: var(--queue-accent-color); border: 2px solid white; cursor: ne-resize; z-index: 20; border-radius: 50%;"></div>
                <div class="resize-handle sw" data-handle="sw" style="position: absolute; bottom: -8px; left: -8px; width: 16px; height: 16px; background: var(--queue-accent-color); border: 2px solid white; cursor: sw-resize; z-index: 20; border-radius: 50%;"></div>
                <div class="resize-handle se" data-handle="se" style="position: absolute; bottom: -8px; right: -8px; width: 16px; height: 16px; background: var(--queue-accent-color); border: 2px solid white; cursor: se-resize; z-index: 20; border-radius: 50%;"></div>
            </div>

        </div>

        <!-- Bottom Controls (Fixed at bottom) -->
        <div style="height: 100px; display: flex; gap: 20px; align-items: center; justify-content: center; border-top: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.3); position: relative;">
            <button id="spin-btn" style="padding: 15px 50px; font-size: 24px; font-weight: 900; background: #e91e63; color: white; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 0 30px rgba(233,30,99,0.5); text-transform: uppercase; letter-spacing: 2px; transition: transform 0.1s, box-shadow 0.3s;">GIRAR</button>
            <button id="close-roulette" style="padding: 15px 30px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 50px; cursor: pointer; font-weight: bold; display: flex; align-items: center; justify-content: center; gap: 10px; transition: background 0.2s;">
                <span>üîô</span> Volver
            </button>
            
            <!-- Roulette Settings Button -->
            <button id="roulette-settings-btn" onclick="toggleRouletteSettings()" style="position: absolute; right: 20px; background: transparent; border: none; font-size: 24px; cursor: pointer; opacity: 0.7; transition: opacity 0.2s;">
                ‚öôÔ∏è
            </button>
        </div>

    </div>

  </div>

  <!-- Roulette Settings Panel -->
  <div id="roulette-settings-panel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; background: rgba(20,20,20,0.95); border: 1px solid #444; border-radius: 12px; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); z-index: 20000; flex-direction: column; gap: 15px;">
    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; padding-bottom: 10px;">
        <h3 style="margin: 0; color: white;">Configuraci√≥n Ruleta</h3>
        <button onclick="toggleRouletteSettings()" style="background: transparent; border: none; color: #ff4444; font-size: 20px; cursor: pointer;">√ó</button>
    </div>
    
    <div style="display: flex; flex-direction: column; gap: 15px;">
        <div class="settings-group">
            <label style="color: #ccc; display: block; margin-bottom: 5px;">Tama√±o de Fuente (px)</label>
            <input type="number" id="r-font-size" value="14" oninput="updateRoulettePreview()" style="width: 100%; padding: 8px; background: #333; border: 1px solid #555; color: white; border-radius: 4px;">
        </div>

        <div class="settings-group">
            <label style="color: #ccc; display: block; margin-bottom: 5px;">Color de Texto</label>
            <input type="color" id="r-text-color" value="#ffffff" oninput="updateRoulettePreview()" style="width: 100%; height: 40px; padding: 0; border: none; background: transparent; cursor: pointer;">
        </div>

        <div class="settings-group">
            <label style="color: #ccc; display: block; margin-bottom: 10px;">Temas</label>
            <div id="r-theme-selector" style="display: flex; gap: 10px; overflow-x: auto; padding-bottom: 10px; padding-top: 5px;">
                <!-- Themes will be injected here -->
            </div>
            <!-- Hidden textarea to store current custom colors if needed, or just use state -->
            <textarea id="r-colors" style="display: none;"></textarea>
        </div>
    </div>

    <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px;">
        <button onclick="saveRouletteSettings()" style="background: var(--queue-accent-color); color: black; border: none; padding: 10px 20px; border-radius: 6px; font-weight: bold; cursor: pointer;">Guardar</button>
    </div>
  </div>

  <!-- Panel de Configuraci√≥n -->
  <div id="settings-panel">
    <h3 style="margin-top:0; border-bottom: 1px solid #333; padding-bottom: 10px;">Configuraci√≥n</h3>
    
    <div class="tab-nav">
      <button class="tab-btn active" onclick="switchTab('general')">General</button>
      <button class="tab-btn" onclick="switchTab('appearance')">Apariencia</button>
      <button class="tab-btn" onclick="switchTab('animations')">Animaci√≥n</button>
      <button class="tab-btn" onclick="switchTab('data')">Datos/API</button>
    </div>

    <!-- TAB: GENERAL -->
    <div id="tab-general" class="tab-content active">
        <div class="settings-group">
          <label>Ancho de Tarjeta (px)</label>
          <input type="number" id="inp-width" value="350">
        </div>

        <div class="settings-group">
          <label>Alto M√≠nimo de Tarjeta (px)</label>
          <input type="number" id="inp-minHeight" value="80" min="0">
        </div>

        <div class="settings-group">
          <label>Espacio entre Tarjetas (px)</label>
          <input type="number" id="inp-spacing" value="15" min="0">
        </div>

        <div class="settings-group">
          <label>Radio de Borde (px)</label>
          <input type="number" id="inp-borderRadius" value="6">
        </div>

        <div class="settings-group">
          <label>Relleno (Padding) (px)</label>
          <input type="number" id="inp-padding" value="15" min="0">
        </div>

        <div class="settings-group">
          <label>Espaciado Textos (Gap) (px)</label>
          <input type="number" id="inp-textGap" value="4" min="0">
        </div>
        
        <div class="settings-group">
          <label>Simulaci√≥n</label>
          <div style="display: flex; gap: 10px;">
            <button class="btn" style="background: #333;" onclick="simulateQueueRequest()">+ Pedido</button>
            <button class="btn" style="background: #333;" onclick="simulateToggleFirst(event)" title="Shift+click = skip (sin puntos)">Next</button>
          </div>
        </div>
    </div>

    <!-- TAB: APARIENCIA -->
    <div id="tab-appearance" class="tab-content">
        <div class="settings-group" style="display: flex; gap: 10px; flex-wrap: wrap;">
           <label style="width: 100%;">Visibilidad de Elementos</label>
           <label style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
             <input type="checkbox" id="inp-showHeader" checked> Cabecera
           </label>
           <label style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
             <input type="checkbox" id="inp-showArtist" checked> Artista
           </label>
           <label style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
             <input type="checkbox" id="inp-showUser" checked> Usuario
           </label>
           <label style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
             <input type="checkbox" id="inp-showEmpty" checked> Mensaje Vac√≠o
           </label>
        </div>

        <div class="settings-group">
          <label>Fuente</label>
          <select id="inp-font">
            <option value="'Montserrat', sans-serif">Montserrat</option>
            <option value="'Roboto', sans-serif">Roboto</option>
            <option value="'Open Sans', sans-serif">Open Sans</option>
            <option value="'Lato', sans-serif">Lato</option>
            <option value="sans-serif">System Default</option>
          </select>
        </div>

        <div class="settings-group">
          <label>Tama√±o de Fuente Base (px)</label>
          <input type="number" id="inp-fontSize" value="16">
        </div>

        <div class="settings-group">
          <label>Color de Acento</label>
          <input type="color" id="inp-accent" value="#00e5ff">
        </div>

        <div class="settings-group">
          <label>Color de Fondo</label>
          <input type="color" id="inp-bg" value="#000000">
        </div>

        <div class="settings-group">
          <label>Color de Texto</label>
          <input type="color" id="inp-text" value="#ffffff">
        </div>

        <div class="settings-group">
          <label>Opacidad Tarjeta Principal</label>
          <input type="range" id="inp-primaryOpacity" min="0" max="100" value="100" oninput="document.getElementById('primary-opacity-val').innerText = this.value + '%'">
          <span id="primary-opacity-val" style="float: right; margin-top: -30px; margin-right: 10px; font-size: 12px; color: #aaa;">100%</span>
        </div>

        <div class="settings-group">
          <label>Opacidad Tarjetas Cola</label>
          <input type="range" id="inp-secondaryOpacity" min="0" max="100" value="60" oninput="document.getElementById('opacity-val').innerText = this.value + '%'">
          <span id="opacity-val" style="float: right; margin-top: -30px; margin-right: 10px; font-size: 12px; color: #aaa;">60%</span>
        </div>
    </div>

    <!-- TAB: ANIMACIONES -->
    <div id="tab-animations" class="tab-content">
        <div class="settings-group">
          <label>Animaci√≥n de Entrada</label>
          <select id="inp-animEntry">
            <option value="anim-entry-slide-left">Slide Left (Default)</option>
            <option value="anim-entry-slide-up">Slide Up</option>
            <option value="anim-entry-fade">Fade In</option>
            <option value="anim-entry-zoom">Zoom In</option>
          </select>
        </div>

        <div class="settings-group">
          <label>Animaci√≥n de Salida</label>
          <select id="inp-animExit">
            <option value="anim-exit-slide-right">Slide Right (Default)</option>
            <option value="anim-exit-slide-down">Slide Down</option>
            <option value="anim-exit-fade">Fade Out</option>
            <option value="anim-exit-zoom">Zoom Out</option>
          </select>
        </div>
    </div>

    <!-- TAB: DATA/API (NUEVO) -->
    <div id="tab-data" class="tab-content">
        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-autocorrect"> 
             <div>
               <strong>üß† Autocorregir Nombres</strong><br>
               <small style="color:#aaa;">Usa Apple Music para corregir t√≠tulos</small>
             </div>
           </label>
        </div>

        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-showAlbumArt"> 
             <div>
               <strong>üé® Portadas HQ</strong><br>
               <small style="color:#aaa;">Muestra car√°tula del √°lbum (600x600)</small>
             </div>
           </label>
        </div>

        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-showWaitTime"> 
             <div>
               <strong>‚è±Ô∏è Tiempo de Espera</strong><br>
               <small style="color:#aaa;">Muestra "Siguiente" o "en X min"</small>
             </div>
           </label>
        </div>

        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-showTotalDuration"> 
             <div>
               <strong>üìä Duraci√≥n Total Cola</strong><br>
               <small style="color:#aaa;">Indicador flotante del tiempo total</small>
             </div>
           </label>
        </div>

        <div class="settings-group">
           <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
             <input type="checkbox" id="inp-syncAppleMusic"> 
             <div>
               <strong>üéµ Sincronizar Apple Music</strong><br>
               <small style="color:#aaa;">Marca canciones como reproducidas (Req. Cider/Widget)</small>
             </div>
           </label>
        </div>
    </div>

    <div class="settings-actions">
      <button class="btn btn-reset" onclick="resetSettings()">Reset</button>
      <button class="btn btn-save" onclick="saveSettings()">Guardar</button>
    </div>
  </div>

  <!-- Controles de Depuraci√≥n -->
   <div id="debug-controls" style="position: fixed; bottom: 20px; left: 20px; opacity: 0.2; transition: opacity 0.3s; z-index: 10000;">
     <button onclick="simulateQueueRequest()" style="padding: 10px; cursor: pointer;">‚ûï Simular Pedido</button>
     <button onclick="toggleMarkPanel()" onmouseenter="showMarkPanel()" onmouseleave="scheduleHideMarkPanel()" style="padding: 10px; cursor: pointer;" title="Abrir acciones de marcado">‚úÖ Marcar</button>
     <button onclick="toggleDebugBorders()" style="padding: 10px; cursor: pointer;">üñºÔ∏è Ver Bordes</button>
     <button onclick="toggleWidgetMover()" style="padding: 10px; cursor: pointer;">üß© Mover Widget</button>
   </div>
   <div id="mark-panel" onmouseenter="cancelHideMarkPanel()" onmouseleave="scheduleHideMarkPanel()" style="position: fixed; bottom: 80px; left: 20px; z-index: 10001; background: rgba(0,0,0,0.80); border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 10px; color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; width: 220px;" hidden>
     <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
       <strong>Marcar canci√≥n</strong>
       <button onclick="toggleMarkPanel()" style="padding: 6px 8px; cursor:pointer; border-radius: 10px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.06); color:#fff;">Cerrar</button>
     </div>
     <div style="display:flex; gap:8px;">
       <button onclick="markFirstPendingFromPanel(true)" style="flex:1; padding: 10px; cursor:pointer; border-radius: 12px; border: 1px solid rgba(255,255,255,0.25); background: rgba(251,191,36,0.15); color:#fff; font-weight: 700;">‚è≠Ô∏è Skip</button>
       <button onclick="markFirstPendingFromPanel(false)" style="flex:1; padding: 10px; cursor:pointer; border-radius: 12px; border: 1px solid rgba(255,255,255,0.25); background: rgba(34,197,94,0.15); color:#fff; font-weight: 700;">‚úÖ Reproducida</button>
     </div>
     <div style="font-size: 12px; opacity: 0.85; margin-top: 10px; line-height: 1.25;">
       Skip marca sin puntos. Reproducida marca y suma puntos.
     </div>
   </div>
   <div id="widget-mover" style="position: fixed; bottom: 80px; left: 20px; z-index: 10001; background: rgba(0,0,0,0.80); border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 10px; color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; width: 320px; max-height: 50vh; overflow: auto;" hidden>
     <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
       <strong>Mover tarjetas (cola)</strong>
       <div style="display:flex; gap:8px; align-items:center;">
         <button onclick="resetManualOrder()" style="padding: 6px 8px; cursor:pointer; border-radius: 10px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.06); color:#fff;">Reset</button>
         <button onclick="toggleWidgetMover()" style="padding: 6px 8px; cursor:pointer; border-radius: 10px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.06); color:#fff;">Cerrar</button>
       </div>
     </div>
     <div id="widget-mover-list" style="display:flex; flex-direction:column; gap:8px;"></div>
     <div style="font-size: 12px; opacity: 0.85; margin-top: 10px; line-height: 1.25;">
       Arrastra una tarjeta para cambiar el orden. Esto escribe en manualOrders del d√≠a.
     </div>
   </div>

  <script>
    // --- Apple Music / Cider Variables (Global) ---
    let ciderSocket = null;
    let lastAutoMarkedSong = ""; 

    function toggleDebugBorders() {
      const container = document.getElementById('queue-container');
      if (container.style.border) {
        container.style.border = '';
        container.style.background = '';
      } else {
        container.style.border = '5px solid red';
        container.style.background = 'rgba(255, 0, 0, 0.2)';
      }
    }

    function toggleWidgetMover() {
      const panel = document.getElementById('widget-mover');
      if (!panel) return;
      panel.hidden = !panel.hidden;
      if (!panel.hidden) {
        try { renderWidgetMoverList(); } catch (_) {}
      }
    }

    function toggleMarkPanel() {
      const panel = document.getElementById('mark-panel');
      if (!panel) return;
      panel.hidden = !panel.hidden;
    }

    let markPanelHideTimer = null;
    function showMarkPanel() {
      const panel = document.getElementById('mark-panel');
      if (!panel) return;
      if (markPanelHideTimer) {
        clearTimeout(markPanelHideTimer);
        markPanelHideTimer = null;
      }
      panel.hidden = false;
    }
    function cancelHideMarkPanel() {
      if (markPanelHideTimer) {
        clearTimeout(markPanelHideTimer);
        markPanelHideTimer = null;
      }
    }
    function scheduleHideMarkPanel() {
      const panel = document.getElementById('mark-panel');
      if (!panel) return;
      if (markPanelHideTimer) clearTimeout(markPanelHideTimer);
      markPanelHideTimer = setTimeout(() => {
        try { panel.hidden = true; } catch (_) {}
      }, 220);
    }

    function getPendingRequestsForMover() {
      let pending = allRequests.filter(req => {
        const id = generateSongId(req);
        return !playedSongIds.has(id);
      });
      pending = applyOrder(pending, currentManualOrder);
      return pending;
    }

    async function persistManualOrder(orderArr) {
      currentManualOrder = Array.isArray(orderArr) ? orderArr : [];
      try { localStorage.setItem(`manualOrder:${currentDay}`, JSON.stringify(currentManualOrder)); } catch (_) {}
      if (!db || !firebase?.firestore?.FieldValue) return;
      try {
        await db.collection('manualOrders').doc(currentDay).set({
          order: currentManualOrder,
          day: currentDay,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
      } catch (_) {}
    }

    async function resetManualOrder() {
      await persistManualOrder([]);
      try { renderQueue(); } catch (_) {}
      try { renderWidgetMoverList(); } catch (_) {}
    }

    function renderWidgetMoverList() {
      const list = document.getElementById('widget-mover-list');
      if (!list) return;
      list.innerHTML = '';

      const pending = getPendingRequestsForMover();
      if (!pending.length) {
        const empty = document.createElement('div');
        empty.textContent = 'No hay canciones pendientes.';
        empty.style.opacity = '0.85';
        list.appendChild(empty);
        return;
      }

      const orderKeys = pending.map(req => String(req?.docId || req?.id || generateSongId(req) || '')).filter(Boolean);

      let draggingKey = null;

      const render = () => {
        list.innerHTML = '';
        orderKeys.forEach((key, idx) => {
          const req = pending.find(r => String(r?.docId || r?.id || generateSongId(r) || '') === key);
          const cancion = (req?.cancion || req?.songName || req?.song || req?.name || '').trim();
          const artista = (req?.artista || req?.artistName || req?.artist || '').trim();
          const usuario = (req?.displayName || req?.usuario || req?.user || req?.username || '').trim();

          const row = document.createElement('div');
          row.draggable = true;
          row.dataset.key = key;
          row.style.display = 'flex';
          row.style.gap = '10px';
          row.style.alignItems = 'center';
          row.style.padding = '10px';
          row.style.borderRadius = '12px';
          row.style.border = '1px solid rgba(255,255,255,0.18)';
          row.style.background = 'rgba(255,255,255,0.06)';
          row.style.cursor = 'grab';
          row.style.userSelect = 'none';

          const left = document.createElement('div');
          left.textContent = String(idx + 1);
          left.style.width = '26px';
          left.style.height = '26px';
          left.style.borderRadius = '8px';
          left.style.display = 'flex';
          left.style.alignItems = 'center';
          left.style.justifyContent = 'center';
          left.style.fontWeight = '800';
          left.style.background = 'rgba(0,229,255,0.18)';
          left.style.border = '1px solid rgba(0,229,255,0.55)';

          const mid = document.createElement('div');
          mid.style.display = 'flex';
          mid.style.flexDirection = 'column';
          mid.style.gap = '2px';
          mid.style.minWidth = '0';
          mid.style.flex = '1';

          const title = document.createElement('div');
          title.textContent = cancion || 'Desconocida';
          title.style.fontWeight = '800';
          title.style.whiteSpace = 'nowrap';
          title.style.overflow = 'hidden';
          title.style.textOverflow = 'ellipsis';

          const sub = document.createElement('div');
          sub.textContent = `${artista || 'Desconocido'} ‚Ä¢ ${usuario || 'An√≥nimo'}`;
          sub.style.fontSize = '12px';
          sub.style.opacity = '0.85';
          sub.style.whiteSpace = 'nowrap';
          sub.style.overflow = 'hidden';
          sub.style.textOverflow = 'ellipsis';

          mid.appendChild(title);
          mid.appendChild(sub);

          const grip = document.createElement('div');
          grip.textContent = '‚ãÆ‚ãÆ';
          grip.style.opacity = '0.8';
          grip.style.fontWeight = '900';
          grip.style.padding = '0 4px';

          row.appendChild(left);
          row.appendChild(mid);
          row.appendChild(grip);

          row.addEventListener('dragstart', (e) => {
            draggingKey = key;
            try { e.dataTransfer.effectAllowed = 'move'; } catch (_) {}
          });
          row.addEventListener('dragover', (e) => {
            e.preventDefault();
          });
          row.addEventListener('drop', async (e) => {
            e.preventDefault();
            const targetKey = row.dataset.key;
            if (!draggingKey || !targetKey || draggingKey === targetKey) return;
            const from = orderKeys.indexOf(draggingKey);
            const to = orderKeys.indexOf(targetKey);
            if (from < 0 || to < 0) return;
            orderKeys.splice(from, 1);
            orderKeys.splice(to, 0, draggingKey);
            await persistManualOrder(orderKeys.slice());
            try { renderQueue(); } catch (_) {}
            render();
          });

          list.appendChild(row);
        });
      };

      render();
    }
    
    // --- Configuraci√≥n / Settings Logic ---
    function switchTab(tabName) {
      // Buttons
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.innerText.toLowerCase().includes(tabName) || 
            (tabName === 'data' && btn.innerText.includes('Datos'))) {
           // Simple check based on text or click handler
        }
      });
      // But simpler: just use event.target or match logic
      const tabs = ['general', 'appearance', 'animations', 'data'];
      tabs.forEach(t => {
        const content = document.getElementById('tab-' + t);
        if (content) {
            content.classList.toggle('active', t === tabName);
        }
      });
      
      // Update buttons visual state
      const btns = document.querySelectorAll('.tab-btn');
      btns.forEach(btn => {
         // Check if this button corresponds to tabName
         const onclick = btn.getAttribute('onclick');
         if (onclick && onclick.includes(`'${tabName}'`)) {
             btn.classList.add('active');
         } else {
             btn.classList.remove('active');
         }
      });
    }

    const defaultSettings = {
      width: 350,
      minHeight: 80,
      spacing: 15,
      padding: 15,
      textGap: 4,
      borderRadius: 6,
      showHeader: true,
      showArtist: true,
      showUser: true,
      showEmpty: true,
      animEntry: 'anim-entry-slide-left',
      animExit: 'anim-exit-slide-right',
      font: "'Montserrat', sans-serif",
      fontSize: 16,
      accent: "#00e5ff",
      bg: "#000000",
      primaryOpacity: 100,
      secondaryOpacity: 60,
      text: "#ffffff",
      // New Data/API Settings
      autocorrect: false,
      showAlbumArt: false,
      showWaitTime: true,
      showTotalDuration: true,
      syncAppleMusic: true
    };

    window.appliedSettings = { ...defaultSettings };

    function loadSettings() {
      const saved = localStorage.getItem('queue_overlay_settings');
      // Merge saved with default to ensure new keys exist
      const settings = saved ? { ...defaultSettings, ...JSON.parse(saved) } : defaultSettings;
      
      // Ensure animEntry is valid
      if (!settings.animEntry) settings.animEntry = defaultSettings.animEntry;
      if (!settings.animExit) settings.animExit = defaultSettings.animExit;
      
      applySettings(settings);
      
      // Update Inputs
      document.getElementById('inp-width').value = settings.width;
      document.getElementById('inp-minHeight').value = settings.minHeight;
      document.getElementById('inp-spacing').value = settings.spacing !== undefined ? settings.spacing : 15;
      document.getElementById('inp-padding').value = settings.padding !== undefined ? settings.padding : 15;
      document.getElementById('inp-textGap').value = settings.textGap !== undefined ? settings.textGap : 4;
      document.getElementById('inp-borderRadius').value = settings.borderRadius;
      
      document.getElementById('inp-showHeader').checked = settings.showHeader !== undefined ? settings.showHeader : true;
      document.getElementById('inp-showArtist').checked = settings.showArtist !== undefined ? settings.showArtist : true;
      document.getElementById('inp-showUser').checked = settings.showUser !== undefined ? settings.showUser : true;
      document.getElementById('inp-showEmpty').checked = settings.showEmpty !== undefined ? settings.showEmpty : true;

      document.getElementById('inp-animEntry').value = settings.animEntry;
      document.getElementById('inp-animExit').value = settings.animExit;
      
      document.getElementById('inp-font').value = settings.font;
      document.getElementById('inp-fontSize').value = settings.fontSize;
      document.getElementById('inp-accent').value = settings.accent;
      document.getElementById('inp-bg').value = settings.bg;
      
      const primaryOpacityVal = settings.primaryOpacity !== undefined ? settings.primaryOpacity : 100;
      document.getElementById('inp-primaryOpacity').value = primaryOpacityVal;
      document.getElementById('primary-opacity-val').innerText = primaryOpacityVal + '%';

      const opacityVal = settings.secondaryOpacity !== undefined ? settings.secondaryOpacity : 60;
      document.getElementById('inp-secondaryOpacity').value = opacityVal;
      document.getElementById('opacity-val').innerText = opacityVal + '%';

      document.getElementById('inp-text').value = settings.text;
      
      // New Inputs
      document.getElementById('inp-autocorrect').checked = settings.autocorrect !== undefined ? settings.autocorrect : false;
      document.getElementById('inp-showAlbumArt').checked = settings.showAlbumArt !== undefined ? settings.showAlbumArt : false;
      document.getElementById('inp-showWaitTime').checked = settings.showWaitTime !== undefined ? settings.showWaitTime : false;
      document.getElementById('inp-showTotalDuration').checked = settings.showTotalDuration !== undefined ? settings.showTotalDuration : false;
      document.getElementById('inp-syncAppleMusic').checked = settings.syncAppleMusic !== undefined ? settings.syncAppleMusic : false;
    }

    function applySettings(s) {
      window.appliedSettings = s;
      const root = document.documentElement;
      root.style.setProperty('--queue-width', s.width + 'px');
      root.style.setProperty('--queue-item-min-height', s.minHeight + 'px');
      root.style.setProperty('--queue-item-spacing', (s.spacing !== undefined ? s.spacing : 15) + 'px');
      root.style.setProperty('--queue-padding', (s.padding !== undefined ? s.padding : 15) + 'px');
      root.style.setProperty('--queue-text-gap', (s.textGap !== undefined ? s.textGap : 4) + 'px');
      root.style.setProperty('--queue-border-radius', s.borderRadius + 'px');
      
      // Set Global Animation Classes on Container
      const container = document.getElementById('queue-container');
      // Limpiar clases de animaci√≥n previas
      container.className = ''; 
      // A√±adir las seleccionadas
      container.classList.add(s.animEntry);
      container.classList.add(s.animExit);
      
      // Toggle visibility classes
      container.classList.toggle('hide-header', s.showHeader === false);
      container.classList.toggle('hide-artist', s.showArtist === false);
      container.classList.toggle('hide-user', s.showUser === false);

      // Empty State visibility logic moved to renderQueue or handled here via CSS class if needed
      // But renderQueue controls the DOM, so we store the setting in a global var or dataset
      container.dataset.showEmpty = s.showEmpty;
      const emptyState = document.getElementById('empty-state');
      if (emptyState) {
         // Si se debe mostrar el mensaje de vac√≠o y no hay elementos visibles en la cola
         // Verificamos si hay elementos .queue-item en el contenedor
         const hasItems = container.querySelectorAll('.queue-item:not(.removing)').length > 0;
         
         if (s.showEmpty && !hasItems) { 
             emptyState.classList.add('visible');
         } else {
             emptyState.classList.remove('visible');
         }
      }

      root.style.setProperty('--queue-font-family', s.font);
      root.style.setProperty('--queue-font-size', s.fontSize + 'px');
      root.style.setProperty('--queue-accent-color', s.accent);
      root.style.setProperty('--queue-text-color', s.text);
      
      const r = parseInt(s.bg.substr(1,2), 16);
      const g = parseInt(s.bg.substr(3,2), 16);
      const b = parseInt(s.bg.substr(5,2), 16);
      
      const primaryOpacity = (s.primaryOpacity !== undefined ? s.primaryOpacity : 100) / 100;
      const opacity = (s.secondaryOpacity !== undefined ? s.secondaryOpacity : 60) / 100;
      const tertiaryOpacity = Math.max(0, opacity * 0.5); // 50% de la opacidad secundaria
      
      root.style.setProperty('--queue-bg-color', `rgba(${r},${g},${b},${primaryOpacity})`);
      root.style.setProperty('--queue-bg-color-transparent', `rgba(${r},${g},${b},${opacity})`);
      root.style.setProperty('--queue-bg-color-tertiary', `rgba(${r},${g},${b},${tertiaryOpacity})`);
      
      // Force render queue to update empty state based on new settings if needed
      if (typeof renderQueue === 'function' && window.allRequests) {
        renderQueue(); 
      }

      // Cider Connection
      if (s.syncAppleMusic) {
        connectCider();
      }
    }

    function getSettingsFromInputs() {
      return {
        width: document.getElementById('inp-width').value,
        minHeight: document.getElementById('inp-minHeight').value,
        spacing: document.getElementById('inp-spacing').value,
        padding: document.getElementById('inp-padding').value,
        textGap: document.getElementById('inp-textGap').value,
        borderRadius: document.getElementById('inp-borderRadius').value,
        showHeader: document.getElementById('inp-showHeader').checked,
        showArtist: document.getElementById('inp-showArtist').checked,
        showUser: document.getElementById('inp-showUser').checked,
        showEmpty: document.getElementById('inp-showEmpty').checked,
        animEntry: document.getElementById('inp-animEntry').value,
        animExit: document.getElementById('inp-animExit').value,
        font: document.getElementById('inp-font').value,
        fontSize: document.getElementById('inp-fontSize').value,
        accent: document.getElementById('inp-accent').value,
        bg: document.getElementById('inp-bg').value,
        primaryOpacity: document.getElementById('inp-primaryOpacity').value,
        secondaryOpacity: document.getElementById('inp-secondaryOpacity').value,
        text: document.getElementById('inp-text').value,
        // New inputs
        autocorrect: document.getElementById('inp-autocorrect').checked,
        showAlbumArt: document.getElementById('inp-showAlbumArt').checked,
        showWaitTime: document.getElementById('inp-showWaitTime').checked,
        showTotalDuration: document.getElementById('inp-showTotalDuration').checked,
        syncAppleMusic: document.getElementById('inp-syncAppleMusic').checked
      };
    }

    function previewSettings() {
      const settings = getSettingsFromInputs();
      applySettings(settings);
    }

    function saveSettings() {
      const settings = getSettingsFromInputs();
      localStorage.setItem('queue_overlay_settings', JSON.stringify(settings));
      applySettings(settings);

      // Sync to Firestore
      if (db) {
        db.collection('userSettings').doc('global_queue_config').set(settings)
          .then(() => console.log("Configuraci√≥n guardada en la nube"))
          .catch(err => console.error("Error guardando configuraci√≥n:", err));
      }

      toggleSettings(); // close panel
    }
    
    // Listeners para vista previa en tiempo real
    document.addEventListener('DOMContentLoaded', () => {
        // Text/Number inputs
        ['inp-width', 'inp-minHeight', 'inp-spacing', 'inp-padding', 'inp-textGap', 'inp-borderRadius', 'inp-animEntry', 'inp-animExit', 
         'inp-font', 'inp-fontSize', 'inp-accent', 'inp-bg', 'inp-primaryOpacity', 'inp-secondaryOpacity', 'inp-text'].forEach(id => {
           const el = document.getElementById(id);
           if(el) {
             el.addEventListener('input', previewSettings);
             el.addEventListener('change', previewSettings);
           }
        });
        
        // Checkboxes - Visual Only
        ['inp-showHeader', 'inp-showArtist', 'inp-showUser', 'inp-showEmpty'].forEach(id => {
           const el = document.getElementById(id);
           if(el) {
             el.addEventListener('change', previewSettings);
           }
        });

        // Checkboxes - Data/Structure (Requires Re-render)
        ['inp-autocorrect', 'inp-showAlbumArt', 'inp-showWaitTime', 'inp-showTotalDuration', 'inp-syncAppleMusic'].forEach(id => {
           const el = document.getElementById(id);
           if(el) {
             el.addEventListener('change', () => {
                previewSettings();
                renderQueue(); // Force re-render to apply data changes
             });
           }
        });
    });

    function resetSettings() {
      if(confirm('¬øRestablecer valores por defecto?')) {
        applySettings(defaultSettings);
        localStorage.removeItem('queue_overlay_settings');
        loadSettings(); // reload inputs
        toggleSettings();
      }
    }

    function toggleSettings() {
      const panel = document.getElementById('settings-panel');
      panel.classList.toggle('open');
    }

    // Inicializar settings
    loadSettings();

    // Configuraci√≥n de Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyA6c3EaIvuPEfM6sTV0YHqCBHuz35ZmNIU",
      authDomain: "zero-strom-web.firebaseapp.com",
      projectId: "zero-strom-web",
      storageBucket: "zero-strom-web.firebasestorage.app",
      messagingSenderId: "758369466349",
      appId: "1:758369466349:web:f2ced362a5a049c70b59e4"
    };

    let db = null;
    try {
      if (typeof firebase !== 'undefined' && firebase.apps) {
        if (!firebase.apps.length) {
          firebase.initializeApp(firebaseConfig);
        }
        db = firebase.firestore();
      } else {
        console.warn('Firebase SDK not loaded');
      }
    } catch (e) {
      console.error('Error initializing Firebase:', e);
      try {
        db = firebase.firestore();
      } catch (_) {}
    }

    if (db) {
      db.collection('userSettings').doc('global_queue_config')
        .onSnapshot((doc) => {
          if (doc.exists) {
            console.log("Configuraci√≥n remota recibida");
            const remoteSettings = doc.data();
            const settings = { ...defaultSettings, ...remoteSettings };
            
            // Guardar localmente y aplicar
            localStorage.setItem('queue_overlay_settings', JSON.stringify(settings));
            applySettings(settings);
            
            // Actualizar inputs si existen
            if (document.getElementById('inp-width')) {
              document.getElementById('inp-width').value = settings.width;
              document.getElementById('inp-minHeight').value = settings.minHeight;
              document.getElementById('inp-spacing').value = settings.spacing !== undefined ? settings.spacing : 15;
              document.getElementById('inp-padding').value = settings.padding !== undefined ? settings.padding : 15;
              document.getElementById('inp-textGap').value = settings.textGap !== undefined ? settings.textGap : 4;
              document.getElementById('inp-borderRadius').value = settings.borderRadius;
              
              document.getElementById('inp-showHeader').checked = settings.showHeader !== undefined ? settings.showHeader : true;
              document.getElementById('inp-showArtist').checked = settings.showArtist !== undefined ? settings.showArtist : true;
              document.getElementById('inp-showUser').checked = settings.showUser !== undefined ? settings.showUser : true;
              document.getElementById('inp-showEmpty').checked = settings.showEmpty !== undefined ? settings.showEmpty : true;

              document.getElementById('inp-animEntry').value = settings.animEntry;
              document.getElementById('inp-animExit').value = settings.animExit;
              
              document.getElementById('inp-font').value = settings.font;
              document.getElementById('inp-fontSize').value = settings.fontSize;
              document.getElementById('inp-accent').value = settings.accent;
              document.getElementById('inp-bg').value = settings.bg;
              
              const primaryOpacityVal = settings.primaryOpacity !== undefined ? settings.primaryOpacity : 100;
              document.getElementById('inp-primaryOpacity').value = primaryOpacityVal;
              document.getElementById('primary-opacity-val').innerText = primaryOpacityVal + '%';

              const opacityVal = settings.secondaryOpacity !== undefined ? settings.secondaryOpacity : 60;
              document.getElementById('inp-secondaryOpacity').value = opacityVal;
              document.getElementById('opacity-val').innerText = opacityVal + '%';

              document.getElementById('inp-text').value = settings.text;
            }
          }
        }, (error) => {
           console.warn("No se pudo sincronizar configuraci√≥n remota:", error);
        });
    } else {
      console.warn("Firestore no inicializado. No se cargar√° configuraci√≥n remota.");
    }

    const container = document.getElementById('queue-container');
    
    // Estado local
    let allRequests = []; // Todas las solicitudes del d√≠a
    let playedSongIds = new Set(); // IDs de canciones ya reproducidas
    let skippedSongIds = new Set(); // IDs reproducidas pero skip (no cuentan puntos)
    let playedSongsLoaded = false; // Evitar "ghost cards" antes de cargar lista negra
    let visibleQueue = []; // Las 3 canciones actualmente mostradas
    let currentManualOrder = []; // Orden manual compartido
    const firstSeenOrder = new Map(); // docId -> incremental order (para estabilizar renders)
    let firstSeenCounter = 0;

    // Utilidad: Obtener clave de fecha local (YYYY-MM-DD)
    function getLocalDateKey(ts) {
      const d = ts ? new Date(ts) : new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${dd}`;
    }

    // Utilidad: Generar ID de canci√≥n (debe coincidir con lista.html)
    function generateSongId(req) {
      // 1. Preferir ID compuesto ya existente (generado por el bot/lista)
      if (req.id && String(req.id).includes('-') && String(req.id).split('-').length >= 3) {
        return req.id;
      }

      // 2. Fallback: Reconstruir ID si falta (l√≥gica legacy)
      // Necesitamos recrear el formato HH:MM desde el timestamp
      let d;
      if (req.ts && typeof req.ts.toDate === 'function') {
        d = req.ts.toDate();
      } else if (req.ts) {
        d = new Date(req.ts);
      } else {
        d = new Date();
      }
      
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const hora = `${hh}:${mm}`;
      
      // Usar hora del objeto si ya viene pre-formateada
      const finalHora = req.hora || hora;
      
      const usuario = req.usuario || req.user || req.username || '';
      const cancion = req.cancion || req.songName || req.song || req.name || '';
      const artista = req.artista || req.artistName || req.artist || '';
      return `${usuario}-${cancion}-${artista}-${finalHora}`.replace(/[^a-zA-Z0-9-]/g, '');
    }

    function getLocalSkippedMap() {
      try { return JSON.parse(localStorage.getItem('skippedSongs') || '{}'); } catch (_) { return {}; }
    }

    function setLocalSkippedMap(map) {
      try { localStorage.setItem('skippedSongs', JSON.stringify(map || {})); } catch (_) {}
    }

    // Orden manual: aplicar
    console.log("Queue Overlay v2.5-firebase-reload-fix loaded");

    function applyOrder(items, order) {
      try {
        if (!Array.isArray(order) || !order.length) return items;

        const inOrderSet = new Set(order);
        const byDocId = new Map();
        const bySongId = new Map();

        items.forEach((it) => {
          if (it && it.docId) byDocId.set(String(it.docId), it);
          const sid = generateSongId(it);
          if (sid) bySongId.set(String(sid), it);
          if (it && it.id) bySongId.set(String(it.id), it);
        });

        // Elementos presentes en 'order' respetando ese orden
        const ordered = [];
        const seen = new Set();
        order.forEach((sid) => {
          const key = String(sid || '');
          if (!key) return;
          const found = byDocId.get(key) || bySongId.get(key);
          if (!found) return;
          if (seen.has(found)) return;
          seen.add(found);
          ordered.push(found);
        });

        // Nuevos (no presentes en 'order') abajo (para mantener FIFO)
        const notInOrder = items.filter((it) => {
          const docId = it && it.docId ? String(it.docId) : '';
          const sid = String(generateSongId(it) || '');
          const rawId = it && it.id ? String(it.id) : '';
          return !(inOrderSet.has(docId) || inOrderSet.has(sid) || inOrderSet.has(rawId));
        });

        return [...ordered, ...notInOrder];
      } catch {
        return items;
      }
    }

    // --- Data & API Logic ---
    const songDataCache = {}; // Key: "Artist - Song", Value: { artworkUrl, durationMs, correctTitle, correctArtist }
    let isFetching = false;

    function normalizeText(input) {
      return String(input || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^\w\s-]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function tokenizeText(input) {
      const t = normalizeText(input);
      if (!t) return [];
      return t.split(' ').filter(Boolean);
    }

    async function fetchSongData(artist, song) {
      const query = `${artist} ${song}`.trim();
      const cacheKey = query.toLowerCase();
      
      if (songDataCache[cacheKey]) return songDataCache[cacheKey];

      try {
        // Aumentamos el l√≠mite para filtrar resultados no deseados
        const res = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=song&limit=10`);
        const data = await res.json();
        
        if (data.resultCount > 0) {
          const reqArtist = normalizeText(artist);
          const reqSong = normalizeText(song);
          if (!reqArtist || !reqSong) return null;
          const reqArtistTokens = tokenizeText(reqArtist);
          const reqSongTokens = tokenizeText(reqSong);
          const avoidKeywords = ['karaoke', 'tribute', 'cover', 'instrumental', 'remix', 'lullaby', 'rendition', 'slowed', 'reverb'];

          const candidates = (data.results || []).filter(t => {
            const lowerName = normalizeText(t.trackName || '');
            const lowerArtist = normalizeText(t.artistName || '');
            const lowerCollection = normalizeText(t.collectionName || '');
            const hasBadWord = avoidKeywords.some(kw =>
              lowerName.includes(kw) ||
              lowerArtist.includes(kw) ||
              lowerCollection.includes(kw)
            );
            return !hasBadWord;
          });

          let best = null;
          let bestScore = -1;
          const scoreTrack = (t) => {
            const trackName = normalizeText(t.trackName || '');
            const artistName = normalizeText(t.artistName || '');
            if (!trackName || !artistName) return -1;

            let score = 0;
            let songHits = 0;
            let artistHits = 0;

            if (trackName.includes(reqSong)) score += 3;
            if (artistName.includes(reqArtist)) score += 3;

            reqSongTokens.forEach(tok => {
              if (tok.length < 2) return;
              if (trackName.includes(tok)) { score += 1; songHits += 1; }
            });
            reqArtistTokens.forEach(tok => {
              if (tok.length < 2) return;
              if (artistName.includes(tok)) { score += 1; artistHits += 1; }
            });

            if (songHits === 0 || artistHits === 0) return -1;
            return score;
          };

          candidates.forEach((t) => {
            const s = scoreTrack(t);
            if (s > bestScore) { bestScore = s; best = t; }
          });

          const threshold = Math.max(5, Math.ceil((reqSongTokens.length + reqArtistTokens.length) * 0.75));
          const track = bestScore >= threshold ? best : null;
          if (!track) return null;

          const result = {
            artworkUrl: track.artworkUrl100.replace('100x100', '600x600'),
            durationMs: track.trackTimeMillis,
            correctTitle: track.trackName,
            correctArtist: track.artistName
          };
          songDataCache[cacheKey] = result;
          return result;
        }
      } catch (e) {
        console.warn("iTunes API Error:", e);
      }
      return null;
    }

    function formatDuration(ms) {
      if (!ms) return "";
      const minutes = Math.floor(ms / 60000);
      const seconds = ((ms % 60000) / 1000).toFixed(0);
      return `${minutes}:${seconds.padStart(2, '0')}`;
    }

    function formatWaitTime(mins) {
      if (mins <= 0.4) return "Siguiente";
      if (mins < 60) return `en ${Math.round(mins)} min`;
      const h = Math.floor(mins / 60);
      const m = Math.round(mins % 60);
      return `en ${h}h ${m}m`;
    }

    // --- Core Render Logic ---

    const queueUrlParams = new URLSearchParams(window.location.search);
    const forcedBadgeParam = String(queueUrlParams.get('badge') || '').trim();
    const forcedUserParam = String(queueUrlParams.get('user') || '').trim();
    function normalizeUserForOverride(v) {
      try { return String(v || '').trim().replace(/^@/, '').toLowerCase(); } catch (_) { return ''; }
    }
    const forcedUserKey = normalizeUserForOverride(forcedUserParam);
    function getForcedBadgeForUser(username) {
      if (!forcedBadgeParam) return '';
      if (!forcedUserKey) return forcedBadgeParam;
      const u = normalizeUserForOverride(username);
      return (u && u === forcedUserKey) ? forcedBadgeParam : '';
    }
    function badgeLabel(badge) {
      const b = String(badge || '').trim();
      if (!b) return '';
      if (b === 'vip') return 'VIP';
      if (b === 'z0-vip') return 'z0Vip';
      if (b === 'donador') return 'ü™ô';
      if (b === 'donador-oro') return 'ü•á';
      if (b === 'donador-plata') return 'ü•à';
      if (b === 'donador-bronce') return 'ü•â';
      if (b === 'z0-fan') return 'z0';
      if (b === 'z0-platino') return 'VIP';
      return b;
    }

    // Funci√≥n para mover una tarjeta al principio de la lista manual
    function moveCardToTop(songId) {
        if (!songId) return;
        
        // Obtener TODAS las canciones pendientes actuales (ya filtradas por played)
        const pending = allRequests.filter(req => !playedSongIds.has(generateSongId(req)));
        
        // Ordenarlas seg√∫n el orden actual (manual o timestamp)
        // Usamos la misma l√≥gica que renderQueue
        let ordered = applyOrder(pending, currentManualOrder);
        
        // Extraer la canci√≥n que queremos mover
        const targetIndex = ordered.findIndex(req => generateSongId(req) === songId);
        if (targetIndex === -1) return; // No encontrada
        
        const targetReq = ordered[targetIndex];
        ordered.splice(targetIndex, 1); // Quitarla de su posici√≥n actual
        ordered.unshift(targetReq); // Ponerla al principio
        
        // Generar el nuevo array de IDs para guardar
        const newOrderIds = ordered.map(req => generateSongId(req));
        
        // Guardar nuevo orden en Firestore
        if (db) {
            db.collection('manualOrders').doc(currentDay).set({
                order: newOrderIds,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true }).then(() => {
                console.log(`Canci√≥n ${songId} movida al inicio`);
            }).catch(err => console.error("Error moviendo canci√≥n:", err));
        }
    }

    function createQueueItem(req, index) {
      const cancion = req.cancion || req.songName || req.song || req.name || '';
      const artista = req.artista || req.artistName || req.artist || '';
      const usuario = req.displayName || req.usuario || req.user || req.username || '';
      const rawBadge = String((req && req.badge) || '').trim();
      const badge = rawBadge || getForcedBadgeForUser(usuario);
      const badgeHtml = badge ? `<span class="user-insignia ${badge}">${badgeLabel(badge)}</span>` : '';
      const div = document.createElement('div');
      const sId = generateSongId(req);
      
      // Wrapper con clases de posici√≥n
      div.className = `queue-item queue-pos-${index + 1}`; 
      div.dataset.songId = sId;
      if (req.docId) div.dataset.docId = req.docId;
      
      // Structure for optional Album Art and Wait Time
      div.innerHTML = `
        <div class="queue-item-inner" style="flex-direction: row; align-items: center; gap: 15px;">
           <img class="item-art" src="" style="display:none; width: 60px; height: 60px; object-fit: cover; border-radius: 4px; flex-shrink: 0;">
           
           <div style="flex: 1; min-width: 0; display: flex; flex-direction: column;">
               <div class="item-header">
                  <span>#${index + 1}</span>
                  <span>En cola</span>
               </div>
               <div class="item-song">${cancion}</div>
               <div class="item-artist">${artista}</div>
               <div class="item-user">
                  Pedido por <span class="user-badge"><span class="user-name">${usuario}</span>${badgeHtml}</span>
               </div>
               <div class="item-wait" style="font-size: 11px; color: var(--queue-accent-color); margin-top: 4px; font-weight: bold; display:none;"></div>
           </div>
        </div>
      `;
    return div;
    }
    }

    function renderQueue() {
      // Evitar renderizado si no hemos cargado la lista de reproducidas (evita flash de ghost cards)
      if (!playedSongsLoaded && db) {
        console.log("Esperando lista de reproducidas...");
        return;
      }

      console.log("renderQueue called. Pending requests:", allRequests.length);
      const now = Date.now();
      
      // 1. Filtrar solicitudes que NO est√°n en playedSongIds
      let pendingRequests = allRequests.filter(req => {
        const id = generateSongId(req);
        if (playedSongIds.has(id)) {
            // console.log("Filtered played:", id); // Debug
            return false;
        }
        return true;
      });

      // 1.5 Aplicar orden manual si existe
      pendingRequests = applyOrder(pendingRequests, currentManualOrder);

      // 2. Tomar las primeras 3 (o settings limit)
      // Hardcoded to 3 for now based on visibleQueue logic, but could be dynamic
      const itemsToShow = pendingRequests.slice(0, 3);
      
      // 3. Diffing Inteligente: Solo animar elementos NUEVOS
      const container = document.getElementById('queue-container');
      
      // Mapa de elementos actuales (Array para manejar duplicados de ID)
      const existingMap = new Map();
      container.querySelectorAll('.queue-item:not(.removing)').forEach(el => {
          const id = el.dataset.docId || el.dataset.songId;
          if (id) {
             if (!existingMap.has(id)) existingMap.set(id, []);
             existingMap.get(id).push(el);
          }
      });
      
      // Procesar items a mostrar
      const desiredEls = [];
      itemsToShow.forEach((req, index) => {
        const reqId = req.docId || req.id || generateSongId(req);
        let itemEl = null;

        // Intentar recuperar un elemento existente
        if (existingMap.has(reqId)) {
            const list = existingMap.get(reqId);
            if (list.length > 0) {
                itemEl = list.shift(); // Tomar el primero disponible
            }
        }

        if (itemEl) {
            // CASO 1: El elemento YA EXISTE
            // Ya lo sacamos de la lista, si la lista queda vac√≠a, el map se limpia solo al final
            
            // Actualizar clase de posici√≥n si cambi√≥
            const newPosClass = `queue-pos-${index + 1}`;
            // Limpiar clases de posici√≥n antiguas
            itemEl.className = itemEl.className.replace(/queue-pos-\d+/g, '').trim();
            itemEl.classList.add(newPosClass);

            try {
              const numEl = itemEl.querySelector('.item-header span');
              if (numEl) numEl.textContent = `#${index + 1}`;
            } catch (_) {}
            
            // Asegurar que sea visible (sin animaci√≥n de entrada)
            if (!itemEl.classList.contains('show')) itemEl.classList.add('show');
            desiredEls.push(itemEl);
        } else {
            // CASO 2: El elemento es NUEVO
            itemEl = createQueueItem(req, index);
            desiredEls.push(itemEl);
            
            // Animar entrada SOLO para este nuevo elemento
            void itemEl.offsetWidth; // Trigger reflow
            itemEl.classList.add('show');
        }
      });

      // Reordenar/insertar elementos para que el DOM refleje el nuevo orden
      const emptyEl = document.getElementById('empty-state');
      desiredEls.forEach((el) => {
        if (!el) return;
        if (emptyEl && emptyEl.parentNode === container) container.insertBefore(el, emptyEl);
        else container.appendChild(el);
      });

      // 4. Eliminar elementos que ya no est√°n (los que quedaron en existingMap)
      existingMap.forEach((list) => {
          list.forEach(el => {
            // el.classList.remove('show'); // Mantener .show para evitar parpadeo o desaparici√≥n inmediata
            el.classList.add('removing');
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                if (el && el.isConnected) el.classList.add('removing-active');
              });
            });
            
            // Eliminar del DOM despu√©s de la animaci√≥n y el colapso
            // Animaci√≥n: 0.8s | Delay colapso: 0.6s | Colapso: 0.8s 
            // Total visual: ~1.4s. Damos 1.5s de margen.
            setTimeout(() => {
                if (el.parentNode) el.parentNode.removeChild(el);
            }, 1500);
          });
      });

      // 5. Empty State Logic
      let empty = document.getElementById('empty-state');
      if (itemsToShow.length === 0) {
         if (!empty) {
             empty = document.createElement('div');
             empty.id = 'empty-state';
             empty.innerHTML = `<div style="font-size: 40px; margin-bottom: 10px;">üéµ</div><div>Esperando solicitudes...</div>`;
             container.appendChild(empty);
         }
         const s = window.appliedSettings || getSettingsFromInputs(); // Get current settings for visibility
         if (s.showEmpty) empty.classList.add('visible');
         else empty.classList.remove('visible');
      } else {
         if (empty) empty.classList.remove('visible');
      }

      // 6. Hydrate Data (Autocorrect, Art, Times)
      hydrateQueueItems(itemsToShow);
      
      // 7. Update Total Duration
      updateTotalDuration(pendingRequests);
    }

    async function hydrateQueueItems(items) {
      const settings = window.appliedSettings || getSettingsFromInputs();
      if (!settings.autocorrect && !settings.showAlbumArt && !settings.showWaitTime) return;

      const getCurrentPlaybackRemainingMinutes = () => {
        try {
          if (!settings || settings.syncAppleMusic !== true) return 0;
          const ms = Number(currentCiderPlayback?.remainingMs || 0);
          const updatedAt = Number(currentCiderPlayback?.updatedAt || 0);
          if (!Number.isFinite(ms) || ms <= 0) return 0;
          const age = Date.now() - updatedAt;
          if (!Number.isFinite(age) || age > 120000) return 0;
          if (ms < 5000) return 0;
          return ms / 60000;
        } catch (_) {
          return 0;
        }
      };

      const shouldAutocorrectText = (reqArtist, reqSong, correctedArtist, correctedSong) => {
        try {
          const ra = normalizeText(reqArtist);
          const rs = normalizeText(reqSong);
          const ca = normalizeText(correctedArtist);
          const cs = normalizeText(correctedSong);

          if (!ra || !rs || !ca || !cs) return false;
          if (ra.length < 2 || rs.length < 2 || ca.length < 2 || cs.length < 2) return false;

          const artistOk = ca.includes(ra) || ra.includes(ca);
          const songOk = cs.includes(rs) || rs.includes(cs);
          return artistOk && songOk;
        } catch (_) {
          return false;
        }
      };

      const container = document.getElementById('queue-container');
      const itemEls = Array.from(container.querySelectorAll('.queue-item:not(.removing)'));
      const elBySongId = new Map();
      itemEls.forEach((el) => {
        const sid = el.dataset.songId;
        if (sid && !elBySongId.has(sid)) elBySongId.set(sid, el);
      });
      
      let accumulatedTime = getCurrentPlaybackRemainingMinutes(); // minutes (incluye canci√≥n actual si hay Cider)

      for (const req of items) {
         if (!req) continue;
         const songId = generateSongId(req);
         const el = elBySongId.get(songId);
         if (!el) continue;

         const songEl = el.querySelector('.item-song');
         const artistEl = el.querySelector('.item-artist');
         const artEl = el.querySelector('.item-art');
         const waitEl = el.querySelector('.item-wait');

         // Check Cache or Fetch
         if (settings.autocorrect || settings.showAlbumArt || settings.showWaitTime) {
             const artist = String(req.artista || req.artistName || req.artist || '').trim();
             const song = String(req.cancion || req.songName || req.song || req.name || '').trim();

             if (songEl) songEl.innerText = song;
             if (artistEl) artistEl.innerText = artist;

             const data = await fetchSongData(artist, song);
             
             if (data) {
                 if (settings.autocorrect) {
                     if (shouldAutocorrectText(artist, song, data.correctArtist, data.correctTitle)) {
                       if (songEl) songEl.innerText = data.correctTitle;
                       if (artistEl) artistEl.innerText = data.correctArtist;
                     }
                 }
                 
                 if (settings.showAlbumArt && data.artworkUrl) {
                     artEl.src = data.artworkUrl;
                     artEl.style.display = 'block';
                 } else if (artEl) {
                     artEl.style.display = 'none';
                 }

                 if (settings.showWaitTime && data.durationMs) {
                     waitEl.style.display = 'block';
                     waitEl.innerText = formatWaitTime(accumulatedTime);
                     accumulatedTime += (data.durationMs / 60000);
                 }
             } else {
                 // Fallback for wait time if no data found (assume 3:30 min)
                 if (settings.showWaitTime) {
                     waitEl.style.display = 'block';
                     waitEl.innerText = formatWaitTime(accumulatedTime);
                     accumulatedTime += 3.5; 
                 }
                 if (artEl) artEl.style.display = 'none';
             }
         }
      }
    }

    async function updateTotalDuration(allPending) {
      const settings = window.appliedSettings || getSettingsFromInputs();
      const indicator = document.getElementById('total-duration-indicator');
      const valEl = document.getElementById('total-time-val');

      if (!settings.showTotalDuration || allPending.length === 0) {
        indicator.style.display = 'none';
        return;
      }

      indicator.style.display = 'block';
      
      let totalMs = 0;
      let unknownCount = 0;

      // Batch fetch or use cache
      // Note: fetching all might be heavy. We'll rely on cache + defaults.
      for (const req of allPending) {
         const artist = String(req.artista || req.artistName || req.artist || '').trim();
         const song = String(req.cancion || req.songName || req.song || req.name || '').trim();
         const cacheKey = `${artist} ${song}`.trim().toLowerCase();
         if (songDataCache[cacheKey]) {
             totalMs += songDataCache[cacheKey].durationMs;
         } else {
             unknownCount++;
         }
      }

      // Estimate unknowns as 3.5 mins
      totalMs += (unknownCount * 3.5 * 60000);

      const h = Math.floor(totalMs / 3600000);
      const m = Math.round((totalMs % 3600000) / 60000);
      
      valEl.innerText = h > 0 ? `${h}h ${m}m` : `${m}m`;
    }

    // --- Apple Music / Cider Integration ---
    // Variables moved to top of script to avoid ReferenceError

    // Global variable to store current playback state
    let currentCiderTrack = null;
    let currentCiderPlayback = { remainingMs: 0, updatedAt: 0 };

    function normalizeMaybeSecondsToMs(v) {
      const n = Number(v);
      if (!Number.isFinite(n) || n <= 0) return 0;
      if (n < 1000) return Math.round(n * 1000);
      if (n < 1000 * 60 * 20) return Math.round(n * 1000);
      return Math.round(n);
    }

    function updateCiderPlaybackTiming(data) {
      try {
        if (!data) return;

        const remainingCandidates = [
          data.timeRemaining,
          data.remainingTime,
          data.remainingTimeMs,
          data.remainingMs,
          data.timeRemainingMs
        ];

        let remainingMs = 0;
        for (let i = 0; i < remainingCandidates.length; i++) {
          const ms = normalizeMaybeSecondsToMs(remainingCandidates[i]);
          if (ms > 0) { remainingMs = ms; break; }
        }

        if (!remainingMs) {
          const durationMs = normalizeMaybeSecondsToMs(
            data.durationInMillis || data.durationMs || data.trackTimeMillis || data.duration || data.playbackDuration
          );
          const positionMs = normalizeMaybeSecondsToMs(
            data.playbackTime || data.currentPlaybackTime || data.position || data.elapsedTime || data.elapsedTimeMs
          );
          if (durationMs > 0 && positionMs >= 0 && positionMs <= durationMs + 15000) {
            remainingMs = Math.max(0, durationMs - positionMs);
          }
        }

        if (remainingMs > 0) {
          currentCiderPlayback = { remainingMs, updatedAt: Date.now() };
        }
      } catch (_) {}
    }

    // Function to check current playing track against the queue
    function checkCurrentTrackAgainstQueue() {
      if (!currentCiderTrack || !currentCiderTrack.artist || !currentCiderTrack.song) return;

      const artist = currentCiderTrack.artist;
      const song = currentCiderTrack.song;
      const requesterId = currentCiderTrack.requesterId ? String(currentCiderTrack.requesterId).trim() : '';
      const playingAppleMusicId = currentCiderTrack.appleMusicId ? String(currentCiderTrack.appleMusicId).trim() : '';
      
      // Clave √∫nica para evitar procesar la misma canci√≥n m√∫ltiples veces
      const key = `${playingAppleMusicId}|${artist}|${song}|${requesterId}`;
      if (lastAutoMarkedSong === key) return; 

      // Normalizaci√≥n segura para comparaci√≥n
      const normalize = (str) => {
          if (!str) return "";
          return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^a-z0-9]/g, "");
      };
      
      const targetArtist = normalize(artist);
      const targetSong = normalize(song);

      if (targetArtist.length < 2 || targetSong.length < 2) return;

      // Filtrar canciones NO reproducidas
      const candidates = allRequests.filter(req => {
          const id = generateSongId(req);
          return !playedSongIds.has(id);
      });

      // L√≥gica de Matching (Prioridad: ID > Match Exacto > Match Parcial)
      const findMatch = () => {
          // 1. Coincidencia por Apple Music ID (si existe)
          if (playingAppleMusicId) {
             const idMatch = candidates.find(req => String(req.appleMusicId || '').trim() === playingAppleMusicId);
             if (idMatch) {
               console.log(`‚úÖ MATCH POR ID: ${playingAppleMusicId} -> ${idMatch.artista} - ${idMatch.cancion}`);
               return idMatch;
             }
          }

          // 2. Coincidencia por Texto (Artista y Canci√≥n)
          for (const req of candidates) {
              const reqArtist = normalize(req.artista);
              const reqSong = normalize(req.cancion);

              // Match Exacto (o contenido completo)
              const artistMatch = reqArtist.includes(targetArtist) || targetArtist.includes(reqArtist);
              const songMatch = reqSong.includes(targetSong) || targetSong.includes(reqSong);

              // Match Cruzado (a veces artista y canci√≥n est√°n invertidos)
              const swappedMatch = (reqArtist.includes(targetSong) || targetSong.includes(reqArtist)) &&
                                   (reqSong.includes(targetArtist) || targetArtist.includes(reqSong));

              if ((artistMatch && songMatch) || swappedMatch) {
                  console.log(`‚úÖ MATCH POR TEXTO: "${targetArtist} - ${targetSong}" vs "${reqArtist} - ${reqSong}"`);
                  return req;
              }
          }
          return null;
      };

      const match = findMatch();

      if (match) {
        console.log(`‚ú® Auto-marking song as played: ${match.artista} - ${match.cancion}`);
        const generatedId = generateSongId(match);
        markSongAsPlayed(generatedId);
        lastAutoMarkedSong = key;
      } else {
        console.log(`üîç No match found for Cider track: ${artist} - ${song} (AM ID: ${playingAppleMusicId})`);
      }
    }

    function getCiderSocketUrl() {
      try {
        const params = new URLSearchParams(window.location.search || '');
        const fromQuery = String(params.get('ciderUrl') || '').trim();
        if (fromQuery) return fromQuery;
      } catch (_) {}
      try {
        const fromLocal = String(localStorage.getItem('ciderUrl') || '').trim();
        if (fromLocal) return fromLocal;
      } catch (_) {}
      return "http://localhost:10767/";
    }

    function connectCider() {
      if (ciderSocket) return; // Already connected
      if (!window.io) {
        console.warn("Socket.io not loaded");
        return;
      }

      const url = getCiderSocketUrl();
      console.log("Intentando conectar a Cider:", url);
      ciderSocket = io(url, {
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: 500,
        timeout: 8000
      });

      ciderSocket.on("connect", () => {
        console.log("‚úÖ Conectado a Cider/Apple Music Widget!");
        // Request current playback status immediately
        ciderSocket.emit("get-playback");
      });

      ciderSocket.on("connect_error", (err) => {
        console.warn("‚ùå Error conectando a Cider:", err && err.message ? err.message : err);
      });

      ciderSocket.on("disconnect", (reason) => {
        console.log("‚ùå Desconectado de Cider. Raz√≥n:", reason);
        // NO anular ciderSocket aqu√≠ para permitir reconexi√≥n autom√°tica de socket.io
        if (reason === "io server disconnect") {
          // Si el servidor nos desconecta expl√≠citamente, intentar reconectar manual
          ciderSocket.connect();
        }
      });

      ciderSocket.on("API:Playback", (event) => {
        // data structure: { data: { name, artistName, ... }, type: "..." }
        const { data, type } = event;
        
        // Log para depuraci√≥n
        console.log("üéµ Cider Event:", type, data?.name);
        try { updateCiderPlaybackTiming(data); } catch (_) {}

        const artist = data && (data.artistName || data.artist);
        const name = data && (data.name || data.songName || data.title);
        const requester = data && (data.requester || data.requestedBy || data.user || data.username || '');
        const requesterId = data && (data.requesterId || data.requesterUserId || data.userId || '');
        const appleMusicId = data
          ? ((data.playParams && data.playParams.id) ? data.playParams.id : (data.appleMusicId || data.id || ''))
          : '';

        if (artist && name) {
          // Actualizar estado de reproducci√≥n actual
          currentCiderTrack = { 
              artist: String(artist), 
              song: String(name), 
              requesterId: String(requesterId || ''), 
              appleMusicId: String(appleMusicId || '') 
          };

          // Lista de eventos que indican cambio de canci√≥n
          const changeEvents = [
              "playbackStatus.nowPlayingItemDidChange", 
              "playbackStatus.nowPlayingItemDidChangeV2", 
              "playbackStatus.playbackStateDidChange", // A veces llega primero
              "get-playback" // Respuesta a nuestra petici√≥n inicial
          ];

          if (changeEvents.includes(type)) {
            console.log("üéµ Cider Now Playing:", artist, "-", name, `[${type}]`);
            // Intentar marcar inmediatamente
            checkCurrentTrackAgainstQueue();
            
            // Reintentar en 2s por si la cola no estaba cargada
            setTimeout(checkCurrentTrackAgainstQueue, 2000);
          }
        }
      });
    }

    // Wrapper for compatibility (redirects to new logic)
    function autoMarkPlayed(artist, song) {
        currentCiderTrack = { artist, song, user: '', appleMusicId: '' };
        checkCurrentTrackAgainstQueue();
    }

    function markSongAsPlayed(id, options) {
      if (!id) return;
      const doSkip = !!(options && options.skip === true);
      try {
        playedSongIds.add(id);
        if (doSkip) skippedSongIds.add(id);
        else skippedSongIds.delete(id);
        playedSongsLoaded = true;
        renderQueue();
      } catch (_) {}
      try {
        const localSkipped = getLocalSkippedMap();
        const arr = Array.isArray(localSkipped[currentDay]) ? localSkipped[currentDay] : [];
        if (doSkip) {
          if (!arr.includes(id)) arr.push(id);
        } else {
          localSkipped[currentDay] = arr.filter(x => x !== id);
        }
        localSkipped[currentDay] = Array.isArray(localSkipped[currentDay]) ? localSkipped[currentDay] : arr;
        setLocalSkippedMap(localSkipped);
      } catch (_) {}
      if (!db) return;
      const payload = {
        songs: firebase.firestore.FieldValue.arrayUnion(id),
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
      };
      if (doSkip) payload.skipped = firebase.firestore.FieldValue.arrayUnion(id);
      else payload.skipped = firebase.firestore.FieldValue.arrayRemove(id);
      db.collection('playedSongs').doc(currentDay).set(payload, { merge: true })
      .then(() => console.log("Song marked as played:", id))
      .catch(err => console.error("Error marking song as played:", err));
    }

    const currentDay = getLocalDateKey();
    console.log("Queue Overlay v2.2 - Fix Empty Match. Listening for day:", currentDay);

    if (db) {
      db.collection('solicitudes')
        .where('day', '==', currentDay)
        .onSnapshot((snapshot) => {
          const temp = [];
          snapshot.forEach(doc => {
            const data = doc.data();
            if (!firstSeenOrder.has(doc.id)) firstSeenOrder.set(doc.id, ++firstSeenCounter);
            const item = { ...data, docId: doc.id, _seen: firstSeenOrder.get(doc.id) };
            if (!item.id) item.id = doc.id;
            temp.push(item);
          });
          
          // Sort in memory (Oldest First / FIFO)
          temp.sort((a, b) => {
             const tA = a.ts && a.ts.toMillis ? a.ts.toMillis() : (new Date(a.ts).getTime() || 0);
             const tB = b.ts && b.ts.toMillis ? b.ts.toMillis() : (new Date(b.ts).getTime() || 0);

             const aHasTime = Number.isFinite(tA) && tA > 0;
             const bHasTime = Number.isFinite(tB) && tB > 0;
             if (aHasTime && bHasTime && tA !== tB) return tA - tB;
             if (aHasTime && !bHasTime) return -1;
             if (!aHasTime && bHasTime) return 1;

             const sA = Number(a?._seen || 0);
             const sB = Number(b?._seen || 0);
             if (sA !== sB) return sA - sB;

             const idA = String(a?.docId || a?.id || generateSongId(a) || '');
             const idB = String(b?.docId || b?.id || generateSongId(b) || '');
             if (idA && idB && idA !== idB) return idA.localeCompare(idB);
             return 0;
          });

          console.log(`Loaded ${temp.length} requests for day ${currentDay}`);
          allRequests = temp;
          renderQueue();
          checkCurrentTrackAgainstQueue();
        }, (error) => {
          console.error("Error en solicitudes:", error);
          try {
            const empty = document.getElementById('empty-state');
            if (empty) empty.innerHTML = '<div style="font-size: 40px; margin-bottom: 10px;">‚ö†Ô∏è</div><div>Error leyendo solicitudes</div><div style="opacity:0.8; font-size:12px; margin-top:6px;">Revisa Firebase/Internet</div>';
          } catch (_) {}
        });

      db.collection('playedSongs').doc(currentDay)
        .onSnapshot((doc) => {
          if (doc.exists) {
            const data = doc.data();
            const songs = data.songs || data.list || [];
            playedSongIds = new Set(songs);
            
            const skipped = Array.isArray(data.skipped) ? data.skipped : [];
            skippedSongIds = new Set(skipped);
            
            // Fusi√≥n cr√≠tica: Las canciones saltadas TAMBI√âN deben considerarse "reproducidas" 
            // para que desaparezcan de la cola visual
            skipped.forEach(id => playedSongIds.add(id));

            try {
              const localSkipped = getLocalSkippedMap();
              localSkipped[currentDay] = skipped;
              setLocalSkippedMap(localSkipped);
            } catch (_) {}
          } else {
            playedSongIds = new Set();
            skippedSongIds = new Set();
            try {
              const localSkipped = getLocalSkippedMap();
              localSkipped[currentDay] = [];
              setLocalSkippedMap(localSkipped);
            } catch (_) {}
          }
          playedSongsLoaded = true; // Marcar como cargado para habilitar renderizado
          renderQueue();
        }, (error) => {
          console.error("Error en playedSongs:", error);
          // En caso de error, permitir renderizar igual para no bloquear la UI
          playedSongsLoaded = true; 
          renderQueue();
        });

      setTimeout(() => {
        if (!playedSongsLoaded) {
          playedSongsLoaded = true;
          renderQueue();
        }
      }, 2500);

      db.collection('manualOrders').doc(currentDay)
        .onSnapshot((doc) => {
          if (doc.exists) {
            currentManualOrder = Array.isArray(doc.data().order) ? doc.data().order : [];
          } else {
            currentManualOrder = [];
          }
          renderQueue();
        }, (error) => {
          console.error("Error en manualOrders:", error);
        });

      // Listener de Notificaciones
      db.collection('notifications')
        .orderBy('timestamp', 'desc')
        .limit(5)
        .onSnapshot((snapshot) => {
          snapshot.docChanges().forEach((change) => {
            if (change.type === 'added') {
              const data = change.doc.data();
              // Solo mostrar si es reciente (√∫ltimos 10 segundos)
              const now = Date.now();
              const ts = data.timestamp ? (data.timestamp.toMillis ? data.timestamp.toMillis() : new Date(data.timestamp).getTime()) : now;
              
              if (now - ts < 10000) {
                 showNotification(data);
              }
            }
          });
        });

    } else {
      console.warn("Firestore no disponible. Cola no podr√° sincronizarse.");
      renderQueue();
    }

    function showNotification(data) {
        const container = document.getElementById('notification-container');
        if (!container) return;
        
        const div = document.createElement('div');
        div.className = `notification-toast ${data.type || ''}`;
        
        let icon = 'üîî';
        let title = 'Notificaci√≥n';
        
        if (data.type === 'points') {
            icon = 'üí∞';
            title = 'Puntos Zero FM';
        }
        
        div.innerHTML = `
            <div class="notification-icon">${icon}</div>
            <div class="notification-content">
                <div class="notification-title">${title}</div>
                <div class="notification-msg">${data.message}</div>
            </div>
        `;
        
        container.appendChild(div);
        
        // Auto remove
        setTimeout(() => {
            div.style.animation = 'fadeOutRight 0.5s forwards';
            setTimeout(() => {
                if (div.parentNode) div.parentNode.removeChild(div);
            }, 500);
        }, 5000);
    }

    // --- L√≥gica de Simulaci√≥n ---
    const debugControls = document.getElementById('debug-controls');
    debugControls.addEventListener('mouseenter', () => debugControls.style.opacity = '1');
    debugControls.addEventListener('mouseleave', () => debugControls.style.opacity = '0.2');
    function simulateQueueRequest() {
      const qs = new URLSearchParams(window.location.search);
      const artists = ["Bad Bunny", "Karol G", "Feid", "Rauw Alejandro", "Shakira", "Daddy Yankee", "Rosal√≠a"];
      const songs = ["Tit√≠ Me Pregunt√≥", "Provenza", "Classy 101", "Todo de Ti", "Bzrp Music Sessions, Vol. 53", "Gasolina", "Despech√°"];
      
      const randomIndex = Math.floor(Math.random() * artists.length);
      const randomArtist = artists[randomIndex];
      const randomSong = songs[randomIndex];
      const randomUser = String(qs.get('user') || "Prueba").trim() || "Prueba";
      const forcedBadge = String(qs.get('badge') || '').trim();
      
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const hora = `${hh}:${mm}`;
      const uniqueId = Date.now().toString(36); // Timestamp base36 para unicidad
      const tsValue = (typeof firebase !== 'undefined' && firebase?.firestore?.Timestamp?.fromDate)
        ? firebase.firestore.Timestamp.fromDate(now)
        : now;
      const req = {
        id: `${randomUser}-${randomSong}-${randomArtist}-${hora}-${uniqueId}`.replace(/[^a-zA-Z0-9-]/g, ''),
        usuario: randomUser,
        displayName: randomUser,
        cancion: randomSong,
        artista: randomArtist,
        ts: tsValue,
        day: getLocalDateKey(now),
        hora,
        status: 'pending',
        isSimulation: true,
        badge: forcedBadge
      };

      // Enviar a Firebase para que se refleje en OBS
      console.log("Enviando simulaci√≥n a Firebase:", req);
      if (!db) {
        allRequests.push(req);
        renderQueue();
        return;
      }
      db.collection('solicitudes').add(req)
        .then(() => console.log("Simulaci√≥n enviada con √©xito"))
        .catch(err => {
          console.error("Error enviando simulaci√≥n:", err);
          try { allRequests.push(req); renderQueue(); } catch (_) {}
        });
    }

    function markFirstPending(skip) {
      const pendingRequests = allRequests.filter(req => {
        const id = generateSongId(req);
        return !playedSongIds.has(id);
      });

      if (pendingRequests.length > 0) {
        const toToggle = pendingRequests[0];
        const id = generateSongId(toToggle);

        console.log("Marcando primera pendiente:", id, { skip: !!skip });
        markSongAsPlayed(id, { skip: !!skip });
      } else {
        alert("No hay canciones pendientes para marcar.");
      }
    }

    function markFirstPendingFromPanel(skip) {
      markFirstPending(!!skip);
      try { toggleMarkPanel(); } catch (_) {}
    }

    function simulateToggleFirst(e) {
      markFirstPending(!!(e && e.shiftKey === true));
    }

    // Modo de prueba autom√°tico: ?test=true
    /* 
    // DESACTIVADO para evitar spam al recargar si la URL se queda guardada
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('test') === 'true') {
      setTimeout(() => {
        console.log("Iniciando modo de prueba autom√°tico...");
        // Simular 3 pedidos para llenar la cola
        simulateQueueRequest();
        setTimeout(simulateQueueRequest, 500);
        setTimeout(simulateQueueRequest, 1000);
      }, 1000);
    } 
    */
    // Start Cider connection immediately
    setTimeout(connectCider, 2000);
    
    // --- Drag & Drop Logic for Settings Button ---
    const settingsBtn = document.getElementById('settings-btn');
    const settingsBtnPosKey = `widget_btn_pos:${location.pathname}:settings-btn`;
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let hasMoved = false;

    try {
      const saved = localStorage.getItem(settingsBtnPosKey);
      if (saved) {
        const pos = JSON.parse(saved);
        if (pos && typeof pos.left === 'number' && typeof pos.top === 'number') {
          settingsBtn.style.left = `${pos.left}px`;
          settingsBtn.style.top = `${pos.top}px`;
        }
      }
    } catch (_) {}

    settingsBtn.addEventListener('mousedown', (e) => {
        isDragging = true;
        hasMoved = false;
        const rect = settingsBtn.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        settingsBtn.style.cursor = 'grabbing';
        
        // Disable transitions during drag for responsiveness
        settingsBtn.style.transition = 'none';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        hasMoved = true;
        e.preventDefault();
        
        const x = e.clientX - dragOffsetX;
        const y = e.clientY - dragOffsetY;
        
        settingsBtn.style.left = `${x}px`;
        settingsBtn.style.top = `${y}px`;
    });

    document.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        
        isDragging = false;
        settingsBtn.style.cursor = 'grab';
        
        // Restore transitions
        settingsBtn.style.transition = 'background 0.3s ease, transform 0.3s ease, opacity 0.3s ease';

        if (hasMoved) {
          const rect = settingsBtn.getBoundingClientRect();
          const left = Math.max(0, Math.min(rect.left, window.innerWidth - rect.width));
          const top = Math.max(0, Math.min(rect.top, window.innerHeight - rect.height));
          settingsBtn.style.left = `${left}px`;
          settingsBtn.style.top = `${top}px`;
          try {
            localStorage.setItem(settingsBtnPosKey, JSON.stringify({ left, top }));
          } catch (_) {}
        }
    });
    
    // Handle click manually to avoid triggering when dragging
    settingsBtn.addEventListener('click', (e) => {
        if (!hasMoved) {
            toggleSettings();
        }
    });

    // --- Roulette Logic ---
    let rouletteParticipants = [];
    let rouletteMode = 'list'; // 'list' | 'new'
    let rouletteCanvas = document.getElementById('roulette-canvas');
    let rouletteCtx = rouletteCanvas ? rouletteCanvas.getContext('2d') : null;
    let isSpinning = false;
    let currentRotation = 0;

    function setRouletteMode(mode) {
        rouletteMode = mode;
        const btnList = document.getElementById('mode-btn-list');
        const btnNew = document.getElementById('mode-btn-new');
        
        if(mode === 'list') {
            if(btnList) {
                btnList.style.background = 'var(--queue-accent-color)';
                btnList.style.color = '#000';
            }
            if(btnNew) {
                btnNew.style.background = 'transparent';
                btnNew.style.color = '#aaa';
            }
            loadRouletteParticipants();
        } else {
            if(btnList) {
                btnList.style.background = 'transparent';
                btnList.style.color = '#aaa';
            }
            if(btnNew) {
                btnNew.style.background = 'var(--queue-accent-color)';
                btnNew.style.color = '#000';
            }
            // Clear for new
            rouletteParticipants = [];
            renderParticipantsList();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
       const closeRBtn = document.getElementById('close-roulette');
       const spinBtn = document.getElementById('spin-btn');
       const addPartBtn = document.getElementById('add-participant-btn');
       const addPartInput = document.getElementById('add-participant-input');

       if(closeRBtn) closeRBtn.addEventListener('click', closeRoulette);
       if(spinBtn) spinBtn.addEventListener('click', spinWheel);
       
       if(addPartBtn) {
           addPartBtn.addEventListener('click', () => {
               const name = addPartInput.value.trim();
               if(name) {
                   addParticipant(name);
                   addPartInput.value = '';
               }
           });
       }
       if(addPartInput) {
           addPartInput.addEventListener('keypress', (e) => {
               if(e.key === 'Enter') {
                   const name = addPartInput.value.trim();
                   if(name) {
                       addParticipant(name);
                       addPartInput.value = '';
                   }
               }
           });
       }
       
       // Init default mode UI
       setRouletteMode('list');
    });

    function openRoulette() {
        const view = document.getElementById('roulette-view');
        const queue = document.getElementById('queue-container');
        if(view && queue) {
            queue.style.display = 'none';
            view.style.display = 'flex';
            
            // Reload if in list mode to get latest updates
            if(rouletteMode === 'list') {
                loadRouletteParticipants();
            }
            
            applyParticipantsVisibility();
            
            // Ensure wheel state is applied (position/size)
            setTimeout(initRouletteState, 100);
        }
    }

    function closeRoulette() {
        const view = document.getElementById('roulette-view');
        const queue = document.getElementById('queue-container');
        if(view && queue) {
            view.style.display = 'none';
            queue.style.display = 'flex';
        }
    }

    function loadRouletteParticipants() {
        if(rouletteMode !== 'list') return; // Should not overwrite if in new mode, unless forced

        // Extract unique users from pending requests
        const pending = allRequests.filter(req => {
            const id = generateSongId(req);
            return !playedSongIds.has(id);
        });
        
        const users = new Set();
        pending.forEach(req => {
            const u = req.displayName || req.usuario || req.user || req.username || '';
            if(u) users.add(u);
        });
        
        rouletteParticipants = Array.from(users);
        renderParticipantsList();
    }

    function renderParticipantsList() {
        const list = document.getElementById('participants-list');
        const count = document.getElementById('participant-count');
        if(!list) return;
        
        list.innerHTML = '';
        if(count) count.innerText = rouletteParticipants.length;

        rouletteParticipants.forEach((p, idx) => {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.justifyContent = 'space-between';
            row.style.alignItems = 'center';
            row.style.background = '#333';
            row.style.padding = '8px 10px';
            row.style.borderRadius = '6px';
            
            const name = document.createElement('span');
            name.style.color = 'white';
            name.innerText = p;
            
            const delBtn = document.createElement('button');
            delBtn.innerText = '√ó';
            delBtn.style.background = 'transparent';
            delBtn.style.border = 'none';
            delBtn.style.color = '#ff4444';
            delBtn.style.fontSize = '18px';
            delBtn.style.cursor = 'pointer';
            delBtn.onclick = () => removeParticipant(idx);

            row.appendChild(name);
            row.appendChild(delBtn);
            list.appendChild(row);
        });
        
        drawWheel();
    }

    function addParticipant(name) {
        if(!rouletteParticipants.includes(name)) {
            rouletteParticipants.push(name);
            renderParticipantsList();
        }
    }

    function removeParticipant(index) {
        rouletteParticipants.splice(index, 1);
        renderParticipantsList();
    }

    // Roulette Settings Logic
    const ROULETTE_THEMES = [
        { name: 'Rainbow', colors: ['#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'] },
        { name: 'Pastel', colors: ['#80DEEA', '#7986CB', '#FF8A80', '#FFD54F', '#4DB6AC'] }, // Based on image 2nd item
        { name: 'Pink/Blue', colors: ['#F48FB1', '#90CAF9', '#FFFFFF', '#90CAF9', '#F48FB1'] }, // Based on image 3rd item
        { name: 'Dark Purple', colors: ['#4A148C', '#7B1FA2', '#AB47BC', '#E1BEE7'] },
        { name: 'Ocean', colors: ['#0288D1', '#03A9F4', '#4FC3F7', '#E1F5FE'] },
        { name: 'Gold', colors: ['#C5A059', '#D4AF37', '#E6C975', '#F3E5AB'] },
        { name: 'Sunset', colors: ['#FFCC80', '#FFAB91', '#EF9A9A', '#CE93D8', '#B39DDB'] },
        { name: 'Forest', colors: ['#C8E6C9', '#A5D6A7', '#81C784', '#66BB6A'] },
        { name: 'Pink/White', colors: ['#F48FB1', '#F8BBD0', '#FCE4EC', '#FFFFFF'] },
        { name: 'Green', colors: ['#43A047', '#66BB6A', '#A5D6A7', '#C8E6C9'] },
        { name: 'Retro', colors: ['#264653', '#2A9D8F', '#E9C46A', '#F4A261', '#E76F51'] }
    ];

    let rouletteConfig = {
        fontSize: 14,
        textColor: '#ffffff',
        colors: ROULETTE_THEMES[0].colors,
        showParticipants: true
    };
    
    // Load config
    try {
        const savedConfig = localStorage.getItem(`widget_config:${location.pathname}:roulette`);
        if(savedConfig) {
            const parsed = JSON.parse(savedConfig);
            if(parsed) rouletteConfig = { ...rouletteConfig, ...parsed };
        }
    } catch(_) {}

    // Apply Participants Visibility (Updated for Tab Logic)
    function applyParticipantsVisibility() {
        const panel = document.getElementById('roulette-participants-panel');
        const content = document.getElementById('roulette-participants-content');
        const toggleBtn = document.getElementById('participants-toggle-tab');
        if(!panel || !content || !toggleBtn) return;

        if(rouletteConfig.showParticipants) {
            // OPEN
            panel.style.width = '250px';
            panel.style.minWidth = '250px';
            panel.style.paddingRight = '20px';
            panel.style.opacity = '1';
            content.style.opacity = '1';
            toggleBtn.innerText = '‚Äπ';
            toggleBtn.style.right = '-20px'; // ensure it stays put relative to panel
        } else {
            // CLOSED
            panel.style.width = '0px';
            panel.style.minWidth = '0px';
            panel.style.paddingRight = '0px';
            // We keep opacity 1 on panel to show the toggle button?
            // Wait, toggle button is child of panel. If panel width is 0, button needs to be visible.
            // Since panel has overflow visible (default if not set, but I set overflow hidden on content), 
            // the button (absolute) should be visible if panel is relative.
            // But panel transition might affect it.
            content.style.opacity = '0';
            toggleBtn.innerText = '‚Ä∫';
        }
    }
    
    function toggleParticipantsPanel() {
        rouletteConfig.showParticipants = !rouletteConfig.showParticipants;
        applyParticipantsVisibility();
        
        // Save state
        try {
            localStorage.setItem(`widget_config:${location.pathname}:roulette`, JSON.stringify(rouletteConfig));
        } catch(_) {}
    }

    // Call on load/init
    // We'll call this in openRoulette too

    function toggleRouletteSettings() {
        const panel = document.getElementById('roulette-settings-panel');
        if(!panel) return;
        
        if(panel.style.display === 'none') {
            // Open and populate
            document.getElementById('r-font-size').value = rouletteConfig.fontSize;
            document.getElementById('r-text-color').value = rouletteConfig.textColor;
            document.getElementById('r-colors').value = rouletteConfig.colors.join(', ');
            
            // Removed legacy checkbox population

            renderThemeSelector();
            
            panel.style.display = 'flex';
        } else {
            panel.style.display = 'none';
        }
    }

    function updateRoulettePreview() {
        const fs = parseInt(document.getElementById('r-font-size').value) || 14;
        const tc = document.getElementById('r-text-color').value || '#ffffff';
        // Removed legacy checkbox reading
        
        // Update temp state
        rouletteConfig.fontSize = fs;
        rouletteConfig.textColor = tc;
        
        drawWheel();
    }

    function renderThemeSelector() {
        const container = document.getElementById('r-theme-selector');
        if(!container) return;
        container.innerHTML = '';
        
        ROULETTE_THEMES.forEach((theme, idx) => {
            const btn = document.createElement('div');
            btn.style.minWidth = '50px';
            btn.style.height = '50px';
            btn.style.borderRadius = '12px';
            btn.style.overflow = 'hidden';
            btn.style.cursor = 'pointer';
            btn.style.display = 'flex';
            btn.style.border = '2px solid transparent';
            btn.style.transition = 'transform 0.1s, border-color 0.2s';
            btn.title = theme.name;
            
            // Check if active
            // Simple array comparison
            const isSelected = JSON.stringify(theme.colors) === JSON.stringify(rouletteConfig.colors);
            if(isSelected) {
                btn.style.borderColor = 'white';
                btn.style.transform = 'scale(1.1)';
                btn.style.boxShadow = '0 0 10px rgba(255,255,255,0.5)';
            }

            // Draw stripes
            theme.colors.forEach(color => {
                const stripe = document.createElement('div');
                stripe.style.flex = '1';
                stripe.style.height = '100%';
                stripe.style.background = color;
                btn.appendChild(stripe);
            });

            btn.onclick = () => {
                rouletteConfig.colors = theme.colors;
                document.getElementById('r-colors').value = theme.colors.join(', ');
                renderThemeSelector(); // Re-render to update selection
                // Auto-preview? Maybe not full save, but let's just update selection visual
            };

            container.appendChild(btn);
        });
    }

    function saveRouletteSettings() {
        // Just save logic, values are already in config due to preview
        // But let's re-read to be safe or just persist
        const fs = parseInt(document.getElementById('r-font-size').value) || 14;
        const tc = document.getElementById('r-text-color').value || '#ffffff';
        
        // We trust rouletteConfig.colors is updated via selection or we can parse from textarea if we kept it editable
        // But since I hid textarea, we rely on state.
        // However, let's also support if textarea was somehow populated (legacy/fallback)
        const colorsStr = document.getElementById('r-colors').value || '';
        if(colorsStr) {
             let parsedColors = colorsStr.split(',').map(c => c.trim()).filter(c => c.startsWith('#'));
             if(parsedColors.length > 0) rouletteConfig.colors = parsedColors;
        }

        rouletteConfig.fontSize = fs;
        rouletteConfig.textColor = tc;
        // showParticipants is managed by the toggle tab directly

        try {
            localStorage.setItem(`widget_config:${location.pathname}:roulette`, JSON.stringify(rouletteConfig));
        } catch(_) {}

        document.getElementById('roulette-settings-panel').style.display = 'none';
        drawWheel();
    }

    function drawWheel() {
        if(!rouletteCtx || !rouletteCanvas) {
             rouletteCanvas = document.getElementById('roulette-canvas');
             if(rouletteCanvas) rouletteCtx = rouletteCanvas.getContext('2d');
             else return;
        }

        const ctx = rouletteCtx;
        const width = rouletteCanvas.width;
        const height = rouletteCanvas.height;
        const cx = width / 2;
        const cy = height / 2;
        const radius = Math.min(width, height) / 2 - 10;
        
        ctx.clearRect(0, 0, width, height);
        
        if(rouletteParticipants.length === 0) {
             ctx.fillStyle = '#ccc';
             ctx.font = '24px Arial';
             ctx.textAlign = 'center';
             ctx.fillText('Sin participantes', cx, cy);
             return;
        }

        const arc = (2 * Math.PI) / rouletteParticipants.length;
        const colors = rouletteConfig.colors;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(currentRotation);

        rouletteParticipants.forEach((p, i) => {
            const angle = i * arc;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, radius, angle, angle + arc);
            ctx.fillStyle = colors[i % colors.length];
            ctx.fill();
            ctx.stroke();

            ctx.save();
            ctx.rotate(angle + arc / 2);
            ctx.fillStyle = rouletteConfig.textColor;
            ctx.font = `bold ${rouletteConfig.fontSize}px Arial`;
            ctx.textAlign = 'right';
            ctx.fillText(p, radius - 20, 5);
            ctx.restore();
        });

        ctx.restore();
        
        // Center circle
        ctx.beginPath();
        ctx.arc(cx, cy, 30, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#333';
        ctx.stroke();
    }

    function spinWheel() {
        if(isSpinning || rouletteParticipants.length === 0) return;
        
        isSpinning = true;
        const winnerLabel = document.getElementById('winner-label');
        if(winnerLabel) {
            winnerLabel.style.display = 'none';
            winnerLabel.style.transition = 'none';
        }
        
        const minSpins = 5;
        const maxSpins = 10;
        const duration = 5000; // ms
        const spinAngle = (minSpins + Math.random() * (maxSpins - minSpins)) * 2 * Math.PI;
        
        const startRotation = currentRotation;
        const targetRotation = startRotation + spinAngle;
        const startTime = performance.now();

        function animate(time) {
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Ease out cubic
            const ease = 1 - Math.pow(1 - progress, 3);
            
            currentRotation = startRotation + (targetRotation - startRotation) * ease;
            drawWheel();
            
            if(progress < 1) {
                requestAnimationFrame(animate);
            } else {
                isSpinning = false;
                determineWinner();
            }
        }
        
        requestAnimationFrame(animate);
    }

    function determineWinner() {
        const count = rouletteParticipants.length;
        if(count === 0) return;
        
        const normalized = currentRotation % (2 * Math.PI);
        let angleOnWheel = (0 - normalized) % (2 * Math.PI);
        if(angleOnWheel < 0) angleOnWheel += 2 * Math.PI;
        
        const arc = (2 * Math.PI) / count;
        const index = Math.floor(angleOnWheel / arc);
        
        const winner = rouletteParticipants[index];
        const winnerLabel = document.getElementById('winner-label');
        if(winnerLabel) {
            winnerLabel.innerText = winner;
            winnerLabel.style.display = 'block';
            // Pop effect
            winnerLabel.style.transform = 'translate(-50%, -50%) scale(1.5)';
            setTimeout(() => {
                winnerLabel.style.transform = 'translate(-50%, -50%) scale(1)';
                winnerLabel.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            }, 100);
        }
    }

    // --- Drag & Drop for Roulette Button ---
    const rouletteBtn = document.getElementById('roulette-btn');
    const rouletteBtnPosKey = `widget_btn_pos:${location.pathname}:roulette-btn`;
    let isDraggingR = false;
    let dragOffsetXR = 0;
    let dragOffsetYR = 0;
    let hasMovedR = false;

    try {
      const savedR = localStorage.getItem(rouletteBtnPosKey);
      if (savedR) {
        const pos = JSON.parse(savedR);
        if (pos && typeof pos.left === 'number' && typeof pos.top === 'number') {
          rouletteBtn.style.left = `${pos.left}px`;
          rouletteBtn.style.top = `${pos.top}px`;
        }
      }
    } catch (_) {}

    rouletteBtn.addEventListener('mousedown', (e) => {
        isDraggingR = true;
        hasMovedR = false;
        const rect = rouletteBtn.getBoundingClientRect();
        dragOffsetXR = e.clientX - rect.left;
        dragOffsetYR = e.clientY - rect.top;
        rouletteBtn.style.cursor = 'grabbing';
        rouletteBtn.style.transition = 'none';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDraggingR) return;
        hasMovedR = true;
        e.preventDefault();
        const x = e.clientX - dragOffsetXR;
        const y = e.clientY - dragOffsetYR;
        rouletteBtn.style.left = `${x}px`;
        rouletteBtn.style.top = `${y}px`;
    });

    document.addEventListener('mouseup', (e) => {
        if (!isDraggingR) return;
        isDraggingR = false;
        rouletteBtn.style.cursor = 'grab';
        rouletteBtn.style.transition = 'background 0.3s ease, transform 0.3s ease, opacity 0.3s ease';

        if (hasMovedR) {
          const rect = rouletteBtn.getBoundingClientRect();
          const left = Math.max(0, Math.min(rect.left, window.innerWidth - rect.width));
          const top = Math.max(0, Math.min(rect.top, window.innerHeight - rect.height));
          rouletteBtn.style.left = `${left}px`;
          rouletteBtn.style.top = `${top}px`;
          try {
            localStorage.setItem(rouletteBtnPosKey, JSON.stringify({ left, top }));
          } catch (_) {}
        }
    });
    
    // Roulette Wheel Drag, Drop & Resize Logic
    const rouletteWrapper = document.getElementById('roulette-wheel-wrapper');
    const roulettePlayArea = document.getElementById('roulette-play-area');
    const rouletteStateKey = `widget_state:${location.pathname}:roulette-wheel`;

    // State
    let rState = { x: 0, y: 0, w: 500, h: 500, initialized: false };

    // Initialize position/size
    function initRouletteState() {
        if (!rouletteWrapper || !roulettePlayArea) return;

        // Force layout calc if hidden (hacky but needed if display:none)
        // Actually, we call this after setting display:flex
        
        try {
            const saved = localStorage.getItem(rouletteStateKey);
            if (saved) {
                const parsed = JSON.parse(saved);
                if (parsed) {
                    rState = { ...rState, ...parsed, initialized: true };
                }
            }
        } catch (_) {}

        if (!rState.initialized) {
            // Center default
            const parentW = roulettePlayArea.clientWidth || 800;
            const parentH = roulettePlayArea.clientHeight || 600;
            rState.x = (parentW - rState.w) / 2;
            rState.y = (parentH - rState.h) / 2;
            rState.initialized = true;
        }

        applyRouletteState();
    }

    function applyRouletteState() {
        if (!rouletteWrapper) return;
        rouletteWrapper.style.width = `${rState.w}px`;
        rouletteWrapper.style.height = `${rState.h}px`;
        rouletteWrapper.style.left = `${rState.x}px`;
        rouletteWrapper.style.top = `${rState.y}px`;
        
        // Redraw wheel to fit new size if needed (canvas scales via CSS but redrawing keeps resolution sharp if we updated canvas width/height attr)
        // For now, canvas has fixed width/height attr (600), CSS scales it. That's fine.
        drawWheel();
    }

    rouletteBtn.addEventListener('click', (e) => {
        if (!hasMovedR) {
            const view = document.getElementById('roulette-view');
            if (view && view.style.display !== 'none') {
                closeRoulette();
            } else {
                openRoulette();
                // Initialize state after making visible so we can measure parent
                setTimeout(initRouletteState, 10);
            }
        }
    });

    // Drag & Resize Logic
    let isDraggingW = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let initialLeft = 0;
    let initialTop = 0;

    let isResizingW = false;
    let resizeHandle = '';
    let initialWidth = 0;
    let initialHeight = 0;

    if (rouletteWrapper) {
        rouletteWrapper.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('resize-handle')) {
                // Resize Start
                isResizingW = true;
                resizeHandle = e.target.getAttribute('data-handle');
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                initialWidth = rState.w;
                initialHeight = rState.h;
                initialLeft = rState.x;
                initialTop = rState.y;
                e.stopPropagation(); 
                e.preventDefault();
            } else {
                // Drag Start
                // Only drag if clicking wrapper or canvas (not internal buttons if any)
                isDraggingW = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                initialLeft = rState.x;
                initialTop = rState.y;
                rouletteWrapper.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingW) {
                e.preventDefault();
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;
                rState.x = initialLeft + dx;
                rState.y = initialTop + dy;
                applyRouletteState();
            } else if (isResizingW) {
                e.preventDefault();
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;
                
                const minSize = 100;

                if (resizeHandle === 'se') {
                    rState.w = Math.max(minSize, initialWidth + dx);
                    rState.h = Math.max(minSize, initialHeight + dy);
                } else if (resizeHandle === 'sw') {
                    const newW = Math.max(minSize, initialWidth - dx);
                    rState.w = newW;
                    rState.h = Math.max(minSize, initialHeight + dy);
                    rState.x = initialLeft + (initialWidth - newW);
                } else if (resizeHandle === 'ne') {
                    const newH = Math.max(minSize, initialHeight - dy);
                    rState.w = Math.max(minSize, initialWidth + dx);
                    rState.h = newH;
                    rState.y = initialTop + (initialHeight - newH);
                } else if (resizeHandle === 'nw') {
                    const newW = Math.max(minSize, initialWidth - dx);
                    const newH = Math.max(minSize, initialHeight - dy);
                    rState.w = newW;
                    rState.h = newH;
                    rState.x = initialLeft + (initialWidth - newW);
                    rState.y = initialTop + (initialHeight - newH);
                }
                applyRouletteState();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isDraggingW || isResizingW) {
                isDraggingW = false;
                isResizingW = false;
                rouletteWrapper.style.cursor = 'grab';
                try {
                    localStorage.setItem(rouletteStateKey, JSON.stringify(rState));
                } catch (_) {}
            }
        });
    }
  </script>
</body>
</html>
