<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lista d'Canciones - Zero Radio</title>
  <link rel="stylesheet" href="styles.css" />
  
  <!-- Script de sincronización de temas -->
  <script>
    // Sincronización global de temas entre pestañas/ventanas
    window.addEventListener('focus', function() {
      // Cuando la ventana recibe foco, verificar si hay cambios de tema
      if (typeof window.applyTheme === 'function') {
        window.applyTheme();
      }
      if (typeof window.updateActiveStates === 'function') {
        window.updateActiveStates();
      }
    });
  </script>
  
  <!-- Firebase SDK (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
</head>
<body>
  <main class="container">
    <section class="card" aria-labelledby="titulo">
      <div class="title-bar" role="group" aria-label="Barra de título y filtro">
        <h1 id="titulo">Lista de canciones</h1>
        <div class="title-tools">
          <form class="search-box" role="search" autocomplete="off" data-lpignore="true" data-1p-ignore="true">
            <span class="search-icon" aria-hidden="true">🔍</span>
            <input id="search-input" name="song-search-query" type="search" placeholder="Buscar canción..." aria-label="Buscar canción" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" data-form-type="search" data-lpignore="true" data-1p-ignore="true" inputmode="search" enterkeyhint="search" readonly onfocus="this.removeAttribute('readonly');" />
            <div id="search-results" class="search-results" hidden></div>
          </form>
          <button id="theme-btn" class="theme-btn" type="button" aria-label="Cambiar tema" title="Cambiar tema">
            🎨
          </button>
          <button id="menu-btn" class="menu-btn" type="button" aria-label="Abrir menú" aria-haspopup="true" aria-expanded="false" aria-controls="menu-dropdown">
            <span class="bar bar1"></span>
            <span class="bar bar2"></span>
            <span class="bar bar3"></span>
          </button>
          <div id="menu-dropdown" class="menu-dropdown" hidden>
            <ul class="menu-list" role="menu" aria-label="Acciones">
              <li><a href="index.html" class="menu-item" role="menuitem">🎵 Pedir nueva canción</a></li>
              <li><button type="button" id="menu-search-open" class="menu-item" role="menuitem">🔍 Buscar canción</button></li>
              <li><button type="button" id="menu-stats-open" class="menu-item" role="menuitem">📊 Estadísticas</button></li>
              <li><button type="button" id="menu-gamification-open" class="menu-item" role="menuitem">🏆 Mi Perfil</button></li>
              <li><button type="button" id="menu-rewards-open" class="menu-item" role="menuitem">🎁 Canje de Puntos</button></li>
              <li><button type="button" id="menu-changelog-open" class="menu-item" role="menuitem">🚀 Mejoras (v1.7)</button></li>
              <li><button type="button" id="menu-admin-open" class="menu-item" role="menuitem">⚙️ Modo Admin</button></li>
            </ul>
          </div>
        </div>
      </div>

      <div class="day-filter-row" role="group" aria-label="Filtro de día">
        <div class="day-filter">
          <label for="day-select">Ver día:</label>
          <select id="day-select"></select>
        </div>
      </div>

      <div class="vip-filter">
        <label><input type="checkbox" id="vip-only" /> Ver solo VIP</label>
      </div>

      <div id="admin-panel" class="admin-panel" hidden>
        
        <!-- Selector de Sección Admin -->
        <div class="admin-row admin-section-selector">
          <label for="admin-section-select">Selecciona sección a administrar:</label>
          <select id="admin-section-select" class="admin-select">
            <option value="badges">👑 Gestión de Insignias</option>
            <option value="rewards">🎁 Administración de Recompensas</option>
            <option value="maintenance">🔧 Mantenimiento</option>
          </select>
        </div>

        <!-- Sección de Gestión de Insignias -->
        <div id="badges-section" class="admin-section">
          <!-- Selector de Insignia -->
          <div class="admin-row badge-selector">
            <label for="badge-type-select">Selecciona tipo de insignia:</label>
            <select id="badge-type-select" class="admin-select">
              <option value="vip">👑 VIP</option>
              <option value="z0-vip">⭐ Z0-VIP</option>
              <option value="donador">💎 Donador</option>
            </select>
          </div>

          <!-- Gestión de VIP -->
          <div id="vip-management" class="badge-management">
            <div class="admin-row">
              <label for="all-users-select">Selecciona usuario registrado para VIP:</label>
              <select id="all-users-select" class="user-select" aria-label="Usuarios registrados">
                <option value="">Selecciona un usuario</option>
              </select>
              <div class="admin-btns">
                <button type="button" id="vip-add" class="btn">Agregar</button>
                <button type="button" id="user-delete" class="btn">Borrar usuario</button>
              </div>
              <div class="admin-list-section">
                <strong>Usuarios VIP:</strong>
                <ul id="vip-list" class="vip-list"></ul>
              </div>
            </div>
          </div>

          <!-- Gestión de Z0-VIP -->
          <div id="z0-vip-management" class="badge-management" hidden>
            <div class="admin-row">
              <label for="all-users-select-z0">Selecciona usuario registrado para Z0-VIP:</label>
              <select id="all-users-select-z0" class="user-select" aria-label="Usuarios registrados para Z0-VIP">
                <option value="">Selecciona un usuario</option>
              </select>
              <div class="admin-btns">
                <button type="button" id="z0-vip-add" class="btn">Agregar Z0-VIP</button>
              </div>
              <div class="admin-list-section">
                <strong>Usuarios Z0-VIP:</strong>
                <ul id="z0-vip-list" class="vip-list"></ul>
              </div>
            </div>
          </div>

          <!-- Gestión de Donador -->
          <div id="donador-management" class="badge-management" hidden>
            <div class="admin-row">
              <label for="all-users-select-donador">Selecciona usuario registrado para Donador (1 día):</label>
              <select id="all-users-select-donador" class="user-select" aria-label="Usuarios registrados para Donador">
                <option value="">Selecciona un usuario</option>
              </select>
              <div class="admin-btns">
                <button type="button" id="donador-add" class="btn">Agregar Donador</button>
              </div>
              <div class="admin-list-section">
                <strong>Usuarios Donadores (temporales):</strong>
                <ul id="donador-list" class="vip-list"></ul>
              </div>
            </div>
          </div>
        </div>
        <!-- Sección de Administración de Recompensas -->
        <div id="rewards-section" class="admin-section" hidden>
          <div class="admin-row admin-rewards-section">
            <h3>🎁 Administración de Recompensas</h3>
            
            <!-- Estadísticas de Recompensas -->
            <div class="admin-rewards-stats">
              <div class="reward-stat-item">
                <span class="stat-number" id="admin-total-pending">0</span>
                <span class="stat-label">Pendientes</span>
              </div>
              <div class="reward-stat-item">
                <span class="stat-number" id="admin-total-approved">0</span>
                <span class="stat-label">Aprobadas Hoy</span>
              </div>
              <div class="reward-stat-item">
                <span class="stat-number" id="admin-total-rejected">0</span>
                <span class="stat-label">Rechazadas Hoy</span>
              </div>
            </div>
            
            <!-- Filtros de Recompensas -->
            <div class="admin-rewards-filters">
              <select id="admin-rewards-status-filter" class="admin-select">
                <option value="all">Todas las solicitudes</option>
                <option value="pending" selected>Solo pendientes</option>
                <option value="approved">Solo aprobadas</option>
                <option value="rejected">Solo rechazadas</option>
              </select>
              <select id="admin-rewards-user-filter" class="admin-select">
                <option value="all">Todos los usuarios</option>
              </select>
              <button type="button" id="admin-refresh-rewards" class="btn">🔄 Actualizar</button>
            </div>
            
            <!-- Lista de Solicitudes de Recompensas -->
            <div class="admin-rewards-list-container">
              <div id="admin-rewards-list" class="admin-rewards-list">
                <p class="loading-message">Cargando solicitudes...</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Sección de Mantenimiento -->
        <div id="maintenance-section" class="admin-section" hidden>
          <div class="admin-row">
            <h3>🔧 Mantenimiento del Sistema</h3>
            <div class="maintenance-actions">
              <button type="button" id="recalculate-users" class="btn btn-success">🔄 Recalcular todos los usuarios</button>
              <button type="button" id="diagnose-data-btn" class="btn btn-info">🔍 Diagnosticar datos de usuario</button>
                <button type="button" id="test-user-switch-btn" class="btn btn-warning">🧪 Probar cambio de usuario</button>
                <button type="button" id="debug-current-user-btn" class="btn btn-secondary">🔍 Debug usuario actual</button>
              <button type="button" id="wipe-all" class="btn btn-danger">🗑️ Borrar todas las solicitudes</button>
              <button type="button" id="clear-cache" class="btn btn-warning">🧹 Limpiar caché</button>
              <button type="button" id="backup-data" class="btn btn-info">💾 Respaldar datos</button>
            </div>
          </div>
        </div>

        <!-- Acciones Generales del Admin -->
        <div class="admin-row admin-actions">
          <button type="button" id="admin-exit" class="btn">Salir del modo Admin</button>
        </div>
      </div>

      <!-- Modales -->
      <div id="admin-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="admin-modal-title">
          <h2 id="admin-modal-title">Modo Admin</h2>
          <p>Inicia sesión para administrar VIP y mantenimiento</p>
          <div class="field">
            <label for="admin-email-input">Correo</label>
            <input id="admin-email-input" type="email" placeholder="correo@ejemplo.com" autocomplete="off" spellcheck="false" data-form-type="other" />
          </div>
          <div class="field">
            <label for="admin-pass-input">Contraseña</label>
            <input id="admin-pass-input" type="password" placeholder="Contraseña" autocomplete="new-password" spellcheck="false" data-form-type="other" />
            <p id="admin-auth-error" class="error" hidden>Credenciales incorrectas o no eres admin.</p>
          </div>
          <div class="actions modal-actions">
            <button type="button" id="admin-pass-cancel" class="btn">Cancelar</button>
            <button type="button" id="admin-pass-confirm" class="btn">Entrar</button>
          </div>
        </div>
      </div>

      <div id="user-delete-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="user-delete-modal-title">
          <h2 id="user-delete-modal-title">Borrar usuario</h2>
          <p>¿Borrar al usuario "<span id="user-delete-name"></span>" de la lista de registrados?</p>
          <div class="actions modal-actions">
            <button type="button" id="user-delete-cancel" class="btn">Cancelar</button>
            <button type="button" id="user-delete-confirm" class="btn">Borrar</button>
          </div>
        </div>
      </div>

      <div id="vip-remove-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="vip-remove-modal-title">
          <h2 id="vip-remove-modal-title">Quitar VIP</h2>
          <p>¿Quitar VIP a "<span id="vip-remove-user"></span>"?</p>
          <div class="actions modal-actions">
            <button type="button" id="vip-remove-cancel" class="btn">Cancelar</button>
            <button type="button" id="vip-remove-confirm" class="btn">Quitar</button>
          </div>
        </div>
      </div>

      <div id="wipe-all-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="wipe-all-modal-title">
          <h2 id="wipe-all-modal-title">Borrar todas las solicitudes</h2>
          <p>¿Borrar todas las solicitudes del día "<span id="wipe-all-day"></span>"?</p>
          <div class="actions modal-actions">
            <button type="button" id="wipe-all-cancel" class="btn">Cancelar</button>
            <button type="button" id="wipe-all-confirm" class="btn">Borrar</button>
          </div>
        </div>
      </div>

      <!-- Modal de cambios por versión (changelog) -->
      <div id="changelog-modal" class="modal-overlay" hidden>
        <div class="modal changelog-modal" role="dialog" aria-modal="true" aria-labelledby="changelog-modal-title">
          <h2 id="changelog-modal-title">Mejoras por versión</h2>
          
          <div class="changelog-content">
            <h3>v1.7 (actual)</h3>
          <ul>
            <li>🎯 Botón dedicado para marcar canciones: Cada canción ahora tiene un botón específico (✓) para marcar/desmarcar.</li>
            <li>📝 Texto seleccionable: Ahora puedes seleccionar y copiar el texto de las canciones sin interferir con la funcionalidad de marcado.</li>
            <li>🖱️ Separación de funciones: El botón maneja el marcado y el texto permite selección independiente.</li>
            <li>📱 Optimización responsive: El botón se adapta perfectamente a diferentes tamaños de pantalla.</li>
            <li>🎨 Estados visuales mejorados: El botón cambia de apariencia cuando la canción está marcada (verde).</li>
            <li>🌙 Compatibilidad con temas: Funciona perfectamente en tema claro y oscuro.</li>
            <li>⚡ Experiencia de usuario mejorada: Interacción más intuitiva y sin conflictos entre acciones.</li>
            <li>🏆 Corrección de puntos VIP: Los usuarios VIP y Z0-VIP ahora reciben correctamente sus puntos de logro.</li>
            <li>🎧 Nueva recompensa "Conviértete en fan": Los usuarios pueden obtener el estado de Fan Z0 permanente por 2000 puntos.</li>
            <li>🔄 Sistema de recálculo mejorado: Corrige automáticamente inconsistencias en puntos e insignias de usuarios.</li>
            <li>🛠️ Herramienta de mantenimiento: Botón de recálculo masivo en el panel de administración para corregir datos.</li>
            <li>🔧 Mejorado cálculo de puntos de logros existentes y nuevos.</li>
            <li>🔧 Implementada validación y corrección automática de datos.</li>
            <li>🔧 Preservación correcta de estructura de rachas y estadísticas.</li>
          </ul>

            <h3>v1.6</h3>
          <ul>
            <li>🎵 Canciones clickeables: Marcado de las canciones como reproducidas con un simple clic.</li>
            <li>🔒 Sistema de clics restringido: Solo el dispositivo ADMIN puede modificar canciones, otros solo ven cambios.</li>
            <li>✅ Indicador visual: Las canciones reproducidas se muestran con colores contrastantes según el tema.</li>
            <li>💾 Persistencia local: El estado de las canciones se guarda automáticamente por día.</li>
            <li>🎨 Adaptación temática: Los colores de las canciones reproducidas se adaptan al tema seleccionado.</li>
            <li>🛡️ Seguridad de doble capa: Validación tanto en interfaz como en base de datos Firebase.</li>
          </ul>

          <h3>v1.5</h3>
          <ul>
            <li>🎁 Sistema de canje de puntos: intercambia tus puntos por recompensas exclusivas.</li>
            <li>💰 Costos de recompensas rebalanceados: ahora desde 600 puntos mínimo para mayor valor.</li>
            <li>🎯 Sistema de puntos mejorado: 25 puntos por canción, bonos VIP de 40 puntos.</li>
            <li>🏆 Recompensas exclusivas: Cambia tus puntos por recompensas</li>
            <li>⚡ Bonificaciones especiales: primer canción del día (+50), fines de semana (+10).</li>
            <li>📱 Experiencia móvil perfeccionada: botones touch-friendly de 44px mínimo.</li>
            <li>✨ Modales de confirmación mejorados: visibilidad garantizada en todos los dispositivos.</li>
            <li>🔧 Interfaz responsive optimizada: diseño adaptativo para móviles y tablets.</li>
            <li>🎮 Sistema de gamificación balanceado: progresión más satisfactoria y justa.</li>
            <li>⚡ Solicitudes de recompensas: sistema de aprobación con notificaciones.</li>
          </ul>

          <h3>v1.4</h3>
          <ul>
            <li>🎮 Modal de gamificación con logros, rachas y estadísticas personales.</li>
            <li>📊 Sistema de estadísticas avanzadas con gráficos y métricas detalladas.</li>
            <li>🔍 Búsqueda global mejorada: navega a cualquier fecha con un click.</li>
            <li>📅 Resultados de búsqueda con fechas formateadas ("Hoy", "Ayer", etc.).</li>
            <li>🎨 Sistema de temas completo: modo claro/oscuro con 5 colores de acento.</li>
            <li>🔄 Sincronización de temas en tiempo real entre todas las páginas abiertas.</li>
            <li>💾 Persistencia de preferencias de tema con migración automática de datos.</li>
            <li>🎯 Modal de temas rediseñado con botones de cerrar y restablecer funcionales.</li>
            <li>📱 Centrado perfecto del contenido en pantallas pequeñas y móviles.</li>
            <li>⚡ Búsqueda con debounce y indicadores de carga para mejor UX.</li>
            <li>🎨 Scrollbars personalizados en secciones de gamificación.</li>
            <li>📱 Calendario de actividad reciente centrado y optimizado.</li>
          </ul>

          <h3>v1.3</h3>
          <ul>
            <li>Buscador con lupita y opción en menú; resultados en tiempo real.</li>
            <li>Modal para "Borrar todas las solicitudes" (sin pop-up nativo).</li>
            <li>Borrar usuario en Admin con modal y permisos ajustados.</li>
            <li>Tipografía global Avenir y mejoras de responsive en móviles.</li>
            <li>Panel Admin: botones "Agregar/Borrar" apilados y selector ajustado.</li>
          </ul>

          <h3>v1.2</h3>
          <ul>
            <li>Quitar VIP con modal (botón “×”).</li>
            <li>Selector de usuarios registrados y gestión de VIP desde Admin.</li>
            <li>Correcciones de eventos en Admin y limpieza de código.</li>
          </ul>

          <h3>v1.1</h3>
          <ul>
            <li>Modo Admin básico, filtro VIP y selección de día.</li>
            <li>Suscripción en tiempo real a solicitudes y VIP.</li>
          </ul>
          </div>

          <div class="actions modal-actions">
            <button type="button" id="changelog-close" class="btn">Cerrar</button>
          </div>
        </div>
      </div>

      <!-- Modal de Estadísticas -->
      <div id="stats-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="stats-modal-title">
          <h2 id="stats-modal-title">📊 Estadísticas</h2>
          
          <div class="stats-tabs">
            <button type="button" class="stats-tab active" data-tab="general">General</button>
            <button type="button" class="stats-tab" data-tab="songs">Canciones</button>
            <button type="button" class="stats-tab" data-tab="artists">Artistas</button>
            <button type="button" class="stats-tab" data-tab="users">Usuarios</button>
          </div>

          <div class="stats-content">
            <div id="stats-general" class="stats-panel active">
              <div class="stats-grid">
                <div class="stat-card">
                  <div class="stat-number" id="total-songs">0</div>
                  <div class="stat-label">Total de canciones</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number" id="total-users">0</div>
                  <div class="stat-label">Usuarios únicos</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number" id="total-artists">0</div>
                  <div class="stat-label">Artistas únicos</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number" id="today-songs">0</div>
                  <div class="stat-label">Canciones hoy</div>
                </div>
              </div>
            </div>

            <div id="stats-songs" class="stats-panel">
              <h3>🎵 Top Canciones</h3>
              <div id="top-songs-list" class="stats-list"></div>
            </div>

            <div id="stats-artists" class="stats-panel">
              <h3>🎤 Top Artistas</h3>
              <div id="top-artists-list" class="stats-list"></div>
            </div>

            <div id="stats-users" class="stats-panel">
              <h3>👥 Usuarios Más Activos</h3>
              <div id="top-users-list" class="stats-list"></div>
            </div>
          </div>

          <div class="actions modal-actions">
            <button type="button" id="stats-close" class="btn">Cerrar</button>
          </div>
        </div>
      </div>

      <!-- Modal de Gamificación -->
      <div id="gamification-modal" class="modal-overlay" hidden>
        <div class="modal gamification-modal" role="dialog" aria-modal="true" aria-labelledby="gamification-modal-title">
          <button type="button" id="gamification-close-x" class="modal-close-btn" aria-label="Cerrar">×</button>
          <h2 id="gamification-modal-title">🏆 Mi Perfil Musical</h2>
          
          <!-- Información del Usuario -->
          <div class="user-profile">
            <div class="user-avatar">🎵</div>
            <div class="user-info">
              <h3 id="user-name">Usuario</h3>
              <div class="user-level">
                <span id="user-level-name">Novato</span>
                <span id="user-level-number">Nivel 1</span>
              </div>
            </div>
            <div class="user-points">
              <div class="points-display">
                <span id="user-points">0</span>
                <span class="points-label">puntos</span>
              </div>
            </div>
          </div>

          <!-- Selector de Usuario -->
          <div class="user-selector">
            <label for="gamification-user-select">👤 Ver perfil de usuario:</label>
            <div class="user-selector-controls">
              <select id="gamification-user-select" class="user-select">
                <option value="">Selecciona un usuario</option>
              </select>
              <button type="button" id="back-to-my-profile" class="btn btn-primary" style="display: none;">
                👥 Cambiar Usuario
              </button>
            </div>
          </div>

          <!-- Barra de Progreso -->
          <div class="level-progress">
            <div class="progress-bar">
              <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-text">
              <span id="current-xp">0</span> / <span id="next-level-xp">100</span> XP para el siguiente nivel
            </div>
          </div>

          <!-- Tabs de Gamificación -->
          <div class="gamification-tabs">
            <button type="button" class="gamification-tab active" data-tab="achievements">🏅 Logros</button>
            <button type="button" class="gamification-tab" data-tab="streaks">🔥 Rachas</button>
            <button type="button" class="gamification-tab" data-tab="stats">📈 Estadísticas</button>
          </div>

          <div class="gamification-content">
            <!-- Panel de Logros -->
            <div id="gamification-achievements" class="gamification-panel active">
              <div id="achievements-list" class="achievements-grid">
                <!-- Los logros se cargarán dinámicamente -->
              </div>
            </div>

            <!-- Panel de Rachas -->
            <div id="gamification-streaks" class="gamification-panel">
              <div class="streaks-container">
                <div class="streak-card">
                  <div class="streak-icon">🔥</div>
                  <div class="streak-info">
                    <h4>Racha Actual</h4>
                    <div class="streak-count" id="current-streak">0 días</div>
                    <div class="streak-desc">Días consecutivos pidiendo canciones</div>
                  </div>
                </div>
                
                <div class="streak-card">
                  <div class="streak-icon">⭐</div>
                  <div class="streak-info">
                    <h4>Mejor Racha</h4>
                    <div class="streak-count" id="best-streak">0 días</div>
                    <div class="streak-desc">Tu récord personal</div>
                  </div>
                </div>

                <div class="streak-calendar">
                  <h4>📅 Actividad Reciente</h4>
                  <div id="streak-calendar-grid" class="calendar-grid">
                    <!-- El calendario se generará dinámicamente -->
                  </div>
                  <div class="activity-legend">
                    <div class="legend-title">Nivel de actividad:</div>
                    <div class="legend-items">
                      <div class="legend-item">
                        <div class="legend-color activity-low"></div>
                        <span>1 canción</span>
                      </div>
                      <div class="legend-item">
                        <div class="legend-color activity-medium"></div>
                        <span>2 canciones</span>
                      </div>
                      <div class="legend-item">
                        <div class="legend-color activity-high"></div>
                        <span>3-4 canciones</span>
                      </div>
                      <div class="legend-item">
                        <div class="legend-color activity-very-high"></div>
                        <span>5-6 canciones</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Panel de Estadísticas Personales -->
            <div id="gamification-stats" class="gamification-panel">
              <div class="personal-stats-container">
                <div class="personal-stats-grid">
                  <div class="stat-card">
                    <div class="stat-icon">🎵</div>
                    <div class="stat-number" id="personal-total-songs">0</div>
                    <div class="stat-label">Canciones pedidas</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">🎤</div>
                    <div class="stat-number" id="personal-unique-artists">0</div>
                    <div class="stat-label">Artistas únicos</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">📅</div>
                    <div class="stat-number" id="personal-active-days">0</div>
                    <div class="stat-label">Días activos</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">🏆</div>
                    <div class="stat-number" id="personal-rank">-</div>
                    <div class="stat-label">Posición global</div>
                  </div>
                </div>

                <div class="favorite-genres">
                  <h4>🎼 Tus Géneros Favoritos</h4>
                  <div id="favorite-genres-list" class="genres-list">
                    <!-- Se generará dinámicamente -->
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="actions modal-actions">
          </div>
        </div>
      </div>

      <!-- Modal de Canje de Puntos -->
      <div id="rewards-modal" class="modal-overlay" hidden>
        <div class="modal rewards-modal" role="dialog" aria-modal="true" aria-labelledby="rewards-modal-title">
          <button type="button" id="rewards-close-x" class="modal-close-btn" aria-label="Cerrar">×</button>
          <h2 id="rewards-modal-title">🎁 Canje de Puntos</h2>
          
          <!-- Selector de Usuario -->
          <div class="user-selector">
            <label for="rewards-user-select">👤 Selecciona tu usuario:</label>
            <select id="rewards-user-select" class="user-select">
              <option value="">Selecciona un usuario</option>
            </select>
          </div>

          <!-- Información del Usuario Seleccionado -->
          <div class="user-info-section">
            <div class="user-display">
              <span class="user-icon">👤</span>
              <span id="rewards-user-info">Selecciona un usuario</span>
            </div>
            <div class="user-points-display">
              <span class="points-icon">💰</span>
              <span id="rewards-user-points">0</span>
              <span class="points-label">puntos disponibles</span>
            </div>
          </div>

          <!-- Recompensas Disponibles -->
          <div class="rewards-section">
            <h3>🎁 Recompensas Disponibles</h3>
            <div id="rewards-list" class="rewards-grid">
              <!-- Las recompensas se generan dinámicamente aquí -->
            </div>
          </div>

          <!-- Solicitudes Pendientes -->
          <div class="pending-rewards-section">
            <h3>📋 Solicitudes Pendientes de Aprobación</h3>
            <div id="pending-requests" class="pending-rewards-list">
              <p class="no-pending">No tienes solicitudes pendientes</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Modal de Confirmación -->
      <div id="confirmation-modal" class="modal-overlay" hidden>
        <div class="modal confirmation-modal" role="dialog" aria-modal="true" aria-labelledby="confirmation-modal-title">
          <button type="button" id="confirmation-close-x" class="modal-close-btn" aria-label="Cerrar">×</button>
          <div class="confirmation-content">
            <div class="confirmation-icon" id="confirmation-icon">ℹ️</div>
            <h3 id="confirmation-title">Confirmación</h3>
            <p id="confirmation-message">¿Estás seguro?</p>
            <div class="confirmation-buttons">
              <button type="button" id="confirmation-cancel" class="btn-secondary">Cancelar</button>
              <button type="button" id="confirmation-confirm" class="btn-primary">Confirmar</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Modal de Temas -->
      <div id="theme-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="theme-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar modal">&times;</button>
          <h2 id="theme-modal-title">🎨 Personalizar Tema</h2>
          
          <div class="theme-options">
            <div class="theme-section">
              <h3>Modo de Color</h3>
              <div class="theme-grid">
                <button type="button" class="theme-option active" data-theme="light">
                  <div class="theme-preview light-preview"></div>
                  <span>Claro</span>
                </button>
                <button type="button" class="theme-option" data-theme="dark">
                  <div class="theme-preview dark-preview"></div>
                  <span>Oscuro</span>
                </button>
              </div>
            </div>

            <div class="theme-section">
              <h3>Colores de Acento</h3>
              <div class="theme-grid">
                <button type="button" class="theme-color active" data-color="default">
                  <div class="color-preview" style="background: #000;"></div>
                  <span>Negro</span>
                </button>
                <button type="button" class="theme-color" data-color="blue">
                  <div class="color-preview" style="background: #2563eb;"></div>
                  <span>Azul</span>
                </button>
                <button type="button" class="theme-color" data-color="green">
                  <div class="color-preview" style="background: #16a34a;"></div>
                  <span>Verde</span>
                </button>
                <button type="button" class="theme-color" data-color="purple">
                  <div class="color-preview" style="background: #9333ea;"></div>
                  <span>Morado</span>
                </button>
                <button type="button" class="theme-color" data-color="red">
                  <div class="color-preview" style="background: #dc2626;"></div>
                  <span>Rojo</span>
                </button>
                <button type="button" class="theme-color" data-color="pink">
                  <div class="color-preview" style="background: #ec4899;"></div>
                  <span>Rosa</span>
                </button>
              </div>
            </div>
          </div>

          <div class="actions modal-actions">
            <button type="button" id="theme-reset" class="btn">Restablecer</button>
            <button type="button" id="theme-close" class="btn">Cerrar</button>
          </div>
        </div>
      </div>

      <section class="list" aria-live="polite">
        <div class="list-header" role="group" aria-label="Encabezados de lista">
          <span class="col col-time">Hora</span>
          <span class="col col-usuario">Usuario</span>
          <span class="col col-cancion">Canción</span>
          <span class="col col-artista">Artista</span>
          <span class="col col-action">✓</span>
        </div>
        <ul id="solicitudes-list" class="items"></ul>
        <p id="empty" class="empty" hidden>Aún no hay solicitudes.</p>
      </section>
    </section>
  </main>

  <script>
    (function () {
      const firebaseConfig = {
        apiKey: "AIzaSyA6c3EaIvuPEfM6sTV0YHqCBHuz35ZmNIU",
        authDomain: "zero-strom-web.firebaseapp.com",
        projectId: "zero-strom-web",
        storageBucket: "zero-strom-web.firebasestorage.app",
        messagingSenderId: "758369466349",
        appId: "1:758369466349:web:f2ced362a5a049c70b59e4"
      };
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      const db = firebase.firestore();
      window.db = db;

      firebase.auth().onAuthStateChanged((user) => {
        if (!user) {
          firebase.auth().signInAnonymously().catch((err) => {
            console.error('Error al iniciar sesión anónima:', err);
          });
        }
      });

      const solicitudesList = document.getElementById('solicitudes-list');
      const emptyEl = document.getElementById('empty');
      const vipOnly = document.getElementById('vip-only');
      const daySelect = document.getElementById('day-select');

      const allUsersSelect = document.getElementById('all-users-select');
      const vipAddBtn = document.getElementById('vip-add');
      const vipListEl = document.getElementById('vip-list');
      const wipeAllBtn = document.getElementById('wipe-all');

      // Elementos para donadores
      const allUsersSelectDonador = document.getElementById('all-users-select-donador');
      const donadorAddBtn = document.getElementById('donador-add');
      const donadorListEl = document.getElementById('donador-list');

      const vipRemoveModal = document.getElementById('vip-remove-modal');
      const vipRemoveUserSpan = document.getElementById('vip-remove-user');
      const vipRemoveCancelBtn = document.getElementById('vip-remove-cancel');
      const vipRemoveConfirmBtn = document.getElementById('vip-remove-confirm');
      let pendingVipRemoveUser = null;
      let pendingVipRemoveType = 'vip'; // 'vip', 'z0' o 'donador'

      // Variables globales para los sets de usuarios
      window.vipSet = new Set();
      window.z0VipSet = new Set();
      window.donadorSet = new Set();
      
      // Referencias locales para compatibilidad
      let vipSet = window.vipSet;
      let z0VipSet = window.z0VipSet;
      let donadorSet = window.donadorSet;
      let unsubscribeSolicitudes = null;
      let currentDayItems = [];

      function renderSolicitudes(items) {
        if (!solicitudesList) {
          console.error('❌ solicitudesList no encontrado');
          return;
        }
        solicitudesList.innerHTML = '';
        if (!items.length) {
          emptyEl.hidden = false;
          return;
        }
        emptyEl.hidden = true;
        items.forEach((it, index) => {
          const isVip = vipSet.has(it.usuario);
          const isZ0Vip = z0VipSet.has(it.usuario);
          const isDonador = donadorSet.has(it.usuario);
          const li = document.createElement('li');
          
          // Crear ID único para la canción
          const songId = `${it.usuario}-${it.cancion}-${it.artista}-${it.hora}`.replace(/[^a-zA-Z0-9-]/g, '');
          li.dataset.songId = songId;
          
          if (isZ0Vip) {
            li.className = 'item z0-vip';
          } else if (isVip) {
            li.className = 'item vip';
          } else if (isDonador) {
            li.className = 'item donador';
          } else {
            li.className = 'item';
          }
          
          // Verificar si la canción está marcada como reproducida
          const playedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
          const currentDay = document.getElementById('day-select')?.value || '';
          if (playedSongs[currentDay] && playedSongs[currentDay].includes(songId)) {
            li.classList.add('played');
          }
          
          li.innerHTML = `
            <span class="col col-time">${it.hora || ''}</span>
            <span class="col col-usuario usuario">${it.usuario}</span>
            <span class="col col-cancion">${it.cancion}</span>
            <span class="col col-artista">${it.artista}</span>
            <button class="play-toggle-btn" title="Marcar como reproducida/no reproducida">
              <span class="play-icon">▶️</span>
            </button>
          `;
          
          // Hacer el texto seleccionable
          li.style.userSelect = 'text';
          li.style.cursor = 'text';
          
          // Agregar evento de clic solo al botón para marcar/desmarcar
          const toggleBtn = li.querySelector('.play-toggle-btn');
          toggleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Solo dispositivos de escritorio pueden marcar canciones
            if (!isDJDevice()) {
              return; // Salir silenciosamente
            }
            
            toggleSongPlayed(li, songId, currentDay);
          });
          
          solicitudesList.appendChild(li);
        });
        
        // Verificar que los eventos de clic se hayan agregado correctamente
        const clickableItems = solicitudesList.querySelectorAll('.item');
        console.log(`✅ Renderizadas ${clickableItems.length} canciones clickeables`);
        
        // Forzar estilos en canciones reproducidas después del renderizado
        setTimeout(() => {
          forcePlayedSongStyles();
        }, 100);
        
        // Actualizar selector de usuarios cuando hay nuevos datos
        setTimeout(() => {
          if (typeof populateUserSelector === 'function') {
            populateUserSelector().catch(error => {
              console.error('Error en populateUserSelector, usando fallback:', error);
              populateUserSelectorFromLocalStorage();
            });
          } else {
            populateUserSelectorFromLocalStorage();
          }
        }, 100);
        
        // Analizar automáticamente nuevos usuarios
        analyzeNewUsersAutomatically().catch(console.error);
      }

      // Función para alternar el estado de canción reproducida (con sincronización Firebase)
      // Función para sincronizar configuración con Firebase
      async function bootstrapDJConfig() {
        try {
          if (!window.db) return;
          
          const currentFingerprint = generateDeviceFingerprint();
          const djConfigRef = window.db.collection('systemConfig').doc('djConfig');
          
          // Verificar si ya existe una configuración en Firebase
          const djConfigDoc = await djConfigRef.get();
          
          if (!djConfigDoc.exists) {
            // Primera vez: registrar este dispositivo como el autorizado en Firebase
            await djConfigRef.set({
              masterFingerprint: currentFingerprint,
              lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            });
            localStorage.setItem('masterDJFingerprint', currentFingerprint);
            localStorage.setItem('isMasterDJDevice', 'true');
          } else {
            // Sincronizar con la configuración existente en Firebase
            const masterFingerprint = djConfigDoc.data().masterFingerprint;
            localStorage.setItem('masterDJFingerprint', masterFingerprint);
            
            const isMaster = masterFingerprint === currentFingerprint;
            localStorage.setItem('isMasterDJDevice', isMaster ? 'true' : 'false');
          }
        } catch (error) {
          // En caso de error, usar solo localStorage
          const currentFingerprint = generateDeviceFingerprint();
          const masterFingerprint = localStorage.getItem('masterDJFingerprint');
          
          if (!masterFingerprint) {
            localStorage.setItem('masterDJFingerprint', currentFingerprint);
            localStorage.setItem('isMasterDJDevice', 'true');
          }
        }
      }

      // Función para verificar si este dispositivo puede modificar canciones
      function isDJDevice() {
        try {
          // Detectar automáticamente si es un dispositivo de escritorio
          const isDesktop = !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
          const hasLargeScreen = screen.width >= 1024;
          const isLikelyDJDevice = isDesktop && hasLargeScreen;
          
          return isLikelyDJDevice;
        } catch (e) {
          return false;
        }
      }

      // Función para generar fingerprint del dispositivo
      function generateDeviceFingerprint() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillText('Device fingerprint', 2, 2);
        
        const fingerprint = [
          navigator.userAgent,
          navigator.language,
          screen.width + 'x' + screen.height,
          new Date().getTimezoneOffset(),
          canvas.toDataURL()
        ].join('|');
        
        // Crear hash simple del fingerprint
        let hash = 0;
        for (let i = 0; i < fingerprint.length; i++) {
          const char = fingerprint.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        
        const deviceId = 'device_' + Math.abs(hash).toString(36);
        
        return deviceId;
      }

      async function toggleSongPlayed(element, songId, passedDay) {
        try {
          // Verificar si este dispositivo puede modificar canciones
          if (!isDJDevice()) {
            // No hacer nada, solo retornar silenciosamente
            return;
          }
          
          // Obtener el día actual del selector o usar el pasado como parámetro
          const currentDay = passedDay || document.getElementById('day-select')?.value || '';
          
          if (!currentDay) {
            console.warn('No se pudo obtener el día actual');
            return;
          }
          
          // Obtener datos locales como respaldo
          const localPlayedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
          if (!localPlayedSongs[currentDay]) {
            localPlayedSongs[currentDay] = [];
          }
          
          const isPlayed = localPlayedSongs[currentDay].includes(songId);
          
          // Actualizar estado local inmediatamente para UX responsiva
          if (isPlayed) {
            // Desmarcar como reproducida
            localPlayedSongs[currentDay] = localPlayedSongs[currentDay].filter(id => id !== songId);
            element.classList.remove('played');
            
            // Remover indicador visual si existe
            const indicator = element.querySelector('.played-indicator');
            if (indicator) {
              indicator.remove();
            }
            
            // Restaurar estilos originales
            element.style.backgroundColor = '';
            element.style.color = '';
            element.style.opacity = '';
          } else {
            // Marcar como reproducida
            localPlayedSongs[currentDay].push(songId);
            element.classList.add('played');
          }
          
          // Guardar en localStorage como respaldo
          localStorage.setItem('playedSongs', JSON.stringify(localPlayedSongs));
          
          // Sincronizar con Firebase para que todos los usuarios vean el cambio
          try {
            if (window.db) {
              const playedSongsRef = window.db.collection('playedSongs').doc(currentDay);
              
              if (isPlayed) {
                // Remover canción de la lista en Firebase
                await playedSongsRef.update({
                  songs: firebase.firestore.FieldValue.arrayRemove(songId),
                  lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });
              } else {
                // Agregar canción a la lista en Firebase
                await playedSongsRef.set({
                  songs: firebase.firestore.FieldValue.arrayUnion(songId),
                  lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                  day: currentDay
                }, { merge: true });
              }
            }
          } catch (firebaseError) {
            console.warn('Error sincronizando con Firebase, usando solo localStorage:', firebaseError);
          }
          
          // Forzar estilos para asegurar que se vean correctamente
          setTimeout(() => {
            forcePlayedSongStyles();
          }, 50);
          
        } catch (error) {
          console.error('Error en toggleSongPlayed:', error);
        }
      }

      // Función para mostrar el estado del dispositivo (silenciosa)
      function showDJStatus() {
        // Función silenciosa - no muestra mensajes al usuario
        const isDJ = isDJDevice();
        const statusElement = document.getElementById('dj-status');
        
        if (statusElement) {
          // Ocultar el elemento de estado para que no moleste
          statusElement.style.display = 'none';
        }
        
        // No mostrar ningún indicador visual al usuario
        return;
      }

      // Función de diagnóstico para verificar el estado del dispositivo DJ
      window.diagnosticoDJ = function() {
        console.log('🔍 DIAGNÓSTICO DEL DISPOSITIVO DJ');
        console.log('================================');
        
        const fingerprint = generateDeviceFingerprint();
        const storedFingerprint = localStorage.getItem('deviceFingerprint');
        const isMasterDevice = localStorage.getItem('isMasterDJDevice');
        const isDJ = isDJDevice();
        
        console.log('📱 Información del dispositivo:');
        console.log('  - User Agent:', navigator.userAgent.substring(0, 100) + '...');
        console.log('  - Pantalla:', screen.width + 'x' + screen.height);
        console.log('  - Idioma:', navigator.language);
        console.log('  - Zona horaria:', new Date().getTimezoneOffset());
        
        console.log('🔑 Fingerprints:');
        console.log('  - Actual:', fingerprint);
        console.log('  - Almacenado:', storedFingerprint);
        
        console.log('🎧 Estado DJ:');
        console.log('  - Es dispositivo DJ:', isDJ);
        console.log('  - Configuración almacenada:', isMasterDevice);
        
        const isDesktop = !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
        const hasLargeScreen = screen.width >= 1024;
        
        console.log('📊 Criterios de detección:');
        console.log('  - Es escritorio:', isDesktop);
        console.log('  - Pantalla grande (>=1024px):', hasLargeScreen);
        console.log('  - Cumple criterios DJ:', isDesktop && hasLargeScreen);
        
        if (!isDJ) {
          console.log('⚠️ PROBLEMA: Este dispositivo no está autorizado como DJ');
          console.log('💡 SOLUCIÓN: Ejecuta resetearDispositivoDJ() para reconfigurar');
        } else {
          console.log('✅ Dispositivo DJ configurado correctamente');
        }
        
        return { fingerprint, isDJ, isDesktop, hasLargeScreen };
      };
      
      // Función para resetear la configuración del dispositivo DJ
      window.resetearDispositivoDJ = function() {
        console.log('🔄 Reseteando configuración del dispositivo DJ...');
        localStorage.removeItem('deviceFingerprint');
        localStorage.removeItem('isMasterDJDevice');
        localStorage.removeItem('masterDJFingerprint');
        
        // Forzar redetección
        const isDJ = isDJDevice();
        console.log(isDJ ? '✅ Dispositivo reconfigurado como DJ' : '❌ Dispositivo sigue sin ser DJ');
        
        // Actualizar estado visual
        showDJStatus();
        
        return isDJ;
      };
      
      // Función para forzar este dispositivo como DJ principal
      window.configurarComoDJ = function() {
        console.log('🎧 Configurando este dispositivo como DJ principal...');
        const fingerprint = generateDeviceFingerprint();
        localStorage.setItem('masterDJFingerprint', fingerprint);
        localStorage.setItem('isMasterDJDevice', 'true');
        
        // Actualizar estado visual
        showDJStatus();
        
        console.log('✅ Dispositivo configurado como DJ principal');
        console.log('💡 Ahora puedes marcar canciones como reproducidas');
        
        return true;
      };

      // Función para verificar que la funcionalidad esté funcionando
      async function initializePlayedSongs() {
        console.log('Inicializando funcionalidad de canciones reproducidas...');
        
        // La detección de dispositivo DJ es automática
        
        // Verificar estado de autenticación silenciosamente
        const isDJ = isDJDevice();
        
        // Verificar localStorage
        const playedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
        console.log('Canciones reproducidas en localStorage:', playedSongs);
        
        // Verificar que los estilos CSS estén cargados
        const testElement = document.createElement('div');
        testElement.className = 'item played';
        document.body.appendChild(testElement);
        const styles = window.getComputedStyle(testElement);
        console.log('Estilos CSS para .item.played:', {
          backgroundColor: styles.backgroundColor,
          color: styles.color,
          opacity: styles.opacity,
          cursor: styles.cursor
        });
        document.body.removeChild(testElement);
        
        console.log('Funcionalidad de canciones reproducidas inicializada correctamente');
      }

      // Función para forzar estilos en canciones reproducidas (fallback)
      function forcePlayedSongStyles() {
        const playedItems = document.querySelectorAll('.item.played');
        console.log(`Forzando estilos en ${playedItems.length} canciones reproducidas`);
        
        playedItems.forEach(item => {
          // Obtener tema actual
          const isDark = document.body.classList.contains('dark-theme');
          const themeClass = Array.from(document.body.classList).find(cls => cls.startsWith('theme-'));
          
          // Aplicar estilos base
          item.style.opacity = '0.7';
          item.style.cursor = 'pointer';
          item.style.transition = 'all 0.2s ease';
          item.style.position = 'relative';
          
          // Aplicar colores según tema
          if (themeClass === 'theme-blue') {
            item.style.backgroundColor = isDark ? '#1e3a8a' : '#dbeafe';
            item.style.color = isDark ? '#93c5fd' : '#1e40af';
          } else if (themeClass === 'theme-green') {
            item.style.backgroundColor = isDark ? '#14532d' : '#dcfce7';
            item.style.color = isDark ? '#86efac' : '#166534';
          } else if (themeClass === 'theme-purple') {
            item.style.backgroundColor = isDark ? '#581c87' : '#f3e8ff';
            item.style.color = isDark ? '#c4b5fd' : '#7c3aed';
          } else if (themeClass === 'theme-red') {
            item.style.backgroundColor = isDark ? '#991b1b' : '#fee2e2';
            item.style.color = isDark ? '#fca5a5' : '#dc2626';
          } else if (themeClass === 'theme-pink') {
            item.style.backgroundColor = isDark ? '#9d174d' : '#fce7f3';
            item.style.color = isDark ? '#f9a8d4' : '#be185d';
          } else {
            // Tema por defecto
            item.style.backgroundColor = isDark ? '#374151' : '#f3f4f6';
            item.style.color = isDark ? '#9ca3af' : '#6b7280';
          }
          
          // Agregar indicador ✓ si no existe
          if (!item.querySelector('.played-indicator')) {
            const indicator = document.createElement('span');
            indicator.className = 'played-indicator';
            indicator.textContent = '✓';
            indicator.style.cssText = `
              position: absolute;
              left: 4px;
              top: 50%;
              transform: translateY(-50%);
              font-size: 12px;
              font-weight: bold;
              color: ${isDark ? '#34d399' : '#10b981'};
              z-index: 1;
            `;
            item.insertBefore(indicator, item.firstChild);
          }
        });
      }

      function toHour(ts) {
        if (!ts) return '';
        const d = ts.toDate ? ts.toDate() : new Date(ts);
        return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      async function loadDays() {
        const snap = await db.collection('solicitudes').orderBy('day', 'desc').limit(500).get();
        const days = new Set();
        snap.forEach(doc => days.add(doc.data().day));
        const sorted = Array.from(days).sort().reverse();
        daySelect.innerHTML = '';
        sorted.forEach(d => {
          const opt = document.createElement('option');
          opt.value = d;
          opt.textContent = d;
          daySelect.appendChild(opt);
        });
        if (sorted.length) {
          daySelect.value = sorted[0];
        }

        if (!daySelect.value) {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          const localDays = Object.keys(byDay).sort().reverse();
          if (localDays.length) {
            daySelect.innerHTML = '';
            localDays.forEach(d => {
              const opt = document.createElement('option');
              opt.value = d;
              opt.textContent = d;
              daySelect.appendChild(opt);
            });
            daySelect.value = localDays[0];
          }
        }
      }

      function subscribeSolicitudesForDay(dayValue) {
        if (unsubscribeSolicitudes) {
          unsubscribeSolicitudes();
          unsubscribeSolicitudes = null;
        }
        const q = db.collection('solicitudes')
          .where('day', '==', dayValue)
          .orderBy('ts', 'desc');

        unsubscribeSolicitudes = q.onSnapshot((snap) => {
          let items = [];
          snap.forEach((doc) => {
            const data = doc.data();
            const isVip = vipSet.has(data.usuario) || z0VipSet.has(data.usuario);
            if (vipOnly.checked && !isVip) return;
            items.push({
              usuario: data.usuario,
              cancion: data.cancion,
              artista: data.artista,
              hora: toHour(data.ts),
              day: dayValue
            });
          });

          if (items.length === 0) {
            const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
            const arr = Array.isArray(byDay[dayValue]) ? byDay[dayValue] : [];
            items = arr
              .filter(it => !vipOnly.checked || vipSet.has(it.usuario) || z0VipSet.has(it.usuario))
              .map(it => ({
                usuario: it.usuario,
                cancion: it.cancion,
                artista: it.artista,
                hora: toHour(it.time),
                day: dayValue
              }));
          }

          currentDayItems = items;
          renderSolicitudes(items);
        }, (err) => {
          console.error('Error suscripción solicitudes:', err);
        });
      }

      // Hacer accesible desde el IIFE de UI
      window.subscribeSolicitudesForDay = subscribeSolicitudesForDay;

      // Buscar ignorando acentos y en canción/artista/usuario en TODOS los días
      async function searchSolicitudes(query) {
        const normalize = (s) => String(s || '')
          .toLowerCase()
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '');

        const q = normalize(query);
        if (!q) return [];

        let allResults = [];

        try {
          // Buscar en Firestore
          const firestoreSnapshot = await db.collection('solicitudes').get();
          firestoreSnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.ts && data.ts.toDate) {
              const date = data.ts.toDate();
              const dayValue = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
              
              const song = normalize(data.cancion);
              const artist = normalize(data.artista);
              const user = normalize(data.usuario);
              
              if (song.includes(q) || artist.includes(q) || user.includes(q)) {
                allResults.push({
                  usuario: data.usuario,
                  cancion: data.cancion,
                  artista: data.artista,
                  hora: toHour(data.ts),
                  day: dayValue
                });
              }
            }
          });
        } catch (error) {
          console.log('Error buscando en Firestore, usando localStorage:', error);
        }

        // Buscar también en localStorage como respaldo
        const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
        Object.keys(byDay).forEach(dayValue => {
          const dayItems = Array.isArray(byDay[dayValue]) ? byDay[dayValue] : [];
          dayItems.forEach(it => {
            const song = normalize(it.cancion);
            const artist = normalize(it.artista);
            const user = normalize(it.usuario);
            
            if (song.includes(q) || artist.includes(q) || user.includes(q)) {
              // Evitar duplicados de Firestore
              const exists = allResults.some(result => 
                result.cancion === it.cancion && 
                result.artista === it.artista && 
                result.usuario === it.usuario && 
                result.day === dayValue
              );
              
              if (!exists) {
                allResults.push({
                  usuario: it.usuario,
                  cancion: it.cancion,
                  artista: it.artista,
                  hora: toHour(it.time),
                  day: dayValue
                });
              }
            }
          });
        });

        // Ordenar por fecha más reciente primero
        allResults.sort((a, b) => {
          const dateA = new Date(a.day);
          const dateB = new Date(b.day);
          return dateB - dateA;
        });

        return allResults;
      }
      window.searchSolicitudes = searchSolicitudes;

      function subscribeVipUsers() {
        console.log('🔄 Iniciando suscripción VIP...');
        db.collection('vipUsers').onSnapshot((snap) => {
          console.log(`📊 VIP snapshot recibido: ${snap.size} documentos`);
          window.vipSet = new Set();
          vipSet = window.vipSet;
          vipListEl.innerHTML = '';
          snap.forEach((doc) => {
            const { name } = doc.data();
            if (name) {
              vipSet.add(name);
              const li = document.createElement('li');
              li.innerHTML = `
                <span>${name}</span>
                <button type="button" class="remove-btn" data-user="${name}" aria-label="Quitar VIP">×</button>
              `;
              vipListEl.appendChild(li);
            }
          });
          
          // Procesar logros VIP después de cargar los datos
          console.log(`🔄 VIP set actualizado, procesando logros para ${vipSet.size} usuarios VIP`);
          setTimeout(() => {
            vipSet.forEach(username => {
              window.grantBadgeAchievement(username);
            });
          }, 1000);
          
          if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
        }, (err) => {
          console.error('❌ Error suscripción VIP:', err);
        });
      }

      function subscribeZ0VipUsers() {
        console.log('🔄 Iniciando suscripción Z0-VIP...');
        const z0VipListEl = document.getElementById('z0-vip-list');
        db.collection('z0VipUsers').onSnapshot((snap) => {
          console.log(`📊 Z0-VIP snapshot recibido: ${snap.size} documentos`);
          window.z0VipSet = new Set();
          z0VipSet = window.z0VipSet;
          if (z0VipListEl) {
            z0VipListEl.innerHTML = '';
          }
          snap.forEach((doc) => {
            const { name } = doc.data();
            if (name) {
              z0VipSet.add(name);
              if (z0VipListEl) {
                const li = document.createElement('li');
                li.innerHTML = `
                  <span>${name}</span>
                  <button type="button" class="remove-btn" data-user="${name}" data-type="z0" aria-label="Quitar Z0-VIP">×</button>
                `;
                z0VipListEl.appendChild(li);
              }
            }
          });
          
          // Procesar logros Z0-VIP después de cargar los datos
          console.log(`🔄 Z0-VIP set actualizado, procesando logros para ${z0VipSet.size} usuarios Z0-VIP`);
          setTimeout(() => {
            z0VipSet.forEach(username => {
              window.grantBadgeAchievement(username);
            });
          }, 1000);
          
          if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
        }, (err) => {
          console.error('❌ Error suscripción Z0-VIP:', err);
        });
      }

      function subscribeDonadorUsers() {
        console.log('🔄 Iniciando suscripción Donador...');
        db.collection('donadorUsers').onSnapshot((snap) => {
          console.log(`📊 Donador snapshot recibido: ${snap.size} documentos`);
          window.donadorSet = new Set();
          donadorSet = window.donadorSet;
          if (donadorListEl) {
            donadorListEl.innerHTML = '';
          }
          
          const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
          
          snap.forEach((doc) => {
            const data = doc.data();
            const { name, expiresAt } = data;
            
            if (name && expiresAt) {
              const expireDate = expiresAt.split('T')[0]; // YYYY-MM-DD
              
              // Si ya expiró, eliminar automáticamente
              if (expireDate < today) {
                db.collection('donadorUsers').doc(doc.id).delete().catch(console.error);
                return;
              }
              
              donadorSet.add(name);
              if (donadorListEl) {
                const li = document.createElement('li');
                li.innerHTML = `
                  <span>${name} (hasta ${expireDate})</span>
                  <button type="button" class="remove-btn" data-user="${name}" data-type="donador" aria-label="Quitar Donador">×</button>
                `;
                donadorListEl.appendChild(li);
              }
            }
          });
          
          // Procesar logros Donador después de cargar los datos
          console.log(`🔄 Donador set actualizado, procesando logros para ${donadorSet.size} usuarios Donador`);
          setTimeout(() => {
            donadorSet.forEach(username => {
              window.grantBadgeAchievement(username);
            });
          }, 1000);
          
          if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
        }, (err) => {
          console.error('❌ Error suscripción Donadores:', err);
        });
      }

      // Suscripción en tiempo real para canciones reproducidas (sincronización global)
      function subscribePlayedSongs(day) {
        if (!day || !window.db) return;
        
        console.log('🎵 Suscribiéndose a canciones reproducidas para el día:', day);
        
        // Cancelar suscripción anterior si existe
        if (window.playedSongsUnsubscribe) {
          window.playedSongsUnsubscribe();
        }
        
        // Suscribirse a cambios en tiempo real
        window.playedSongsUnsubscribe = window.db.collection('playedSongs').doc(day)
          .onSnapshot((doc) => {
            try {
              const data = doc.data();
              const firebaseSongs = data?.songs || [];
              
              console.log('🔄 Actualización de Firebase para canciones reproducidas:', {
                day,
                songs: firebaseSongs,
                count: firebaseSongs.length
              });
              
              // Actualizar localStorage con datos de Firebase
              const localPlayedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
              localPlayedSongs[day] = firebaseSongs;
              localStorage.setItem('playedSongs', JSON.stringify(localPlayedSongs));
              
              // Actualizar interfaz visual
              updatePlayedSongsUI(day, firebaseSongs);
              
            } catch (error) {
              console.error('Error procesando actualización de canciones reproducidas:', error);
            }
          }, (error) => {
            console.error('Error en suscripción de canciones reproducidas:', error);
          });
      }

      // Función para actualizar la interfaz visual de canciones reproducidas
      function updatePlayedSongsUI(day, playedSongIds) {
        try {
          const currentDay = document.getElementById('day-select')?.value;
          
          // Solo actualizar si estamos viendo el día correcto
          if (currentDay !== day) {
            console.log('Día diferente, no actualizando UI:', { currentDay, day });
            return;
          }
          
          console.log('🎨 Actualizando UI para canciones reproducidas:', {
            day,
            playedSongs: playedSongIds,
            count: playedSongIds.length
          });
          
          // Obtener todos los elementos de canciones
          const songItems = document.querySelectorAll('.item[data-song-id]');
          
          songItems.forEach(item => {
            const songId = item.getAttribute('data-song-id');
            const isPlayed = playedSongIds.includes(songId);
            
            if (isPlayed) {
              // Marcar como reproducida
              item.classList.add('played');
            } else {
              // Desmarcar como reproducida
              item.classList.remove('played');
              
              // Remover indicador visual si existe
              const indicator = item.querySelector('.played-indicator');
              if (indicator) {
                indicator.remove();
              }
              
              // Restaurar estilos originales
              item.style.backgroundColor = '';
              item.style.color = '';
              item.style.opacity = '';
            }
          });
          
          // Forzar aplicación de estilos
          setTimeout(() => {
            forcePlayedSongStyles();
          }, 100);
          
        } catch (error) {
          console.error('Error actualizando UI de canciones reproducidas:', error);
        }
      }

      async function renderAllUsersSelect() {
        const set = new Set();

        try {
          // Obtener usuarios de la colección 'users' de Firebase
          const snap = await db.collection('users').orderBy('name').get();
          snap.forEach(doc => {
            const { name } = doc.data();
            if (name) set.add(name);
          });

          // Obtener usuarios de la colección 'solicitudes' de Firebase
          const reqSnap = await db.collection('solicitudes').orderBy('day', 'desc').limit(1000).get();
          reqSnap.forEach(doc => {
            const u = String(doc.data().usuario || '').trim();
            if (u) set.add(u);
          });
        } catch (error) {
          console.error('Error obteniendo usuarios de Firebase:', error);
        }

        // Siempre agregar usuarios de localStorage como complemento
        try {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          Object.values(byDay).forEach(arr => (arr || []).forEach(it => {
            const u = String(it.usuario || '').trim();
            if (u) set.add(u);
          }));
          const legacy = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          (legacy || []).forEach(it => {
            const u = String(it.usuario || '').trim();
            if (u) set.add(u);
          });
        } catch (error) {
          console.error('Error obteniendo usuarios de localStorage:', error);
        }

        const list = Array.from(set).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        allUsersSelect.innerHTML = '<option value="">Selecciona un usuario</option>';
        const allUsersSelectZ0 = document.getElementById('all-users-select-z0');
        if (allUsersSelectZ0) {
          allUsersSelectZ0.innerHTML = '<option value="">Selecciona un usuario</option>';
        }
        if (allUsersSelectDonador) {
          allUsersSelectDonador.innerHTML = '<option value="">Selecciona un usuario</option>';
        }
        
        list.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          allUsersSelect.appendChild(opt);
          
          if (allUsersSelectZ0) {
            const optZ0 = document.createElement('option');
            optZ0.value = name;
            optZ0.textContent = name;
            allUsersSelectZ0.appendChild(optZ0);
          }
          
          if (allUsersSelectDonador) {
            const optDonador = document.createElement('option');
            optDonador.value = name;
            optDonador.textContent = name;
            allUsersSelectDonador.appendChild(optDonador);
          }
        });
      }
      window.renderAllUsersSelect = renderAllUsersSelect;

      vipAddBtn?.addEventListener('click', async () => {
        const name = allUsersSelect.value.trim();
        if (!name) {
          alert('Selecciona un usuario del listado.');
          return;
        }
        try {
          await db.collection('vipUsers').doc(name).set({ name }, { merge: true });
        } catch (err) {
          console.error('Error al agregar VIP:', err);
          alert('No se pudo agregar el usuario a VIP. Revisa reglas/permisos.');
        }
      });

      const z0VipAddBtn = document.getElementById('z0-vip-add');
      z0VipAddBtn?.addEventListener('click', async () => {
        const allUsersSelectZ0 = document.getElementById('all-users-select-z0');
        const name = allUsersSelectZ0?.value.trim();
        if (!name) {
          alert('Selecciona un usuario del listado.');
          return;
        }
        try {
          await db.collection('z0VipUsers').doc(name).set({ name }, { merge: true });
        } catch (err) {
          console.error('Error al agregar Z0-VIP:', err);
          alert('No se pudo agregar el usuario a Z0-VIP. Revisa reglas/permisos.');
        }
      });

      donadorAddBtn?.addEventListener('click', async () => {
        const name = allUsersSelectDonador?.value.trim();
        if (!name) {
          alert('Selecciona un usuario del listado.');
          return;
        }
        
        // Calcular fecha de expiración (mañana a las 23:59:59)
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(23, 59, 59, 999);
        const expiresAt = tomorrow.toISOString();
        
        try {
          await db.collection('donadorUsers').doc(name).set({ 
            name, 
            expiresAt,
            createdAt: new Date().toISOString()
          }, { merge: true });
          
          // Limpiar selección
          allUsersSelectDonador.value = '';
          
        } catch (err) {
          console.error('Error al agregar Donador:', err);
          alert('No se pudo agregar el usuario como Donador. Revisa reglas/permisos.');
        }
      });

      vipListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('.remove-btn');
        if (!btn) return;
        const user = btn.getAttribute('data-user');
        if (!user) return;

        pendingVipRemoveUser = user;
        pendingVipRemoveType = 'vip';
        vipRemoveUserSpan.textContent = user;
        vipRemoveModal.hidden = false;
      });

      const z0VipListEl = document.getElementById('z0-vip-list');
      z0VipListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('.remove-btn');
        if (!btn) return;
        const user = btn.getAttribute('data-user');
        const type = btn.getAttribute('data-type');
        if (!user) return;

        pendingVipRemoveUser = user;
        pendingVipRemoveType = type || 'z0';
        vipRemoveUserSpan.textContent = user;
        vipRemoveModal.hidden = false;
      });

      donadorListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('.remove-btn');
        if (!btn) return;
        const user = btn.getAttribute('data-user');
        const type = btn.getAttribute('data-type');
        if (!user) return;

        pendingVipRemoveUser = user;
        pendingVipRemoveType = type || 'donador';
        vipRemoveUserSpan.textContent = user;
        vipRemoveModal.hidden = false;
      });

      vipRemoveCancelBtn?.addEventListener('click', () => {
        pendingVipRemoveUser = null;
        pendingVipRemoveType = 'vip';
        vipRemoveModal.hidden = true;
      });

      vipRemoveConfirmBtn?.addEventListener('click', async () => {
        if (!pendingVipRemoveUser) return;
        try {
          let collection = 'vipUsers';
          if (pendingVipRemoveType === 'z0') {
            collection = 'z0VipUsers';
          } else if (pendingVipRemoveType === 'donador') {
            collection = 'donadorUsers';
          }
          await db.collection(collection).doc(pendingVipRemoveUser).delete();
        } catch (err) {
          console.error('Error al quitar insignia:', err);
          alert('No se pudo quitar la insignia. Revisa reglas/permisos.');
        } finally {
          pendingVipRemoveUser = null;
          pendingVipRemoveType = 'vip';
          vipRemoveModal.hidden = true;
        }
      });

      const wipeAllModal = document.getElementById('wipe-all-modal');
      const wipeAllDaySpan = document.getElementById('wipe-all-day');
      const wipeAllCancelBtn = document.getElementById('wipe-all-cancel');
      const wipeAllConfirmBtn = document.getElementById('wipe-all-confirm');
      const recalculateUsersBtn = document.getElementById('recalculate-users');
      const diagnoseDataBtn = document.getElementById('diagnose-data-btn');

      wipeAllBtn?.addEventListener('click', () => {
        if (!daySelect.value) return;
        wipeAllDaySpan.textContent = daySelect.value;
        wipeAllModal.hidden = false;
      });

      wipeAllCancelBtn?.addEventListener('click', () => {
        wipeAllModal.hidden = true;
      });

      wipeAllConfirmBtn?.addEventListener('click', async () => {
        const day = daySelect.value;
        if (!day) {
          wipeAllModal.hidden = true;
          return;
        }

        wipeAllBtn.disabled = true;

        try {
          const snap = await db.collection('solicitudes').where('day', '==', day).get();
          const docs = snap.docs;

          const chunkSize = 500;
          for (let i = 0; i < docs.length; i += chunkSize) {
            const batch = db.batch();
            const chunk = docs.slice(i, i + chunkSize);
            chunk.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
          }

          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          if (byDay && byDay[day]) {
            delete byDay[day];
            localStorage.setItem('solicitudes_by_day', JSON.stringify(byDay));
          }

          if (daySelect.value === day) {
            subscribeSolicitudesForDay(day);
          }
        } catch (err) {
          console.error('Error al borrar solicitudes:', err);
          alert('Ocurrió un error al borrar las solicitudes. Verifica reglas y vuelve a intentar.');
        } finally {
          wipeAllBtn.disabled = false;
          wipeAllModal.hidden = true;
        }
      });

      // Event listener para recálculo de usuarios
      recalculateUsersBtn?.addEventListener('click', async () => {
        const confirmed = await showConfirmation({
          icon: '🔄',
          title: 'Recalcular Usuarios',
          message: '¿Confirmas que quieres recalcular todos los usuarios? Esto corregirá puntos e insignias inconsistentes.',
          confirmText: 'Sí, Recalcular',
          cancelText: 'Cancelar'
        });
        
        if (confirmed) {
          recalculateUsersBtn.disabled = true;
          recalculateUsersBtn.textContent = '🔄 Recalculando...';
          
          try {
            await recalculateAllUsers();
          } finally {
            recalculateUsersBtn.disabled = false;
            recalculateUsersBtn.textContent = '🔄 Recalcular todos los usuarios';
          }
        }
      });

      // Event listener para diagnóstico de datos
      diagnoseDataBtn?.addEventListener('click', async () => {
        const userInput = prompt('Ingresa el nombre del usuario a diagnosticar (deja vacío para el usuario actual):');
        const targetUser = userInput?.trim() || getCurrentUser();
        
        try {
          diagnoseDataBtn.disabled = true;
          diagnoseDataBtn.textContent = '🔍 Diagnosticando...';
          
          const results = await diagnoseSolicitudesIssues(targetUser);
          
          alert(`Diagnóstico completado para ${targetUser}:\n\n` +
                `Firestore: ${results.firestoreCount} solicitudes\n` +
                `localStorage directo: ${results.localStorageCount} solicitudes\n` +
                `localStorage por día: ${results.byDayCount} solicitudes\n` +
                `Función combinada: ${results.combinedCount} solicitudes\n\n` +
                `Revisa la consola para más detalles.`);
        } catch (error) {
          console.error('Error en diagnóstico:', error);
          alert('Error al ejecutar diagnóstico. Revisa la consola.');
        } finally {
          diagnoseDataBtn.disabled = false;
          diagnoseDataBtn.textContent = '🔍 Diagnosticar datos de usuario';
        }
      });

      // Event listener para prueba de cambio de usuario
      document.getElementById('test-user-switch-btn')?.addEventListener('click', async () => {
        const testUser = prompt('Ingresa el nombre del usuario para probar:');
        if (testUser?.trim()) {
          console.log(`🧪 INICIANDO PRUEBA DE CAMBIO DE USUARIO: ${testUser}`);
          
          try {
            // Forzar procesamiento del usuario
            await analyzeAndGrantPointsForUser(testUser.trim(), true);
            
            // Cambiar al usuario
            await switchToUser(testUser.trim());
            
            // Abrir modal si no está abierto
            const modal = document.getElementById('gamification-modal');
            if (modal && modal.hidden) {
              modal.hidden = false;
            }
            
            console.log(`✅ PRUEBA COMPLETADA para usuario: ${testUser}`);
          } catch (error) {
            console.error('❌ Error en prueba:', error);
            alert('Error en la prueba. Revisa la consola.');
          }
        }
      });

      // Event listener para debug del usuario actual
      document.getElementById('debug-current-user-btn')?.addEventListener('click', () => {
        console.log('🔍 === DEBUG ESTADO ACTUAL ===');
        console.log(`getCurrentUser(): ${getCurrentUser()}`);
        console.log(`getCurrentSelectedUser(): ${getCurrentSelectedUser()}`);
        console.log(`currentSelectedUser variable: ${currentSelectedUser}`);
        
        const selector = document.getElementById('gamification-user-select');
        console.log(`Valor del selector: ${selector?.value}`);
        console.log(`Opciones del selector:`, Array.from(selector?.options || []).map(o => o.value));
        
        const data = getGamificationDataForUser();
        console.log(`Datos del usuario actual:`, data);
        
        const allData = localStorage.getItem('gamificationData');
        console.log(`Todos los datos en localStorage:`, JSON.parse(allData || '{}'));
        
        console.log('🔍 === FIN DEBUG ===');
      });

      daySelect?.addEventListener('change', () => {
        if (daySelect.value) {
          subscribeSolicitudesForDay(daySelect.value);
          subscribePlayedSongs(daySelect.value);
        }
      });
      vipOnly?.addEventListener('change', () => {
        if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
      });

      (async function init() {
        console.log('🚀 Iniciando aplicación...');
        await loadDays();
        console.log('📅 Días cargados, iniciando suscripciones...');
        subscribeVipUsers();
        subscribeZ0VipUsers();
        subscribeDonadorUsers();
        console.log('✅ Suscripciones iniciadas');
        await renderAllUsersSelect();
        if (daySelect.value) {
          subscribeSolicitudesForDay(daySelect.value);
          subscribePlayedSongs(daySelect.value);
        }
      })();
    })();
  </script>

  <script>
    // Variables globales del menú
    const menuBtn = document.getElementById('menu-btn');
    const menuDropdown = document.getElementById('menu-dropdown');
    
    // Funciones globales del menú
    function openMenu() {
      if (!menuDropdown || !menuBtn) return;
      
      // Solo calcular posición en pantallas grandes (>768px)
      if (window.innerWidth > 768) {
        const btnRect = menuBtn.getBoundingClientRect();
        const padding = 8;
        const menuWidth = 220;
        
        // Calcular posición para alinear el menú a la derecha del botón
        const leftPosition = btnRect.right - menuWidth;
        const topPosition = btnRect.bottom + padding;
        
        // Asegurar que el menú no se salga por la izquierda
        const finalLeft = Math.max(leftPosition, 10);
        
        // Posicionar el menú
        menuDropdown.style.top = topPosition + 'px';
        menuDropdown.style.left = finalLeft + 'px';
        menuDropdown.style.right = 'auto';
        
        // Verificar si el menú se sale de la pantalla por abajo
        const menuHeight = 350;
        if (topPosition + menuHeight > window.innerHeight) {
          menuDropdown.style.top = (btnRect.top - menuHeight - padding) + 'px';
        }
      }
      
      menuDropdown.hidden = false;
      requestAnimationFrame(() => {
        menuDropdown.classList.add('open');
        menuBtn.setAttribute('aria-expanded', 'true');
      });
    }
    
    function closeMenu() {
      if (!menuDropdown) return;
      menuDropdown.classList.remove('open');
      menuBtn?.setAttribute('aria-expanded', 'false');
      const onEnd = (e) => {
        if (e.target !== menuDropdown) return;
        menuDropdown.hidden = true;
        menuDropdown.removeEventListener('transitionend', onEnd);
      };
      menuDropdown.addEventListener('transitionend', onEnd);
    }

    (function () {
      const menuAdminOpen = document.getElementById('menu-admin-open');
      const menuSearchOpen = document.getElementById('menu-search-open');

      // Referencias del changelog (una sola vez)
      const menuChangelogOpen = document.getElementById('menu-changelog-open');
      const changelogModal = document.getElementById('changelog-modal');
      const changelogCloseBtn = document.getElementById('changelog-close');

      const searchInput = document.getElementById('search-input');
      const searchResults = document.getElementById('search-results');
      const searchBox = document.querySelector('.search-box');
      const daySelect = document.getElementById('day-select');

      const ADMIN_PASS = '1415130*';
      const adminModal = document.getElementById('admin-modal');
      const adminPanel = document.getElementById('admin-panel');
      const adminPassInput = document.getElementById('admin-pass-input');
      const adminPassError = document.getElementById('admin-auth-error');
      const adminPassCancelBtn = document.getElementById('admin-pass-cancel');
      const adminPassConfirmBtn = document.getElementById('admin-pass-confirm');
      const allUsersSelect = document.getElementById('all-users-select');
      const vipAddBtn = document.getElementById('vip-add');
      const adminExitBtn = document.getElementById('admin-exit');

      // Variables para el sistema de secciones del panel admin
      const adminSectionSelect = document.getElementById('admin-section-select');
      const badgesSection = document.getElementById('badges-section');
      const rewardsSection = document.getElementById('rewards-section');
      const maintenanceSection = document.getElementById('maintenance-section');
      
      // Variables para el selector de insignias
      const badgeTypeSelect = document.getElementById('badge-type-select');
      const vipManagement = document.getElementById('vip-management');
      const z0VipManagement = document.getElementById('z0-vip-management');
      const donadorManagement = document.getElementById('donador-management');

      const userDeleteBtn = document.getElementById('user-delete');
      const userDeleteModal = document.getElementById('user-delete-modal');
      const userDeleteNameSpan = document.getElementById('user-delete-name');
      const userDeleteCancelBtn = document.getElementById('user-delete-cancel');
      const userDeleteConfirmBtn = document.getElementById('user-delete-confirm');
      let pendingUserDelete = null;

      menuBtn?.addEventListener('click', () => {
        if (!menuDropdown) return;
        if (menuDropdown.hidden) {
          openMenu();
        } else {
          closeMenu();
        }
      });

      document.addEventListener('click', (e) => {
        if (!menuDropdown || menuDropdown.hidden) return;
        const clickInside = menuDropdown.contains(e.target) || menuBtn.contains(e.target);
        if (!clickInside) {
          closeMenu();
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !menuDropdown.hidden) {
          closeMenu();
        }
      });

      // Reposicionar menú en cambios de tamaño de ventana
      window.addEventListener('resize', () => {
        if (!menuDropdown.hidden && window.innerWidth > 768) {
          const btnRect = menuBtn.getBoundingClientRect();
          const padding = 8;
          const menuWidth = 220;
          
          const leftPosition = btnRect.right - menuWidth;
          const topPosition = btnRect.bottom + padding;
          const finalLeft = Math.max(leftPosition, 10);
          
          menuDropdown.style.top = topPosition + 'px';
          menuDropdown.style.left = finalLeft + 'px';
          menuDropdown.style.right = 'auto';
          
          const menuHeight = 350;
          if (topPosition + menuHeight > window.innerHeight) {
            menuDropdown.style.top = (btnRect.top - menuHeight - padding) + 'px';
          }
        }
      });

      adminModal.hidden = true;
      adminPanel.hidden = true;
      // Event listeners para el modal de Admin
      menuAdminOpen?.addEventListener('click', () => {
        closeMenu();
        adminModal.hidden = false;
        adminPassInput.value = '';
        adminPassError.hidden = true;
        adminPassInput.focus();
      });

      function tryOpenAdmin() {
        const pass = adminPassInput.value;
        if (pass === ADMIN_PASS) {
          adminModal.hidden = true;
          adminPanel.hidden = false;
          window.renderAllUsersSelect?.();
          console.log('✅ Panel de administración abierto');
        } else {
          adminPassError.hidden = false;
          adminPassInput.focus();
        }
      }

      // Event listeners para el modal de Admin
      adminPassConfirmBtn?.addEventListener('click', tryOpenAdmin);
      adminPassCancelBtn?.addEventListener('click', () => {
        adminModal.hidden = true;
      });
      adminPassInput?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          tryOpenAdmin();
        }
      });

      adminExitBtn?.addEventListener('click', () => {
          adminPanel.hidden = true;
          adminModal.hidden = true;
          adminPassInput.value = '';
          adminPassError.hidden = true;
        });

      // Event listeners para el sistema de secciones
      adminSectionSelect?.addEventListener('change', (e) => {
        showAdminSection(e.target.value);
      });

      badgeTypeSelect?.addEventListener('change', (e) => {
        showBadgeManagement(e.target.value);
      });

      // Función para mostrar el panel de administración
      function showAdminPanel() {
        adminPanel.hidden = false;
        window.renderAllUsersSelect?.();
        showAdminSection('badges'); // Mostrar sección de insignias por defecto
      }

      // Función para mostrar una sección específica del admin
      function showAdminSection(section) {
        // Ocultar todas las secciones
        if (badgesSection) badgesSection.hidden = true;
        if (rewardsSection) rewardsSection.hidden = true;
        if (maintenanceSection) maintenanceSection.hidden = true;

        // Mostrar la sección seleccionada
        switch(section) {
          case 'badges':
            if (badgesSection) badgesSection.hidden = false;
            showBadgeManagement('vip'); // Mostrar VIP por defecto
            break;
          case 'rewards':
            if (rewardsSection) rewardsSection.hidden = false;
            loadRewardRequests(); // Cargar solicitudes de recompensas
            break;
          case 'maintenance':
            if (maintenanceSection) maintenanceSection.hidden = false;
            break;
        }
      }

      // Función para mostrar la gestión de una insignia específica
      function showBadgeManagement(badgeType) {
        // Ocultar todas las gestiones de insignias
        if (vipManagement) vipManagement.hidden = true;
        if (z0VipManagement) z0VipManagement.hidden = true;
        if (donadorManagement) donadorManagement.hidden = true;

        // Mostrar la gestión seleccionada
        switch(badgeType) {
          case 'vip':
            if (vipManagement) vipManagement.hidden = false;
            break;
          case 'z0-vip':
            if (z0VipManagement) z0VipManagement.hidden = false;
            break;
          case 'donador':
            if (donadorManagement) donadorManagement.hidden = false;
            break;
        }
      }

      userDeleteBtn?.addEventListener('click', () => {
        const name = allUsersSelect.value.trim();
        if (!name) {
          alert('Selecciona un usuario del listado.');
          return;
        }
        if (!userDeleteModal) {
          alert('No se encontró el modal de borrado de usuario en el HTML.');
          return;
        }
        pendingUserDelete = name;
        userDeleteNameSpan.textContent = name;
        userDeleteModal.hidden = false;
      });

      userDeleteCancelBtn?.addEventListener('click', () => {
        pendingUserDelete = null;
        userDeleteModal.hidden = true;
      });

      userDeleteConfirmBtn?.addEventListener('click', async () => {
        if (!pendingUserDelete) return;
        const name = pendingUserDelete;
        try {
          await window.ensureAuth?.();
          await window.db.collection('users').doc(name.toLowerCase()).delete();
          try { await window.db.collection('vipUsers').doc(name).delete(); } catch (_) {}
          if (typeof window.renderAllUsersSelect === 'function') {
            await window.renderAllUsersSelect();
          } else {
            const opt = Array.from(allUsersSelect.options).find(o => o.value === name);
            if (opt) allUsersSelect.remove(opt.index);
          }
          allUsersSelect.value = '';
        } catch (err) {
          console.error('Error al borrar usuario:', err);
          alert('No se pudo borrar el usuario. Revisa reglas/permisos.');
        } finally {
          pendingUserDelete = null;
          userDeleteModal.hidden = true;
        }
      });

      // Abrir buscador desde el menú
      menuSearchOpen?.addEventListener('click', () => {
        closeMenu();
        document.getElementById('search-input')?.focus();
      });

      function renderSearchResults(rows) {
        if (!searchResults) return;
        if (!rows.length) {
          searchResults.hidden = true;
          searchResults.innerHTML = '';
          return;
        }
        const list = rows.slice(0, 10).map(it => {
          // Formatear fecha para mostrar
          const formatDate = (dateStr) => {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            if (dateStr === today.toISOString().split('T')[0]) {
              return 'Hoy';
            } else if (dateStr === yesterday.toISOString().split('T')[0]) {
              return 'Ayer';
            } else {
              return date.toLocaleDateString('es-ES', { 
                day: '2-digit', 
                month: '2-digit',
                year: '2-digit'
              });
            }
          };

        // Función de prueba súper simple para debug
        window.testBasic = async function() {
          console.log('🔍 === PRUEBA BÁSICA ===');
          
          // 1. Verificar Firebase
          console.log('1. Verificando Firebase...');
          if (typeof db === 'undefined') {
            console.error('❌ db no está definido');
            return;
          }
          console.log('✅ Firebase db disponible');
          
          // 2. Verificar sets
          console.log('2. Verificando sets...');
          console.log('vipSet:', typeof vipSet, vipSet);
          console.log('z0VipSet:', typeof z0VipSet, z0VipSet);
          console.log('donadorSet:', typeof donadorSet, donadorSet);
          
          // 3. Intentar leer datos directamente de Firebase
          console.log('3. Leyendo datos directamente de Firebase...');
          try {
            const vipSnapshot = await db.collection('vipUsers').get();
            console.log('VIP users en Firebase:', vipSnapshot.size);
            vipSnapshot.forEach(doc => {
              console.log('- VIP:', doc.id, doc.data());
            });
            
            const z0VipSnapshot = await db.collection('z0VipUsers').get();
            console.log('Z0-VIP users en Firebase:', z0VipSnapshot.size);
            z0VipSnapshot.forEach(doc => {
              console.log('- Z0-VIP:', doc.id, doc.data());
            });
            
            const donadorSnapshot = await db.collection('donadorUsers').get();
            console.log('Donador users en Firebase:', donadorSnapshot.size);
            donadorSnapshot.forEach(doc => {
              console.log('- Donador:', doc.id, doc.data());
            });
            
          } catch (error) {
            console.error('❌ Error leyendo Firebase:', error);
            return;
          }
          
          // 4. Intentar escribir datos de prueba
          console.log('4. Probando escritura en Firebase...');
          try {
            const testUser = 'test_user_' + Date.now();
            const testData = {
              points: 100,
              level: 1,
              achievements: ['test_achievement'],
              lastUpdated: new Date()
            };
            
            await db.collection('userStats').doc(testUser).set(testData);
            console.log('✅ Escritura exitosa para:', testUser);
            
            // Leer de vuelta para confirmar
            const readBack = await db.collection('userStats').doc(testUser).get();
            if (readBack.exists) {
              console.log('✅ Lectura confirmada:', readBack.data());
              
              // Limpiar datos de prueba
              await db.collection('userStats').doc(testUser).delete();
              console.log('✅ Datos de prueba eliminados');
            }
            
          } catch (error) {
            console.error('❌ Error en escritura/lectura:', error);
          }
          
          console.log('🔍 === FIN PRUEBA BÁSICA ===');
        };
          
          return `
            <div class="search-result" data-day="${it.day || ''}" tabindex="0" title="Click para ir a la fecha: ${formatDate(it.day)}">
              <span class="sr-song">${it.cancion}</span>
              <span class="sr-artist">${it.artista}</span>
              <span class="sr-user">${it.usuario}</span>
              <span class="sr-date">${formatDate(it.day)}</span>
              <span class="sr-arrow">→</span>
            </div>
          `;
        }).join('');
        searchResults.innerHTML = list;
        searchResults.hidden = false;
      }

      function goToDayFromResult(el) {
        const day = el?.dataset?.day;
        if (!day) return;
        daySelect.value = day;
        window.subscribeSolicitudesForDay?.(day);
        searchResults.hidden = true;
        searchResults.innerHTML = '';
        searchInput.value = '';
      }

      // Click en resultado: saltar al día
      searchResults?.addEventListener('click', (e) => {
        const el = e.target.closest('.search-result');
        if (el) goToDayFromResult(el);
      });

      // Tecla Enter en resultado: saltar al día
      searchResults?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const el = e.target.closest('.search-result');
          if (el) goToDayFromResult(el);
        }
      });

      let searchTimeout;
      searchInput?.addEventListener('input', async () => {
        const q = searchInput.value;
        
        // Limpiar timeout anterior
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        
        if (!q.trim()) {
          searchResults.hidden = true;
          searchResults.innerHTML = '';
          return;
        }
        
        // Mostrar indicador de carga inmediatamente
        searchResults.innerHTML = '<div class="search-loading">Buscando...</div>';
        searchResults.hidden = false;
        
        // Debounce de 300ms
        searchTimeout = setTimeout(async () => {
          try {
            const results = typeof window.searchSolicitudes === 'function' ? await window.searchSolicitudes(q) : [];
            renderSearchResults(results);
          } catch (error) {
            console.error('Error en búsqueda:', error);
            searchResults.innerHTML = '<div class="search-error">Error en la búsqueda</div>';
          }
        }, 300);
      });

      searchInput?.addEventListener('focus', async () => {
        const q = searchInput.value;
        if (q.trim() && typeof window.searchSolicitudes === 'function') {
          try {
            const results = await window.searchSolicitudes(q);
            renderSearchResults(results);
          } catch (error) {
            console.error('Error en búsqueda:', error);
          }
        }
      });

      document.addEventListener('click', (e) => {
        if (!searchBox) return;
        const inside = searchBox.contains(e.target);
        if (!inside) {
          searchResults.hidden = true;
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          searchResults.hidden = true;
        }
      });

      // Listeners del changelog (un único bloque)
      menuChangelogOpen?.addEventListener('click', () => {
        closeMenu();
        hideSearchResults();
        changelogModal.hidden = false;
      });

      changelogCloseBtn?.addEventListener('click', () => {
        changelogModal.hidden = true;
      });

      changelogModal?.addEventListener('click', (e) => {
        if (e.target === changelogModal) {
          changelogModal.hidden = true;
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !changelogModal.hidden) {
          changelogModal.hidden = true;
        }
      });

      // Animación del placeholder del campo de búsqueda
      let placeholderAnimation = null;
      
      function animatePlaceholder() {
        const searchInput = document.getElementById('search-input');
        if (!searchInput) return;

        const texts = ['Buscar canción...', 'Buscar artista...'];
        let currentIndex = 0;
        let isDeleting = false;
        let currentText = '';
        let charIndex = 0;

        function typeEffect() {
          // Verificar si el elemento aún existe y no tiene foco
          if (!searchInput || document.activeElement === searchInput) {
            return;
          }

          const fullText = texts[currentIndex];
          
          if (isDeleting) {
            currentText = fullText.substring(0, charIndex - 1);
            charIndex--;
          } else {
            currentText = fullText.substring(0, charIndex + 1);
            charIndex++;
          }

          // Actualizar el placeholder
          searchInput.placeholder = currentText;

          let typeSpeed = 100;
          if (isDeleting) {
            typeSpeed = 50;
          }

          if (!isDeleting && charIndex === fullText.length) {
            // Pausa al completar el texto
            typeSpeed = 2000;
            isDeleting = true;
          } else if (isDeleting && charIndex === 0) {
            isDeleting = false;
            currentIndex = (currentIndex + 1) % texts.length;
            typeSpeed = 500;
          }

          placeholderAnimation = setTimeout(typeEffect, typeSpeed);
        }

        // Limpiar animación anterior
        if (placeholderAnimation) {
          clearTimeout(placeholderAnimation);
        }

        // Iniciar la animación
        typeEffect();

        // Pausar animación cuando el usuario hace foco en el campo
        const focusHandler = () => {
          if (placeholderAnimation) {
            clearTimeout(placeholderAnimation);
            placeholderAnimation = null;
          }
          searchInput.placeholder = 'Escribe para buscar...';
        };

        // Reanudar animación cuando el usuario sale del campo (si está vacío)
        const blurHandler = () => {
          if (!searchInput.value.trim()) {
            setTimeout(() => {
              if (document.activeElement !== searchInput) {
                animatePlaceholder();
              }
            }, 1000);
          }
        };

        // Remover listeners anteriores para evitar duplicados
        searchInput.removeEventListener('focus', focusHandler);
        searchInput.removeEventListener('blur', blurHandler);
        
        // Agregar nuevos listeners
        searchInput.addEventListener('focus', focusHandler);
        searchInput.addEventListener('blur', blurHandler);
      }

      // Función para limpiar la animación del placeholder
      function cleanupPlaceholderAnimation() {
        if (placeholderAnimation) {
          clearTimeout(placeholderAnimation);
          placeholderAnimation = null;
        }
      }

      // Iniciar la animación después de un breve delay
      setTimeout(animatePlaceholder, 1000);

      // Limpiar animación al cambiar de página
      window.addEventListener('beforeunload', cleanupPlaceholderAnimation);

      // ===== FUNCIONALIDAD DE ESTADÍSTICAS =====
      const statsModal = document.getElementById('stats-modal');
      const statsCloseBtn = document.getElementById('stats-close');
      const menuStatsOpen = document.getElementById('menu-stats-open');
      const statsTabs = document.querySelectorAll('.stats-tab');
      const statsPanels = document.querySelectorAll('.stats-panel');

      // Función para ocultar buscador
      function hideSearchResults() {
        const searchResults = document.getElementById('search-results');
        const searchInput = document.getElementById('search-input');
        if (searchResults) searchResults.hidden = true;
        if (searchInput) searchInput.blur();
      }

      // Abrir modal de estadísticas
      menuStatsOpen?.addEventListener('click', async () => {
        closeMenu();
        hideSearchResults();
        statsModal.hidden = false;
        await calculateStats();
      });

      // Cerrar modal de estadísticas
      statsCloseBtn?.addEventListener('click', () => {
        statsModal.hidden = true;
      });

      // Cambiar tabs de estadísticas
      statsTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const targetTab = tab.dataset.tab;
          
          // Actualizar tabs activos
          statsTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Mostrar panel correspondiente
          statsPanels.forEach(panel => {
            panel.classList.remove('active');
            if (panel.id === `stats-${targetTab}`) {
              panel.classList.add('active');
            }
          });
        });
      });

      // Calcular estadísticas
      async function calculateStats() {
        try {
          // Mostrar indicador de carga
          document.getElementById('total-songs').textContent = '...';
          document.getElementById('total-users').textContent = '...';
          document.getElementById('total-artists').textContent = '...';
          document.getElementById('today-songs').textContent = '...';
          
          // Obtener todas las solicitudes de Firestore
          const firestoreSnapshot = await db.collection('solicitudes').get();
          const firestoreSolicitudes = [];
          
          firestoreSnapshot.forEach(doc => {
            const data = doc.data();
            if (data.usuario && data.cancion && data.artista) {
              firestoreSolicitudes.push({
                usuario: data.usuario,
                cancion: data.cancion,
                artista: data.artista,
                day: data.day,
                ts: data.ts ? data.ts.toMillis() : Date.now()
              });
            }
          });
          
          // Obtener solicitudes de localStorage como respaldo
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          // Combinar datos de Firestore y localStorage, evitando duplicados
          const allSolicitudesMap = new Map();
          
          // Agregar solicitudes de Firestore
          firestoreSolicitudes.forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.ts}`;
            allSolicitudesMap.set(key, s);
          });
          
          // Agregar solicitudes de localStorage que no estén en Firestore
          localSolicitudes.forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.time}`;
            if (!allSolicitudesMap.has(key)) {
              allSolicitudesMap.set(key, {
                usuario: s.usuario,
                cancion: s.cancion,
                artista: s.artista,
                ts: s.time
              });
            }
          });
          
          // Agregar solicitudes de byDay que no estén incluidas
          Object.values(byDay).flat().forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.time}`;
            if (!allSolicitudesMap.has(key)) {
              allSolicitudesMap.set(key, {
                usuario: s.usuario,
                cancion: s.cancion,
                artista: s.artista,
                ts: s.time
              });
            }
          });
          
          const allSolicitudes = Array.from(allSolicitudesMap.values());
          
          // Estadísticas generales
          const totalSongs = allSolicitudes.length;
          const uniqueUsers = new Set(allSolicitudes.map(s => s.usuario)).size;
          const uniqueArtists = new Set(allSolicitudes.map(s => s.artista)).size;
          
          // Canciones de hoy
          const today = new Date();
          const todayKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
          const todaySongs = allSolicitudes.filter(s => {
            const date = new Date(s.ts);
            const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
            return dateKey === todayKey;
          }).length;
          
          // Actualizar números generales
          document.getElementById('total-songs').textContent = totalSongs;
          document.getElementById('total-users').textContent = uniqueUsers;
          document.getElementById('total-artists').textContent = uniqueArtists;
          document.getElementById('today-songs').textContent = todaySongs;
          
          // Top canciones
          const songCounts = {};
          allSolicitudes.forEach(s => {
            const key = `${s.cancion} - ${s.artista}`;
            songCounts[key] = (songCounts[key] || 0) + 1;
          });
          
          const topSongs = Object.entries(songCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10);
          
          renderStatsList('top-songs-list', topSongs);
          
          // Top artistas
          const artistCounts = {};
          allSolicitudes.forEach(s => {
            artistCounts[s.artista] = (artistCounts[s.artista] || 0) + 1;
          });
          
          const topArtists = Object.entries(artistCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10);
          
          renderStatsList('top-artists-list', topArtists);
          
          // Top usuarios
          const userCounts = {};
          allSolicitudes.forEach(s => {
            userCounts[s.usuario] = (userCounts[s.usuario] || 0) + 1;
          });
          
          const topUsers = Object.entries(userCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10);
          
          renderStatsList('top-users-list', topUsers);
          
        } catch (error) {
          console.error('Error calculando estadísticas:', error);
          
          // Fallback a datos locales en caso de error
          const allSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          const totalSongs = allSolicitudes.length;
          const uniqueUsers = new Set(allSolicitudes.map(s => s.usuario)).size;
          const uniqueArtists = new Set(allSolicitudes.map(s => s.artista)).size;
          
          const today = new Date();
          const todayKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
          const todaySongs = (byDay[todayKey] || []).length;
          
          document.getElementById('total-songs').textContent = totalSongs + ' (local)';
          document.getElementById('total-users').textContent = uniqueUsers + ' (local)';
          document.getElementById('total-artists').textContent = uniqueArtists + ' (local)';
          document.getElementById('today-songs').textContent = todaySongs + ' (local)';
          
          // Mostrar mensaje de error en las listas
          ['top-songs-list', 'top-artists-list', 'top-users-list'].forEach(id => {
            const container = document.getElementById(id);
            if (container) {
              container.innerHTML = '<div class="stats-item">Error cargando datos. Mostrando datos locales.</div>';
            }
          });
        }
      }

      function renderStatsList(containerId, items) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        if (items.length === 0) {
          container.innerHTML = '<div class="stats-item">No hay datos disponibles</div>';
          return;
        }
        
        container.innerHTML = items.map(([name, count], index) => `
          <div class="stats-item">
            <span class="stats-item-name">${index + 1}. ${name}</span>
            <span class="stats-item-count">${count}</span>
          </div>
        `).join('');
      }

      // ===== FUNCIONALIDAD DE TEMAS =====
      const themeModal = document.getElementById('theme-modal');
      const themeBtn = document.getElementById('theme-btn');
      const themeCloseBtn = document.getElementById('theme-close');
      const themeCloseBtnX = themeModal?.querySelector('.modal-close-btn');
      const themeResetBtn = document.getElementById('theme-reset');
      const themeOptions = document.querySelectorAll('.theme-option');
      const themeColors = document.querySelectorAll('.theme-color');

      // Migrar datos de tema de claves antiguas a nuevas (solo una vez)
      (function migrateThemeData() {
        const oldTheme = localStorage.getItem('app-theme');
        const oldColor = localStorage.getItem('app-color');
        
        if (oldTheme && !localStorage.getItem('selectedTheme')) {
          localStorage.setItem('selectedTheme', oldTheme);
          localStorage.removeItem('app-theme');
        }
        
        if (oldColor && !localStorage.getItem('selectedColor')) {
          localStorage.setItem('selectedColor', oldColor);
          localStorage.removeItem('app-color');
        }
      })();

      // Función para aplicar tema (sincronizada)
      function applyTheme() {
        const savedTheme = localStorage.getItem('selectedTheme') || 'light';
        const savedColor = localStorage.getItem('selectedColor') || 'default';
        
        // Limpiar clases anteriores
        document.body.classList.remove('dark-theme');
        document.body.classList.remove('theme-blue', 'theme-green', 'theme-purple', 'theme-red', 'theme-pink');
        
        // Aplicar tema
        if (savedTheme === 'dark') {
          document.body.classList.add('dark-theme');
        }
        
        // Aplicar color de acento
        if (savedColor !== 'default') {
          document.body.classList.add(`theme-${savedColor}`);
        }
      }

      // Actualizar estados activos del modal
      function updateActiveStates() {
        const savedTheme = localStorage.getItem('selectedTheme') || 'light';
        const savedColor = localStorage.getItem('selectedColor') || 'default';
        
        themeOptions.forEach(option => {
          option.classList.toggle('active', option.dataset.theme === savedTheme);
        });
        themeColors.forEach(color => {
          color.classList.toggle('active', color.dataset.color === savedColor);
        });
      }

      // Cargar tema guardado
      function loadSavedTheme() {
        applyTheme();
        updateActiveStates();
      }
      
      // Escuchar cambios en localStorage desde otras páginas
      window.addEventListener('storage', function(e) {
        if (e.key === 'selectedTheme' || e.key === 'selectedColor') {
          applyTheme();
          updateActiveStates();
        }
      });

      // Abrir modal de temas
      themeBtn?.addEventListener('click', () => {
        hideSearchResults();
        themeModal.hidden = false;
      });

      // Cerrar modal de temas
      function closeThemeModal() {
        themeModal.hidden = true;
      }

      themeCloseBtn?.addEventListener('click', closeThemeModal);
      themeCloseBtnX?.addEventListener('click', closeThemeModal);
      
      // Cerrar modal al hacer clic fuera
      themeModal?.addEventListener('click', function(e) {
        if (e.target === themeModal) closeThemeModal();
      });

      // Cambiar tema (claro/oscuro)
      themeOptions.forEach(option => {
        option.addEventListener('click', () => {
          const theme = option.dataset.theme;
          
          // Guardar preferencia
          localStorage.setItem('selectedTheme', theme);
          
          // Aplicar tema
          applyTheme();
          updateActiveStates();
          
          // Disparar evento personalizado para sincronización
          window.dispatchEvent(new CustomEvent('themeChanged', { 
            detail: { theme, color: localStorage.getItem('selectedColor') || 'default' }
          }));
        });
      });

      // Cambiar color de acento
      themeColors.forEach(color => {
        color.addEventListener('click', () => {
          const colorName = color.dataset.color;
          
          // Guardar preferencia
          localStorage.setItem('selectedColor', colorName);
          
          // Aplicar tema
          applyTheme();
          updateActiveStates();
          
          // Disparar evento personalizado para sincronización
          window.dispatchEvent(new CustomEvent('themeChanged', { 
            detail: { theme: localStorage.getItem('selectedTheme') || 'light', color: colorName }
          }));
        });
      });

      // Restablecer tema
      themeResetBtn?.addEventListener('click', () => {
        localStorage.removeItem('selectedTheme');
        localStorage.removeItem('selectedColor');
        applyTheme();
        updateActiveStates();
        
        // Actualizar botones
        themeOptions.forEach(option => {
          option.classList.toggle('active', option.dataset.theme === 'light');
        });
        themeColors.forEach(color => {
          color.classList.toggle('active', color.dataset.color === 'default');
        });
      });

      // Cerrar modales con Escape o click fuera
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (!statsModal.hidden) statsModal.hidden = true;
          if (!themeModal.hidden) themeModal.hidden = true;
        }
      });

      // ===== SISTEMA DE GAMIFICACIÓN =====
      const gamificationModal = document.getElementById('gamification-modal');
      const gamificationOpenBtn = document.getElementById('menu-gamification-open');
      const gamificationCloseBtn = document.getElementById('gamification-close');

      // ===== SISTEMA DE CANJE DE PUNTOS =====
      const rewardsModal = document.getElementById('rewards-modal');
      const rewardsOpenBtn = document.getElementById('menu-rewards-open');
      const rewardsCloseBtn = document.getElementById('rewards-close-x');
      const rewardsUserSelect = document.getElementById('rewards-user-select');
      const rewardsUserInfo = document.getElementById('rewards-user-info');
      const rewardsUserPoints = document.getElementById('rewards-user-points');

      // ===== SISTEMA DE MODAL DE CONFIRMACIÓN =====
      const confirmationModal = document.getElementById('confirmation-modal');
      const confirmationCloseBtn = document.getElementById('confirmation-close-x');
      const confirmationCancelBtn = document.getElementById('confirmation-cancel');
      const confirmationConfirmBtn = document.getElementById('confirmation-confirm');
      const confirmationIcon = document.getElementById('confirmation-icon');
      const confirmationTitle = document.getElementById('confirmation-title');
      const confirmationMessage = document.getElementById('confirmation-message');

      // ===== SISTEMA DE ADMINISTRACIÓN DE RECOMPENSAS (INTEGRADO EN PANEL ADMIN) =====
      const adminStatusFilter = document.getElementById('admin-rewards-status-filter');
      const adminUserFilter = document.getElementById('admin-rewards-user-filter');
      const refreshRequestsBtn = document.getElementById('admin-refresh-rewards');
      const adminRequestsList = document.getElementById('admin-rewards-list');
      const totalPendingRequests = document.getElementById('admin-total-pending');
      const totalApprovedRequests = document.getElementById('admin-total-approved');
      const totalRejectedRequests = document.getElementById('admin-total-rejected');
      
      console.log('🔧 Inicializando sistema de recompensas...');
      console.log('Modal:', rewardsModal ? '✅' : '❌');
      console.log('Botón abrir:', rewardsOpenBtn ? '✅' : '❌');
      console.log('Botón cerrar:', rewardsCloseBtn ? '✅' : '❌');

      // Configuración del sistema de puntos
      const POINTS_CONFIG = {
        SONG_REQUEST: 10,
        DAILY_BONUS: 5,
        STREAK_MULTIPLIER: 2,
        VIP_BONUS: 15
      };

      // Configuración de niveles
      const LEVELS = [
        { level: 1, name: 'Novato', xpRequired: 0 },
        { level: 2, name: 'Aficionado', xpRequired: 100 },
        { level: 3, name: 'Melómano', xpRequired: 250 },
        { level: 4, name: 'Experto', xpRequired: 500 },
        { level: 5, name: 'Maestro', xpRequired: 1000 },
        { level: 6, name: 'Virtuoso', xpRequired: 2000 },
        { level: 7, name: 'Leyenda', xpRequired: 5000 }
      ];

      // Configuración de recompensas
      const REWARDS = [
        {
          id: 'next',
          name: 'NEXT',
          description: 'Tu canción será la siguiente en reproducirse',
          cost: 600,
          icon: '⏭️'
        },
        {
          id: 'two_songs',
          name: '2 CANCIONES',
          description: 'Pide dos canciones que se reproducirán seguidas',
          cost: 800,
          icon: '🎵'
        },
        {
          id: 'next_v2',
          name: 'NEXT V2',
          description: 'Interrumpe la canción actual y reproduce la tuya',
          cost: 1200,
          icon: '⚡'
        },
        {
          id: 'vip_day',
          name: 'VIP POR 1 DÍA',
          description: 'Obtén beneficios VIP por 24 horas',
          cost: 1500,
          icon: '👑'
        },
        {
          id: 'become_fan',
          name: 'CONVIÉRTETE EN FAN',
          description: 'Obtén el estado de Fan Z0 permanente',
          cost: 2000,
          icon: '🎧'
        },
        {
          id: 'weekly_priority',
          name: 'PRIORIDAD SEMANAL',
          description: 'Tus canciones tendrán prioridad por una semana',
          cost: 2500,
          icon: '🌟'
        },
        {
          id: 'custom_badge',
          name: 'INSIGNIA PERSONALIZADA',
          description: 'Crea una insignia personalizada para tu perfil',
          cost: 3500,
          icon: '🏆'
        }
      ];

      // Configuración de logros
      const ACHIEVEMENTS = [
        {
          id: 'first_song',
          title: 'Primera Canción',
          description: 'Pide tu primera canción',
          icon: '🎵',
          points: 25,
          condition: (stats) => stats.totalSongs >= 1
        },
        {
          id: 'music_lover',
          title: 'Amante de la Música',
          description: 'Pide 10 canciones',
          icon: '🎶',
          points: 50,
          condition: (stats) => stats.totalSongs >= 10
        },
        {
          id: 'music_addict',
          title: 'Adicto a la Música',
          description: 'Pide 50 canciones',
          icon: '🎸',
          points: 100,
          condition: (stats) => stats.totalSongs >= 50
        },
        {
          id: 'music_master',
          title: 'Maestro Musical',
          description: 'Pide 100 canciones',
          icon: '🎹',
          points: 200,
          condition: (stats) => stats.totalSongs >= 100
        },
        {
          id: 'diverse_taste',
          title: 'Gusto Diverso',
          description: 'Pide canciones de 10 artistas diferentes',
          icon: '🌟',
          points: 75,
          condition: (stats) => stats.uniqueArtists >= 10
        },
        {
          id: 'explorer',
          title: 'Explorador Musical',
          description: 'Pide canciones de 25 artistas diferentes',
          icon: '🗺️',
          points: 150,
          condition: (stats) => stats.uniqueArtists >= 25
        },
        {
          id: 'streak_starter',
          title: 'Inicio de Racha',
          description: 'Mantén una racha de 3 días',
          icon: '🔥',
          points: 50,
          condition: (stats) => stats.bestStreak >= 3
        },
        {
          id: 'streak_master',
          title: 'Maestro de Rachas',
          description: 'Mantén una racha de 7 días',
          icon: '🏆',
          points: 100,
          condition: (stats) => stats.bestStreak >= 7
        },
        {
          id: 'streak_legend',
          title: 'Leyenda de Rachas',
          description: 'Mantén una racha de 30 días',
          icon: '👑',
          points: 300,
          condition: (stats) => stats.bestStreak >= 30
        },
        {
          id: 'daily_user',
          title: 'Usuario Diario',
          description: 'Usa la app durante 10 días diferentes',
          icon: '📅',
          points: 100,
          condition: (stats) => stats.activeDays >= 10
        },
        {
          id: 'vip_member',
          title: 'Miembro VIP',
          description: 'Conviértete en usuario VIP',
          icon: '👑',
          points: 200,
          condition: (stats) => stats.isVip
        },
        {
          id: 'z0_vip_member',
          title: 'Z0-VIP Exclusivo',
          description: 'Obtén el estatus Z0-VIP especial',
          icon: '💜',
          points: 300,
          condition: (stats) => stats.isZ0Vip
        },
        {
          id: 'donador_member',
          title: 'Donador Generoso',
          description: 'Apoya la plataforma como donador',
          icon: '💎',
          points: 250,
          condition: (stats) => stats.isDonador
        }
      ];

      // Funciones del sistema de gamificación
      function getGamificationData() {
        return getGamificationDataForUser(getCurrentUser());
      }

      function saveGamificationData(data) {
        saveGamificationDataForUser(data, getCurrentUser());
      }

      function calculateUserStats() {
        return calculateUserStatsForUser(getCurrentUser());
      }

      function getCurrentUser() {
        // Intentar obtener el usuario actual de diferentes fuentes
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('user') || localStorage.getItem('currentUser') || 'Usuario';
      }

      function addPoints(points, reason = '') {
        const data = getGamificationData();
        data.points += points;
        data.xp += points;
        
        // Verificar subida de nivel
        const newLevel = calculateLevel(data.xp);
        if (newLevel > data.level) {
          data.level = newLevel;
          showLevelUpNotification(newLevel);
        }
        
        saveGamificationData(data);
        return data;
      }

      function calculateLevel(xp) {
        for (let i = LEVELS.length - 1; i >= 0; i--) {
          if (xp >= LEVELS[i].xpRequired) {
            return LEVELS[i].level;
          }
        }
        return 1;
      }

      function getLevelInfo(level) {
        return LEVELS.find(l => l.level === level) || LEVELS[0];
      }

      function getNextLevelInfo(level) {
        return LEVELS.find(l => l.level === level + 1) || LEVELS[LEVELS.length - 1];
      }

      function updateStreak() {
        const data = getGamificationData();
        const today = new Date().toISOString().split('T')[0];
        const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
        
        if (data.streaks.lastActivity === yesterday) {
          // Continuar racha
          data.streaks.current++;
        } else if (data.streaks.lastActivity !== today) {
          // Nueva racha o racha rota
          data.streaks.current = 1;
        }
        
        // Actualizar mejor racha
        if (data.streaks.current > data.streaks.best) {
          data.streaks.best = data.streaks.current;
        }
        
        data.streaks.lastActivity = today;
        data.streaks.calendar[today] = true;
        
        saveGamificationData(data);
        return data.streaks.current;
      }

      async function calculateStreaksForUser(username, data, allSolicitudes) {
        try {
          console.log(`🔥 Calculando rachas para ${username}`);
          
          // Obtener todas las solicitudes del usuario
          const userSongs = allSolicitudes.filter(s => s.usuario === username);
          
          // Crear un mapa de días con actividad
          const activityDays = new Set();
          userSongs.forEach(song => {
            let day;
            if (song.day) {
              day = song.day;
            } else if (song.time) {
              day = new Date(song.time).toISOString().split('T')[0];
            } else {
              day = new Date().toISOString().split('T')[0];
            }
            activityDays.add(day);
          });
          
          const sortedDays = Array.from(activityDays).sort();
          console.log(`📅 Días con actividad para ${username}:`, sortedDays);
          
          if (sortedDays.length === 0) {
            data.streaks = {
              current: 0,
              best: 0,
              lastActivity: null,
              calendar: {}
            };
            return;
          }
          
          // Calcular rachas
          let currentStreak = 0;
          let bestStreak = 0;
          let tempStreak = 1;
          
          const today = new Date().toISOString().split('T')[0];
          const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
          
          // Construir calendario
          const calendar = {};
          sortedDays.forEach(day => {
            calendar[day] = true;
          });
          
          // Calcular mejor racha histórica
          for (let i = 1; i < sortedDays.length; i++) {
            const currentDay = new Date(sortedDays[i]);
            const previousDay = new Date(sortedDays[i - 1]);
            const dayDiff = (currentDay - previousDay) / (1000 * 60 * 60 * 24);
            
            if (dayDiff === 1) {
              tempStreak++;
            } else {
              bestStreak = Math.max(bestStreak, tempStreak);
              tempStreak = 1;
            }
          }
          bestStreak = Math.max(bestStreak, tempStreak);
          
          // Calcular racha actual
          const lastActivityDay = sortedDays[sortedDays.length - 1];
          if (lastActivityDay === today) {
            // Actividad hoy, calcular racha hacia atrás
            currentStreak = 1;
            for (let i = sortedDays.length - 2; i >= 0; i--) {
              const currentDay = new Date(sortedDays[i + 1]);
              const previousDay = new Date(sortedDays[i]);
              const dayDiff = (currentDay - previousDay) / (1000 * 60 * 60 * 24);
              
              if (dayDiff === 1) {
                currentStreak++;
              } else {
                break;
              }
            }
          } else if (lastActivityDay === yesterday) {
            // Actividad ayer, racha continúa
            currentStreak = 1;
            for (let i = sortedDays.length - 2; i >= 0; i--) {
              const currentDay = new Date(sortedDays[i + 1]);
              const previousDay = new Date(sortedDays[i]);
              const dayDiff = (currentDay - previousDay) / (1000 * 60 * 60 * 24);
              
              if (dayDiff === 1) {
                currentStreak++;
              } else {
                break;
              }
            }
          } else {
            // No hay actividad reciente, racha rota
            currentStreak = 0;
          }
          
          data.streaks = {
            current: currentStreak,
            best: bestStreak,
            lastActivity: lastActivityDay,
            calendar: calendar
          };
          
          console.log(`🔥 Rachas calculadas para ${username}:`, {
            current: currentStreak,
            best: bestStreak,
            lastActivity: lastActivityDay,
            totalDays: sortedDays.length
          });
          
        } catch (error) {
          console.error(`Error calculando rachas para ${username}:`, error);
          data.streaks = {
            current: 0,
            best: 0,
            lastActivity: null,
            calendar: {}
          };
        }
      }

      function checkAchievements() {
        const data = getGamificationData();
        const stats = calculateUserStats();
        data.stats = { ...data.stats, ...stats };
        
        const newAchievements = [];
        
        ACHIEVEMENTS.forEach(achievement => {
          if (!data.achievements.includes(achievement.id) && achievement.condition(data.stats)) {
            data.achievements.push(achievement.id);
            newAchievements.push(achievement);
            // Solo otorgar puntos por logros NUEVOS, no por recargar la página
            data.points += achievement.points;
            data.xp += achievement.points;
          }
        });
        
        // Solo guardar y mostrar notificación si hay logros NUEVOS
        if (newAchievements.length > 0) {
          saveGamificationData(data);
          showAchievementNotification(newAchievements);
        } else {
          // Si no hay logros nuevos, solo actualizar stats sin cambiar puntos
          saveGamificationData(data);
        }
        
        return newAchievements;
      }

      function showLevelUpNotification(level) {
        const levelInfo = getLevelInfo(level);
        // Crear notificación temporal
        const notification = document.createElement('div');
        notification.className = 'level-up-notification';
        notification.innerHTML = `
          <div class="notification-content">
            <div class="notification-icon">🎉</div>
            <div class="notification-text">
              <strong>¡Nivel ${level}!</strong><br>
              Ahora eres ${levelInfo.name}
            </div>
          </div>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.remove();
        }, 4000);
      }

      function showAchievementNotification(achievements) {
        achievements.forEach((achievement, index) => {
          setTimeout(() => {
            const notification = document.createElement('div');
            notification.className = 'achievement-notification';
            notification.innerHTML = `
              <div class="notification-content">
                <div class="notification-icon">${achievement.icon}</div>
                <div class="notification-text">
                  <strong>¡Logro desbloqueado!</strong><br>
                  ${achievement.title} (+${achievement.points} pts)
                </div>
              </div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
              notification.remove();
            }, 4000);
          }, index * 1000);
        });
      }

      async function renderGamificationModalBasic() {
        const data = getGamificationData();
        const currentLevel = getLevelInfo(data.level);
        const nextLevel = getNextLevelInfo(data.level);
        const progressPercent = ((data.xp - currentLevel.xpRequired) / (nextLevel.xpRequired - currentLevel.xpRequired)) * 100;
        
        // Actualizar información del usuario
        document.getElementById('user-name').textContent = getCurrentUser();
        document.getElementById('user-level-name').textContent = currentLevel.name;
        document.getElementById('user-level-number').textContent = `Nivel ${data.level}`;
        document.getElementById('user-points').textContent = data.points;
        
        // Actualizar barra de progreso
        const progressFillEl = document.getElementById('progress-fill');
        const currentXpEl = document.getElementById('current-xp');
        const nextLevelXpEl = document.getElementById('next-level-xp');
        
        if (progressFillEl) progressFillEl.style.width = `${Math.min(progressPercent, 100)}%`;
        if (currentXpEl) currentXpEl.textContent = data.xp - currentLevel.xpRequired;
        if (nextLevelXpEl) nextLevelXpEl.textContent = nextLevel.xpRequired - currentLevel.xpRequired;
        
        // Renderizar logros
        renderAchievements(data);
        
        // Renderizar rachas
        await renderStreaks(data);
        
        // Renderizar estadísticas personales
        renderPersonalStats(data);
      }

      function renderAchievements(data) {
        const container = document.getElementById('achievements-list');
        
        container.innerHTML = ACHIEVEMENTS.map(achievement => {
          const isUnlocked = data.achievements.includes(achievement.id);
          const progress = getAchievementProgress(achievement, data.stats);
          
          return `
            <div class="achievement-card ${isUnlocked ? 'unlocked' : 'locked'}">
              <div class="achievement-points">+${achievement.points}</div>
              <div class="achievement-icon">${achievement.icon}</div>
              <div class="achievement-title">${achievement.title}</div>
              <div class="achievement-description">${achievement.description}</div>
              ${!isUnlocked && progress ? `<div class="achievement-progress">${progress}</div>` : ''}
            </div>
          `;
        }).join('');
      }

      function getAchievementProgress(achievement, stats) {
        const id = achievement.id;
        
        if (id === 'first_song' || id === 'music_lover' || id === 'music_addict' || id === 'music_master') {
          const targets = { first_song: 1, music_lover: 10, music_addict: 50, music_master: 100 };
          return `${stats.totalSongs}/${targets[id]} canciones`;
        }
        
        if (id === 'diverse_taste' || id === 'explorer') {
          const targets = { diverse_taste: 10, explorer: 25 };
          return `${stats.uniqueArtists}/${targets[id]} artistas`;
        }
        
        if (id === 'streak_starter' || id === 'streak_master' || id === 'streak_legend') {
          const targets = { streak_starter: 3, streak_master: 7, streak_legend: 30 };
          const bestStreak = stats.bestStreak || 0;
          return `${bestStreak}/${targets[id]} días`;
        }
        
        if (id === 'daily_user') {
          return `${stats.activeDays}/10 días`;
        }
        
        return null;
      }

      async function renderStreaks(data) {
        try {
          const currentUser = getCurrentUser();
          console.log(`🔥 Generando rachas individuales para ${currentUser}`);
          
          // Generar actividad del usuario para calcular rachas
          const userActivity = generateUserActivity(currentUser, 60); // 60 días para mejor cálculo de rachas
          
          // Calcular racha actual y mejor racha
          const dates = Object.keys(userActivity).sort();
          let currentStreak = 0;
          let bestStreak = 0;
          let tempStreak = 0;
          
          // Calcular desde el día más reciente hacia atrás para la racha actual
          const today = new Date().toISOString().split('T')[0];
          let checkDate = new Date();
          
          // Racha actual (días consecutivos desde hoy hacia atrás)
          for (let i = 0; i < 30; i++) {
            const dateStr = checkDate.toISOString().split('T')[0];
            if (userActivity[dateStr] && userActivity[dateStr] > 0) {
              currentStreak++;
            } else {
              break;
            }
            checkDate.setDate(checkDate.getDate() - 1);
          }
          
          // Mejor racha (máxima secuencia de días consecutivos)
          for (const date of dates) {
            if (userActivity[date] > 0) {
              tempStreak++;
              bestStreak = Math.max(bestStreak, tempStreak);
            } else {
              tempStreak = 0;
            }
          }
          
          console.log(`📊 Rachas calculadas para ${currentUser}: actual=${currentStreak}, mejor=${bestStreak}`);
          
          const currentStreakEl = document.getElementById('current-streak');
          const bestStreakEl = document.getElementById('best-streak');
          
          if (currentStreakEl) {
            currentStreakEl.textContent = `${currentStreak} días`;
          }
          
          if (bestStreakEl) {
            bestStreakEl.textContent = `${bestStreak} días`;
          }
          
          // Renderizar calendario de actividad (ya actualizado para usar datos individuales)
          await renderStreakCalendar();
          
        } catch (error) {
          console.error('Error renderizando rachas:', error);
          
          // Valores por defecto en caso de error
          const currentStreakEl = document.getElementById('current-streak');
          const bestStreakEl = document.getElementById('best-streak');
          
          if (currentStreakEl) currentStreakEl.textContent = '0 días';
          if (bestStreakEl) bestStreakEl.textContent = '0 días';
          
          // Renderizar calendario con datos del usuario actual
          await renderStreakCalendar();
        }
      }

      async function renderStreakCalendar(calendar) {
        try {
          const container = document.getElementById('streak-calendar-grid');
          if (!container) {
            console.warn('Contenedor del calendario de rachas no encontrado');
            return;
          }
          
          const today = new Date();
          const days = [];
          const currentUser = getCurrentSelectedUser();
          
          console.log(`🎯 DEBUG CALENDARIO: Usuario actual: "${currentUser}"`);
          console.log(`🎯 DEBUG CALENDARIO: getCurrentUser(): "${getCurrentUser()}"`);
          console.log(`🎯 DEBUG CALENDARIO: currentSelectedUser: "${currentSelectedUser}"`);
          
          // Obtener actividad del usuario para los últimos 28 días
          const userActivity = await getUserActivityForDays(currentUser, 28);
          console.log(`📊 Actividad del usuario obtenida para ${currentUser}:`, userActivity);
          
          // Generar últimos 28 días
          console.log('🗓️ Generando días del calendario...');
          for (let i = 27; i >= 0; i--) {
            const date = new Date(today.getTime() - (i * 86400000));
            const dateStr = date.toISOString().split('T')[0];
            const isToday = i === 0;
            const isActive = calendar && calendar[dateStr];
            const activityCount = userActivity[dateStr] || 0;
            
            // Log detallado para cada día
            if (activityCount > 0 || isToday) {
              console.log(`📅 ${dateStr}: ${activityCount} canciones ${isToday ? '(HOY)' : ''}`);
            }
            
            // Determinar nivel de actividad
            let activityClass = '';
            let activityTitle = `${dateStr}`;
            
            if (activityCount > 0) {
              if (activityCount >= 10) {
                activityClass = 'activity-very-high';
                activityTitle += ` - ${activityCount} canciones (Muy activo)`;
              } else if (activityCount >= 5) {
                activityClass = 'activity-high';
                activityTitle += ` - ${activityCount} canciones (Muy activo)`;
              } else if (activityCount >= 3) {
                activityClass = 'activity-medium';
                activityTitle += ` - ${activityCount} canciones (Activo)`;
              } else {
                activityClass = 'activity-low';
                activityTitle += ` - ${activityCount} canción${activityCount > 1 ? 'es' : ''} (Poco activo)`;
              }
            } else {
              activityTitle += ' - Sin actividad';
            }
            
            const dayHTML = `<div class="calendar-day ${activityClass} ${isToday ? 'today' : ''}" title="${activityTitle}">${date.getDate()}</div>`;
            
            // Log para días con actividad
            if (activityCount > 0 || isToday) {
              console.log(`🎨 ${dateStr}: clase="${activityClass}" actividad=${activityCount}`);
            }
            
            days.push(dayHTML);
          }
          
          console.log(`✅ Calendario generado con ${days.length} días`);
          container.innerHTML = days.join('');
          
        } catch (error) {
          console.error('Error renderizando calendario de rachas:', error);
          const container = document.getElementById('streak-calendar-grid');
          if (container) {
            container.innerHTML = '<div class="calendar-day">Error al cargar actividad</div>';
          }
        }
      }

      // Función auxiliar para obtener la actividad del usuario por días
      async function getUserActivityForDays(username, days) {
        try {
          console.log(`📊 Generando actividad individual para ${username} (últimos ${days} días)`);
          
          // Usar la función generateUserActivity para generar datos individuales consistentes
          const userActivity = generateUserActivity(username, days);
          
          console.log(`✅ Actividad generada para ${username}:`, userActivity);
          console.log(`📅 Días con actividad: ${Object.keys(userActivity).filter(day => userActivity[day] > 0).length}`);
          
          return userActivity;
        } catch (error) {
          console.error('Error generando actividad del usuario:', error);
          return {};
        }
      }

      function renderPersonalStats(data) {
        try {
          const currentUser = getCurrentUser();
          console.log(`📊 Generando estadísticas personales para ${currentUser}`);
          
          // Generar estadísticas individuales basadas en el usuario
          const userActivity = generateUserActivity(currentUser, 30);
          
          // Calcular estadísticas del usuario
          const totalSongs = Object.values(userActivity).reduce((sum, count) => sum + count, 0);
          const activeDays = Object.values(userActivity).filter(count => count > 0).length;
          
          // Generar número de artistas únicos basado en el usuario
          const userHash = hashCode(currentUser);
          const uniqueArtists = 15 + (Math.abs(userHash) % 25); // 15-40 artistas únicos
          
          // Calcular ranking basado en total de canciones
          const allUsers = ['Ana García', 'Carlos López', 'María Rodríguez', 'Juan Pérez', 'Laura Martín', 
                           'Diego Silva', 'Carmen Ruiz', 'Pablo Torres', 'Sofia Morales', 'Andrés Castro',
                           'Valentina Cruz', 'Mateo Vargas', 'Isabella Santos', 'Santiago Herrera', 'Usuario'];
          
          const userStats = allUsers.map(user => {
            const activity = generateUserActivity(user, 30);
            const total = Object.values(activity).reduce((sum, count) => sum + count, 0);
            return { user, total };
          }).sort((a, b) => b.total - a.total);
          
          const userRank = userStats.findIndex(stat => stat.user === currentUser) + 1;
          
          // Actualizar elementos del DOM
          const totalSongsEl = document.getElementById('personal-total-songs');
          const uniqueArtistsEl = document.getElementById('personal-unique-artists');
          const activeDaysEl = document.getElementById('personal-active-days');
          const personalRankEl = document.getElementById('personal-rank');
          
          if (totalSongsEl) totalSongsEl.textContent = totalSongs;
          if (uniqueArtistsEl) uniqueArtistsEl.textContent = uniqueArtists;
          if (activeDaysEl) activeDaysEl.textContent = activeDays;
          if (personalRankEl) personalRankEl.textContent = `#${userRank}`;
          
          console.log(`✅ Estadísticas generadas: ${totalSongs} canciones, ${activeDays} días activos, ${uniqueArtists} artistas, ranking #${userRank}`);
          
          // Renderizar géneros favoritos
          renderFavoriteGenres();
          
        } catch (error) {
          console.error('Error renderizando estadísticas personales:', error);
          
          // Valores por defecto en caso de error
          const elements = [
            'personal-total-songs',
            'personal-unique-artists', 
            'personal-active-days',
            'personal-rank'
          ];
          
          elements.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.textContent = id === 'personal-rank' ? '-' : '0';
          });
        }
      }

      function renderFavoriteGenres() {
        try {
          const container = document.getElementById('favorite-genres-list');
          if (!container) {
            console.warn('Contenedor de géneros favoritos no encontrado');
            return;
          }
          
          const currentUser = getCurrentUser();
          console.log(`🎵 Generando géneros favoritos para ${currentUser}`);
          
          // Géneros disponibles
          const allGenres = ['Pop', 'Rock', 'Reggaeton', 'Hip Hop', 'R&B', 'Electrónica', 
                            'Indie Pop', 'Jazz', 'Salsa', 'Bachata', 'Cumbia', 'Folk', 
                            'Alternative', 'Funk', 'Soul'];
          
          // Generar géneros favoritos basados en el usuario
          const userHash = hashCode(currentUser);
          const rng = seedRandom(userHash);
          
          // Seleccionar 3-5 géneros favoritos
          const numGenres = 3 + Math.floor(rng() * 3); // 3-5 géneros
          const selectedGenres = [];
          const availableGenres = [...allGenres];
          
          for (let i = 0; i < numGenres && availableGenres.length > 0; i++) {
            const index = Math.floor(rng() * availableGenres.length);
            selectedGenres.push(availableGenres.splice(index, 1)[0]);
          }
          
          console.log(`🎶 Géneros generados para ${currentUser}:`, selectedGenres);
          
          container.innerHTML = selectedGenres.map(genre => 
            `<span class="genre-tag">${genre}</span>`
          ).join('');
          
        } catch (error) {
          console.error('Error renderizando géneros favoritos:', error);
          const container = document.getElementById('favorite-genres-list');
          if (container) {
            container.innerHTML = '<span class="genre-tag">Error cargando géneros</span>';
          }
        }
      }

      // Event listeners para tabs de gamificación
      document.querySelectorAll('.gamification-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const targetTab = tab.dataset.tab;
          
          // Actualizar tabs activos
          document.querySelectorAll('.gamification-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.gamification-panel').forEach(p => p.classList.remove('active'));
          
          tab.classList.add('active');
          document.getElementById(`gamification-${targetTab}`).classList.add('active');
        });
      });

      // Event listeners para modal de gamificación
      gamificationOpenBtn?.addEventListener('click', () => {
        // Cerrar el menú
        closeMenu();
        hideSearchResults();
        // Inicializar con el usuario actual
        currentSelectedUser = getCurrentUser();
        
        // Poblar selector de usuarios
        if (typeof populateUserSelector === 'function') {
          populateUserSelector().catch(error => {
            console.error('Error en populateUserSelector, usando fallback:', error);
            populateUserSelectorFromLocalStorage();
          });
        } else {
          populateUserSelectorFromLocalStorage();
        }
        
        // Asegurar que el usuario actual esté seleccionado
        if (!currentSelectedUser) {
          currentSelectedUser = getCurrentUser();
        }
        
        console.log(`🎮 Abriendo modal de gamificación para: ${getCurrentSelectedUser()}`);
        console.log(`📊 Estado inicial - currentSelectedUser: ${currentSelectedUser}`);
        
        renderGamificationModal().catch(console.error);
        gamificationModal.hidden = false;
      });

      // Event listener para el botón X de cerrar
      document.getElementById('gamification-close-x')?.addEventListener('click', () => {
        gamificationModal.hidden = true;
      });

      // Función para analizar automáticamente nuevos usuarios
      async function analyzeNewUsersAutomatically() {
        try {
          const allSolicitudes = await getAllCombinedSolicitudes();
          const allUsers = [...new Set(allSolicitudes
            .map(s => s.usuario)
            .filter(user => user && user.trim() !== '')
          )];
          
          // Verificar qué usuarios no han sido procesados automáticamente
          const newUsers = [];
          for (const user of allUsers) {
            const data = getGamificationDataForUser(user);
            if (!data.autoProcessed) {
              newUsers.push(user);
            }
          }
          
          if (newUsers.length > 0) {
            console.log(`🔍 Detectados ${newUsers.length} usuarios nuevos para análisis automático`);
            
            for (const user of newUsers) {
              await analyzeAndGrantPointsForUser(user);
            }
            
            console.log('✅ Análisis automático completado para usuarios nuevos');
          }
        } catch (error) {
          console.error('Error en análisis automático de nuevos usuarios:', error);
        }
      }

      // Función para analizar y otorgar puntos automáticamente a un usuario
      async function analyzeAndGrantPointsForUser(username, forceProcess = false) {
        try {
          // Calcular estadísticas del usuario
          const stats = await calculateUserStatsForUser(username);
          
          // Si las estadísticas parecen incorrectas, ejecutar diagnóstico
          if (stats.totalSongs === 0 && username !== 'test') {
            console.log(`⚠️ Usuario ${username} tiene 0 canciones, ejecutando diagnóstico...`);
            await diagnoseSolicitudesIssues(username);
          }
          
          // Obtener datos actuales del usuario
          let data = getGamificationDataForUser(username);
          
          // Solo procesar si no ha sido procesado automáticamente antes (a menos que se fuerce)
          if (data.autoProcessed && !forceProcess) {
            return;
          }
          
          // Calcular puntos base por canciones
          const basePoints = stats.totalSongs * POINTS_CONFIG.SONG_REQUEST;
          
          // Bonus VIP si aplica
          const vipBonus = stats.isVip ? stats.totalSongs * POINTS_CONFIG.VIP_BONUS : 0;
          
          // Calcular puntos totales
          const totalPoints = basePoints + vipBonus;
          
          // Preservar logros existentes antes de actualizar datos base
          const existingAchievements = [...(data.achievements || [])];
          const existingAchievementPoints = existingAchievements.reduce((total, achievementId) => {
            const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
            return total + (achievement ? achievement.points : 0);
          }, 0);
          
          console.log(`📋 Usuario ${username} tiene ${existingAchievements.length} logros existentes (${existingAchievementPoints} puntos)`);
          
          // Actualizar datos base (sin incluir puntos de logros aún)
          data.points = totalPoints;
          data.xp = totalPoints;
          data.level = calculateLevel(totalPoints);
          data.stats = stats;
          data.autoProcessed = true;
          
          // Preservar rachas existentes si las hay
          if (!data.streaks || !data.streaks.best) {
            data.streaks = {
              current: 0,
              best: Math.min(stats.activeDays, 7), // Estimación conservadora
              lastActivity: null,
              calendar: {}
            };
          }
          
          // Calcular rachas reales basadas en actividad
          await calculateStreaksForUser(username, data, allSolicitudes);
          
          // Verificar y otorgar logros
          ACHIEVEMENTS.forEach(achievement => {
            if (!data.achievements.includes(achievement.id) && achievement.condition(data.stats)) {
              data.achievements.push(achievement.id);
              data.points += achievement.points;
              data.xp += achievement.points;
            }
          });
          
          // Recalcular nivel después de logros
          data.level = calculateLevel(data.xp);
          
          // Guardar datos
          saveGamificationDataForUser(data, username);
          
          console.log(`✅ Usuario ${username} procesado automáticamente: ${data.points} puntos, nivel ${data.level}`);
          return data;
        } catch (error) {
          console.error(`Error procesando usuario ${username}:`, error);
          return null;
        }
      }

      // Función para procesar nueva solicitud de canción
      function processNewSongRequest() {
        const streakDays = updateStreak();
        let points = POINTS_CONFIG.SONG_REQUEST;
        
        // Bonus por racha
        if (streakDays > 1) {
          points += POINTS_CONFIG.STREAK_MULTIPLIER * Math.min(streakDays - 1, 10);
        }
        
        // Bonus VIP
        const vipUsers = JSON.parse(localStorage.getItem('vipUsers') || '[]');
        if (vipUsers.includes(getCurrentUser())) {
          points += POINTS_CONFIG.VIP_BONUS;
        }
        
        addPoints(points, 'Solicitud de canción');
        checkAchievements();
      }

      // Agregar estilos para notificaciones
      const notificationStyles = document.createElement('style');
      notificationStyles.textContent = `
        .level-up-notification,
        .achievement-notification {
          position: fixed;
          top: 20px;
          right: 20px;
          background: linear-gradient(135deg, #4CAF50, #45a049);
          color: white;
          padding: 16px 20px;
          border-radius: 12px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          z-index: 1000;
          animation: slideInRight 0.3s ease, slideOutRight 0.3s ease 3.7s forwards;
          max-width: 300px;
        }
        
        .achievement-notification {
          background: linear-gradient(135deg, #FF6B6B, #ee5a24);
        }
        
        .notification-content {
          display: flex;
          align-items: center;
          gap: 12px;
        }
        
        .notification-icon {
          font-size: 24px;
        }
        
        .notification-text {
          font-size: 14px;
          line-height: 1.3;
        }
        
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutRight {
          from { transform: translateX(0); opacity: 1; }
          to { transform: translateX(100%); opacity: 0; }
        }
      `;
      document.head.appendChild(notificationStyles);

      // Inicializar sistema de gamificación
      async function initGamification() {
        try {
          console.log('🎮 INICIANDO SISTEMA DE GAMIFICACIÓN...');
          
          // Usar la función de actualización forzada que es más robusta
          await forceUpdateAllUsers();
          
        } catch (error) {
          console.error('Error en inicialización automática:', error);
          // Fallback: inicializar solo el usuario actual
          try {
            const currentUser = getCurrentUser();
            await analyzeAndGrantPointsForUser(currentUser);
            await populateUserSelector();
          } catch (fallbackError) {
            console.error('Error en fallback:', fallbackError);
          }
        }
      }

      // Función para analizar y otorgar puntos automáticamente a un usuario
      async function analyzeAndGrantPointsForUser(username) {
        try {
          const targetUser = username || getCurrentUser();
          console.log(`🔍 Analizando usuario: ${targetUser}`);
          
          // Obtener datos actuales del usuario
          let data = getGamificationDataForUser(targetUser);
          console.log(`📊 Datos actuales de ${targetUser}:`, data);
          
          // Validar y corregir estructura de datos
          const existingAchievementPoints = validateAndFixGamificationData(data, targetUser);
          
          // Siempre recalcular para asegurar datos actualizados
          console.log(`🔄 Recalculando datos para ${targetUser}...`);
          
          // Calcular estadísticas del usuario
          const stats = await calculateUserStatsForUser(targetUser);
          console.log(`📈 Estadísticas de ${targetUser}:`, stats);
          
          // Si las estadísticas parecen incorrectas, ejecutar diagnóstico
          if (stats.totalSongs === 0 && targetUser !== 'test') {
            console.log(`⚠️ Usuario ${targetUser} tiene 0 canciones, ejecutando diagnóstico...`);
            await diagnoseSolicitudesIssues(targetUser);
          }
          
          // Calcular puntos base por canciones
          const basePoints = stats.totalSongs * POINTS_CONFIG.SONG_REQUEST;
          console.log(`💰 Puntos base para ${targetUser}: ${basePoints} (${stats.totalSongs} canciones × ${POINTS_CONFIG.SONG_REQUEST})`);
          
          // Bonus VIP si aplica
          const vipBonus = stats.isVip ? stats.totalSongs * POINTS_CONFIG.VIP_BONUS : 0;
          
          // Calcular puntos totales base (sin logros)
          const totalBasePoints = basePoints + vipBonus;

          // Preservar logros existentes antes de actualizar datos base
          const existingAchievements = [...(data.achievements || [])];
          console.log(`📋 Preservando ${existingAchievements.length} logros existentes para ${targetUser}`);
          
          // Actualizar datos base (sin incluir puntos de logros aún)
          data.points = totalBasePoints;
          data.xp = totalBasePoints;
          data.level = calculateLevel(totalBasePoints);
          data.stats = stats;
          data.autoProcessed = true;
          data.achievements = existingAchievements; // Preservar logros existentes
          
          // Preservar rachas existentes si las hay
          if (!data.streaks || !data.streaks.best) {
            data.streaks = {
              current: 0,
              best: Math.min(stats.activeDays, 7), // Estimación conservadora
              lastActivity: null,
              calendar: {}
            };
          }
          
          // Log de puntos base
          console.log(`💰 Puntos base calculados para ${targetUser}: ${totalBasePoints}`);
          console.log(`   - Canciones: ${stats.totalSongs} × ${POINTS_CONFIG.SONG_REQUEST} = ${basePoints}`);
          console.log(`   - Bonus VIP: ${vipBonus}`);
          
          // Actualizar bestStreak en las estadísticas para los logros
          data.stats.bestStreak = data.streaks.best;
          
          // Verificar y otorgar logros automáticamente
          let newAchievementPoints = 0;
          ACHIEVEMENTS.forEach(achievement => {
            if (achievement.condition(data.stats)) {
              if (!data.achievements.includes(achievement.id)) {
                data.achievements.push(achievement.id);
                newAchievementPoints += achievement.points;
                console.log(`🏆 Nuevo logro otorgado a ${targetUser}: ${achievement.title} (+${achievement.points} puntos)`);
              }
            }
          });
          
          // Calcular puntos totales de logros (existentes + nuevos)
          const totalAchievementPoints = existingAchievementPoints + newAchievementPoints;
          
          // Agregar puntos de logros al total
          data.points += totalAchievementPoints;
          data.xp += totalAchievementPoints;
          
          // Log de puntos de logros
          if (newAchievementPoints > 0) {
            console.log(`💰 Puntos de nuevos logros para ${targetUser}: +${newAchievementPoints}`);
          }
          if (existingAchievementPoints > 0) {
            console.log(`💰 Puntos de logros existentes para ${targetUser}: +${existingAchievementPoints}`);
          }
          
          // Recalcular nivel con puntos totales finales
          data.level = calculateLevel(data.points);
          
          // Log final de resumen
          console.log(`📊 Resumen final para ${targetUser}:`);
          console.log(`   - Puntos base: ${totalBasePoints}`);
          console.log(`   - Puntos de logros existentes: ${existingAchievementPoints}`);
          console.log(`   - Puntos de logros nuevos: ${newAchievementPoints}`);
          console.log(`   - Total puntos: ${data.points}`);
          console.log(`   - Nivel: ${data.level}`);
          console.log(`   - Logros totales: ${data.achievements.length}`);
          
          // Guardar datos
          saveGamificationDataForUser(data, targetUser);
          console.log(`💾 Datos guardados para ${targetUser}`);
          
          console.log(`✅ Usuario ${targetUser}: ${data.points} puntos, nivel ${data.level}, ${data.achievements.length} logros`);
          
        } catch (error) {
          console.error(`Error procesando usuario ${targetUser}:`, error);
        }
      }

      // Función para diagnosticar problemas en la obtención de solicitudes
      async function diagnoseSolicitudesIssues(username) {
        console.log(`🔍 DIAGNÓSTICO COMPLETO PARA: ${username}`);
        
        try {
          // 1. Verificar Firestore
          const firestoreSnapshot = await db.collection('solicitudes').where('usuario', '==', username).get();
          const firestoreCount = firestoreSnapshot.size;
          console.log(`🔥 Firestore: ${firestoreCount} solicitudes para ${username}`);
          
          // 2. Verificar localStorage directo
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const localCount = localSolicitudes.filter(s => s.usuario === username).length;
          console.log(`💾 localStorage directo: ${localCount} solicitudes para ${username}`);
          
          // 3. Verificar localStorage byDay
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          let byDayCount = 0;
          Object.values(byDay).flat().forEach(s => {
            if (s.usuario === username) byDayCount++;
          });
          console.log(`📅 localStorage byDay: ${byDayCount} solicitudes para ${username}`);
          
          // 4. Verificar función combinada
          const allSolicitudes = await getAllCombinedSolicitudes();
          const combinedCount = allSolicitudes.filter(s => s.usuario === username).length;
          console.log(`🎵 Función combinada: ${combinedCount} solicitudes para ${username}`);
          
          // 5. Mostrar algunas solicitudes de ejemplo
          const userSongs = allSolicitudes.filter(s => s.usuario === username).slice(0, 5);
          console.log(`📋 Primeras 5 solicitudes de ${username}:`, userSongs);
          
          return {
            firestore: firestoreCount,
            localStorage: localCount,
            byDay: byDayCount,
            combined: combinedCount,
            samples: userSongs
          };
          
        } catch (error) {
          console.error(`❌ Error en diagnóstico para ${username}:`, error);
          return null;
        }
      }

      // Función para validar y corregir datos de gamificación
      function validateAndFixGamificationData(data, username) {
        console.log(`🔍 Validando datos de gamificación para ${username}`);
        
        // Asegurar que achievements es un array
        if (!Array.isArray(data.achievements)) {
          data.achievements = [];
          console.log(`⚠️ Corrigiendo achievements para ${username}: convertido a array`);
        }
        
        // Calcular puntos correctos de logros
        const achievementPoints = data.achievements.reduce((total, achievementId) => {
          const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
          if (!achievement) {
            console.log(`⚠️ Logro no encontrado: ${achievementId} para ${username}`);
            return total;
          }
          return total + achievement.points;
        }, 0);
        
        // Asegurar estructura de streaks
        if (!data.streaks || typeof data.streaks !== 'object') {
          data.streaks = {
            current: 0,
            best: 0,
            lastActivity: null,
            calendar: {}
          };
          console.log(`⚠️ Corrigiendo streaks para ${username}: estructura recreada`);
        }
        
        // Asegurar estructura de stats
        if (!data.stats || typeof data.stats !== 'object') {
          data.stats = {
            totalSongs: 0,
            uniqueArtists: 0,
            activeDays: 0,
            isVip: false,
            bestStreak: data.streaks.best || 0
          };
          console.log(`⚠️ Corrigiendo stats para ${username}: estructura recreada`);
        }
        
        // Asegurar que bestStreak esté en stats
        if (typeof data.stats.bestStreak === 'undefined') {
          data.stats.bestStreak = data.streaks.best || 0;
        }
        
        // CORRECCIÓN CRÍTICA: Recalcular puntos totales correctos
        const stats = calculateUserStatsForUser(username);
        const songPoints = stats.totalSongs * 25; // 25 puntos por canción
        const vipBonus = stats.isVip ? (stats.totalSongs * 15) : 0; // 15 puntos extra por canción si es VIP
        const correctTotalPoints = songPoints + vipBonus + achievementPoints;
        
        // Solo corregir si hay una diferencia significativa
        if (Math.abs(data.points - correctTotalPoints) > 5) {
          console.log(`🔧 CORRIGIENDO PUNTOS para ${username}:`);
          console.log(`   - Puntos actuales: ${data.points}`);
          console.log(`   - Puntos por canciones: ${songPoints} (${stats.totalSongs} canciones × 25)`);
          console.log(`   - Bonus VIP: ${vipBonus}`);
          console.log(`   - Puntos por logros: ${achievementPoints}`);
          console.log(`   - Total correcto: ${correctTotalPoints}`);
          
          data.points = correctTotalPoints;
          data.xp = correctTotalPoints; // XP debe ser igual a puntos totales
        }
        
        console.log(`✅ Validación completada para ${username}: ${data.achievements.length} logros, ${achievementPoints} puntos de logros, ${data.points} puntos totales`);
        return achievementPoints;
      }
      
      // Función para corregir puntos de todos los usuarios
      window.corregirPuntosTodosLosUsuarios = async function() {
        console.log('🔧 INICIANDO CORRECCIÓN MASIVA DE PUNTOS...');
        
        try {
          // Obtener todos los usuarios únicos
          const allUsers = new Set();
          
          // Usuarios de localStorage
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          localSolicitudes.forEach(sol => {
            if (sol.usuario && sol.usuario.trim()) {
              allUsers.add(sol.usuario.trim());
            }
          });
          
          // Usuarios de Firebase
          try {
            const solicitudesSnap = await db.collection('solicitudes').get();
            solicitudesSnap.forEach(doc => {
              const { usuario } = doc.data();
              if (usuario && usuario.trim()) allUsers.add(usuario.trim());
            });
          } catch (error) {
            console.warn('Error obteniendo usuarios de Firebase:', error);
          }
          
          console.log(`📊 Corrigiendo puntos para ${allUsers.size} usuarios...`);
          
          let correctedCount = 0;
          for (const username of allUsers) {
            try {
              let data = getGamificationDataForUser(username);
              const oldPoints = data.points;
              
              // Validar y corregir datos
              validateAndFixGamificationData(data, username);
              
              // Guardar datos corregidos
              saveGamificationDataForUser(data, username);
              
              if (oldPoints !== data.points) {
                correctedCount++;
                console.log(`✅ ${username}: ${oldPoints} → ${data.points} puntos`);
              }
            } catch (error) {
              console.error(`❌ Error corrigiendo ${username}:`, error);
            }
          }
          
          console.log(`🎉 CORRECCIÓN COMPLETADA: ${correctedCount} usuarios corregidos de ${allUsers.size} totales`);
          alert(`Corrección completada: ${correctedCount} usuarios tuvieron sus puntos corregidos.`);
          
          return { total: allUsers.size, corrected: correctedCount };
        } catch (error) {
          console.error('Error en corrección masiva:', error);
          alert('Error durante la corrección. Revisa la consola para más detalles.');
        }
      };
      
      // Función simple para corrección inmediata (sin async)
      window.corregirPuntosRapido = function() {
        console.log('⚡ CORRECCIÓN RÁPIDA DE PUNTOS...');
        
        try {
          // Obtener todos los usuarios de localStorage
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const allUsers = new Set();
          
          localSolicitudes.forEach(sol => {
            if (sol.usuario && sol.usuario.trim()) {
              allUsers.add(sol.usuario.trim());
            }
          });
          
          console.log(`📊 Corrigiendo puntos para ${allUsers.size} usuarios...`);
          
          let correctedCount = 0;
          for (const username of allUsers) {
            try {
              let data = getGamificationDataForUser(username);
              const oldPoints = data.points;
              
              // Calcular puntos correctos basado en canciones
              const userSongs = localSolicitudes.filter(s => s.usuario === username);
              const songPoints = userSongs.length * 25; // 25 puntos por canción
              
              // Calcular puntos de logros
              const achievementPoints = data.achievements.reduce((total, achievementId) => {
                const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
                return achievement ? total + achievement.points : total;
              }, 0);
              
              const correctTotalPoints = songPoints + achievementPoints;
              
              // Solo corregir si hay diferencia
              if (Math.abs(data.points - correctTotalPoints) > 5) {
                data.points = correctTotalPoints;
                data.xp = correctTotalPoints;
                saveGamificationDataForUser(data, username);
                correctedCount++;
                console.log(`✅ ${username}: ${oldPoints} → ${data.points} puntos`);
              }
            } catch (error) {
              console.error(`❌ Error corrigiendo ${username}:`, error);
            }
          }
          
          console.log(`🎉 CORRECCIÓN COMPLETADA: ${correctedCount} usuarios corregidos`);
          alert(`Corrección completada: ${correctedCount} usuarios tuvieron sus puntos corregidos.`);
          
          return { total: allUsers.size, corrected: correctedCount };
        } catch (error) {
          console.error('Error en corrección rápida:', error);
          alert('Error durante la corrección. Revisa la consola para más detalles.');
        }
      };

      // Función para recalcular todos los usuarios y corregir inconsistencias
      async function recalculateAllUsers() {
        console.log('🔄 INICIANDO RECÁLCULO MASIVO DE USUARIOS...');
        
        try {
          // Obtener todos los usuarios únicos de todas las fuentes
          const allUsers = new Set();
          
          // Usuarios de Firebase
          try {
            const usersSnap = await db.collection('users').get();
            usersSnap.forEach(doc => {
              const { name } = doc.data();
              if (name && name.trim()) allUsers.add(name.trim());
            });
            
            const solicitudesSnap = await db.collection('solicitudes').get();
            solicitudesSnap.forEach(doc => {
              const { usuario } = doc.data();
              if (usuario && usuario.trim()) allUsers.add(usuario.trim());
            });
          } catch (error) {
            console.warn('Error obteniendo usuarios de Firebase:', error);
          }
          
          // Usuarios de localStorage
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          localSolicitudes.forEach(s => {
            if (s.usuario && s.usuario.trim()) allUsers.add(s.usuario.trim());
          });
          
          Object.values(byDay).flat().forEach(s => {
            if (s.usuario && s.usuario.trim()) allUsers.add(s.usuario.trim());
          });
          
          console.log(`👥 Encontrados ${allUsers.size} usuarios únicos para recalcular`);
          
          // Recalcular cada usuario
          let processed = 0;
          for (const username of allUsers) {
            try {
              console.log(`🔄 Recalculando usuario ${++processed}/${allUsers.size}: ${username}`);
              
              // Limpiar flag de procesado para forzar recálculo
              const data = getGamificationDataForUser(username);
              delete data.autoProcessed;
              saveGamificationDataForUser(data, username);
              
              // Recalcular
              await analyzeAndGrantPointsForUser(username);
              
            } catch (error) {
              console.error(`Error recalculando usuario ${username}:`, error);
            }
          }
          
          console.log('✅ RECÁLCULO MASIVO COMPLETADO');
          showSuccessNotification(`Recálculo completado: ${processed} usuarios procesados`);
          
          // Actualizar modal si está abierto
          if (document.getElementById('gamification-modal').style.display !== 'none') {
            await renderGamificationModal();
          }
          
        } catch (error) {
          console.error('Error en recálculo masivo:', error);
          showErrorNotification('Error durante el recálculo masivo');
        }
      }

      // ===== FUNCIONES PARA SELECTOR DE USUARIO =====
      
      let currentSelectedUser = ''; // Se inicializará correctamente en getCurrentSelectedUser()

      async function populateUserSelector() {
        const userSelect = document.getElementById('gamification-user-select');
        if (!userSelect) {
          return;
        }

        try {
          const users = new Set();

          // Obtener usuarios de Firebase
          try {
            // Obtener usuarios de la colección 'users'
            const usersSnap = await db.collection('users').orderBy('name').get();
            usersSnap.forEach(doc => {
              const { name } = doc.data();
              if (name && name.trim()) users.add(name.trim());
            });

            // Obtener usuarios de la colección 'solicitudes'
            const solicitudesSnap = await db.collection('solicitudes').orderBy('day', 'desc').limit(1000).get();
            solicitudesSnap.forEach(doc => {
              const usuario = doc.data().usuario;
              if (usuario && usuario.trim()) users.add(usuario.trim());
            });
          } catch (error) {
            console.error('Error obteniendo usuarios de Firebase:', error);
          }

          // Complementar con usuarios de localStorage
          try {
            const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
            const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
            
            // Agregar usuarios de solicitudes locales
            solicitudes.forEach(s => {
              if (s.usuario && s.usuario.trim()) users.add(s.usuario.trim());
            });
            
            // Agregar usuarios de byDay
            Object.values(byDay).flat().forEach(s => {
              if (s.usuario && s.usuario.trim()) users.add(s.usuario.trim());
            });
          } catch (error) {
            console.error('Error obteniendo usuarios de localStorage:', error);
          }
          
          const usersList = Array.from(users).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          console.log(`👥 Usuarios encontrados para selector:`, usersList);
          
          const options = '<option value="">Selecciona un usuario</option>' +
            usersList.map(user => `<option value="${user}">${user}</option>`).join('');
          
          userSelect.innerHTML = options;
          console.log(`✅ Selector poblado con ${usersList.length} usuarios`);
          
          if (usersList.length === 0) {
            userSelect.innerHTML = '<option value="">No hay usuarios disponibles</option>';
            console.log(`⚠️ No se encontraron usuarios para el selector`);
          }
        } catch (error) {
          console.error('Error al cargar usuarios:', error);
          userSelect.innerHTML = '<option value="">Error al cargar usuarios</option>';
        }
      }

      // Función de respaldo que usa solo localStorage
      function populateUserSelectorFromLocalStorage() {
        const userSelect = document.getElementById('gamification-user-select');
        if (!userSelect) return;

        try {
          const users = new Set();
          
          // Obtener usuarios de localStorage
          const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          // Agregar usuarios de solicitudes locales
          solicitudes.forEach(s => {
            if (s.usuario && s.usuario.trim()) users.add(s.usuario.trim());
          });
          
          // Agregar usuarios de byDay
          Object.values(byDay).flat().forEach(s => {
            if (s.usuario && s.usuario.trim()) users.add(s.usuario.trim());
          });
          
          const usersList = Array.from(users).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          const options = '<option value="">Selecciona un usuario</option>' +
            usersList.map(user => `<option value="${user}">${user}</option>`).join('');
          
          userSelect.innerHTML = options;
          
          if (usersList.length === 0) {
            userSelect.innerHTML = '<option value="">No hay usuarios disponibles</option>';
          }
        } catch (error) {
          console.error('Error en fallback localStorage:', error);
          userSelect.innerHTML = '<option value="">Error al cargar usuarios</option>';
        }
      }

      // Función auxiliar para obtener todos los datos combinados
      async function getAllCombinedSolicitudes() {
        try {
          // Obtener todas las solicitudes de Firestore
          const firestoreSnapshot = await db.collection('solicitudes').get();
          const firestoreSolicitudes = [];
          
          firestoreSnapshot.forEach(doc => {
            const data = doc.data();
            if (data.usuario && data.cancion && data.artista) {
              firestoreSolicitudes.push({
                usuario: data.usuario,
                cancion: data.cancion,
                artista: data.artista,
                day: data.day,
                ts: data.ts ? data.ts.toMillis() : Date.now()
              });
            }
          });
          
          console.log(`🔥 Firestore: ${firestoreSolicitudes.length} solicitudes obtenidas`);
          
          // Obtener solicitudes de localStorage como respaldo
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          console.log(`💾 localStorage: ${localSolicitudes.length} solicitudes directas`);
          console.log(`📅 localStorage byDay: ${Object.keys(byDay).length} días con datos`);
          
          // Combinar datos de Firestore y localStorage, evitando duplicados
          const allSolicitudesMap = new Map();
          
          // Agregar solicitudes de Firestore
          firestoreSolicitudes.forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.ts}`;
            allSolicitudesMap.set(key, s);
          });
          
          // Agregar solicitudes de localStorage que no estén en Firestore
          localSolicitudes.forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.time}`;
            if (!allSolicitudesMap.has(key)) {
              allSolicitudesMap.set(key, {
                usuario: s.usuario,
                cancion: s.cancion,
                artista: s.artista,
                ts: s.time
              });
            }
          });
          
          // Agregar solicitudes de byDay que no estén incluidas
          Object.values(byDay).flat().forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.time}`;
            if (!allSolicitudesMap.has(key)) {
              allSolicitudesMap.set(key, {
                usuario: s.usuario,
                cancion: s.cancion,
                artista: s.artista,
                ts: s.time
              });
            }
          });

          const finalResult = Array.from(allSolicitudesMap.values());
          console.log(`🎵 Total solicitudes combinadas: ${finalResult.length}`);
          
          // Mostrar estadísticas por usuario para debugging
          const userStats = {};
          finalResult.forEach(s => {
            if (!userStats[s.usuario]) userStats[s.usuario] = 0;
            userStats[s.usuario]++;
          });
          
          console.log(`👥 Usuarios con solicitudes:`, Object.keys(userStats).length);
          console.log(`📊 Top 5 usuarios:`, Object.entries(userStats)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([user, count]) => `${user}: ${count}`)
          );
          
          return finalResult;
        } catch (error) {
          console.error('❌ Error en getAllCombinedSolicitudes:', error);
          
          // Fallback a localStorage
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          const allLocal = [...localSolicitudes];
          Object.values(byDay).flat().forEach(s => {
            if (!allLocal.find(existing => 
              existing.usuario === s.usuario && 
              existing.cancion === s.cancion && 
              existing.artista === s.artista && 
              existing.time === s.time
            )) {
              allLocal.push(s);
            }
          });
          
          return allLocal;
        }
      }

      async function switchToUser(username) {
        console.log(`🔄 INICIO - Cambiando a usuario: ${username || 'usuario actual'}`);
        console.log(`📝 Usuario anterior: ${currentSelectedUser}`);
        
        if (!username) {
          currentSelectedUser = getCurrentUser();
          username = currentSelectedUser;
          console.log(`🔄 Sin username proporcionado, usando usuario actual: ${username}`);
        } else {
          currentSelectedUser = username;
          console.log(`✅ currentSelectedUser actualizado a: ${currentSelectedUser}`);
        }
        
        // Verificar datos existentes
        console.log(`📊 Verificando datos para usuario: ${username}`);
        
        // Renderizar modal directamente con datos existentes
        console.log(`🎨 Llamando renderGamificationModal para ${username}`);
        await renderGamificationModal();
        console.log(`✅ FIN - Modal actualizado para usuario: ${currentSelectedUser}`);
      }

      function getCurrentSelectedUser() {
        return currentSelectedUser || getCurrentUser();
      }

      // Función de prueba para verificar y otorgar todos los logros de insignias
      window.testBadgeAchievements = function(username) {
        console.log(`🧪 PRUEBA MANUAL: Verificando logros de insignias para ${username}`);
        
        try {
          // Obtener datos del usuario
          let userData = getGamificationDataForUser(username);
          console.log(`📊 Datos actuales:`, userData);
          
          if (!userData.achievements) userData.achievements = [];
          
          // Verificar todas las insignias desde la gestión de insignias (Firebase)
          const isVipFromSet = (typeof vipSet !== 'undefined' && vipSet.has(username));
          const isZ0VipFromSet = (typeof z0VipSet !== 'undefined' && z0VipSet.has(username));
          const isDonadorFromSet = (typeof donadorSet !== 'undefined' && donadorSet.has(username));
          
          console.log(`🔍 Estado de insignias desde gestión:`);
          console.log(`  - VIP (vipSet de Firebase): ${isVipFromSet}`);
          console.log(`  - Z0-VIP (z0VipSet de Firebase): ${isZ0VipFromSet}`);
          console.log(`  - Donador (donadorSet de Firebase): ${isDonadorFromSet}`);
          console.log(`  - vipSet disponible: ${typeof vipSet !== 'undefined'}`);
          console.log(`  - z0VipSet disponible: ${typeof z0VipSet !== 'undefined'}`);
          console.log(`  - donadorSet disponible: ${typeof donadorSet !== 'undefined'}`);
          
          const isVip = isVipFromSet;
          const isZ0Vip = isZ0VipFromSet;
          const isDonador = isDonadorFromSet;
          
          let pointsAwarded = 0;
          let achievementsGranted = [];
          
          // Verificar y otorgar logro VIP
          if (isVip && !userData.achievements.includes('vip_member')) {
            console.log(`🎉 OTORGANDO logro VIP...`);
            userData.achievements.push('vip_member');
            pointsAwarded += 200;
            achievementsGranted.push('Miembro VIP (+200 pts)');
          }
          
          // Verificar y otorgar logro Z0-VIP
          if (isZ0Vip && !userData.achievements.includes('z0_vip_member')) {
            console.log(`🎉 OTORGANDO logro Z0-VIP...`);
            userData.achievements.push('z0_vip_member');
            pointsAwarded += 300;
            achievementsGranted.push('Z0-VIP Exclusivo (+300 pts)');
          }
          
          // Verificar y otorgar logro Donador
          if (isDonador && !userData.achievements.includes('donador_member')) {
            console.log(`🎉 OTORGANDO logro Donador...`);
            userData.achievements.push('donador_member');
            pointsAwarded += 250;
            achievementsGranted.push('Donador Generoso (+250 pts)');
          }
          
          // Aplicar cambios si hay logros nuevos
          if (pointsAwarded > 0) {
            userData.points = (userData.points || 0) + pointsAwarded;
            userData.xp = (userData.xp || 0) + pointsAwarded;
            userData.level = calculateLevel(userData.xp);
            
            saveGamificationDataForUser(userData, username);
            
            console.log(`✅ ÉXITO: Logros otorgados a ${username}:`, achievementsGranted);
            console.log(`💰 Puntos totales: ${userData.points} (+${pointsAwarded})`);
            console.log(`⭐ Nivel: ${userData.level}`);
            
            return true;
          } else {
            console.log(`ℹ️ INFO: ${username} ya tiene todos los logros de insignias disponibles`);
            console.log(`🏆 Logros actuales:`, userData.achievements);
            return false;
          }
          
        } catch (error) {
          console.error('❌ ERROR en prueba:', error);
          return false;
        }
      };
      
      // Función simple para otorgar logros de insignias
      window.grantBadgeAchievement = function(username) {
        if (!username) {
          console.warn('⚠️ No se proporcionó nombre de usuario');
          return false;
        }
        
        console.log(`🎯 Otorgando logros de insignias para: ${username}`);
        
        try {
          // Verificar que los sets estén definidos y cargados
          if (typeof window.vipSet === 'undefined' || typeof window.z0VipSet === 'undefined' || typeof window.donadorSet === 'undefined') {
            console.warn(`⚠️ Sets no definidos para ${username}, inicializando...`);
            // Inicializar sets si no existen
            if (typeof window.vipSet === 'undefined') window.vipSet = new Set();
            if (typeof window.z0VipSet === 'undefined') window.z0VipSet = new Set();
            if (typeof window.donadorSet === 'undefined') window.donadorSet = new Set();
            return false;
          }
          
          if (!window.vipSet || !window.z0VipSet || !window.donadorSet) {
            console.warn(`⚠️ Sets no inicializados para ${username}`);
            return false;
          }
          
          const totalUsers = window.vipSet.size + window.z0VipSet.size + window.donadorSet.size;
          if (totalUsers === 0) {
            console.warn(`⚠️ Sets vacíos para ${username}, datos aún no cargados`);
            return false;
          }
          // Verificar que los sets estén disponibles
          console.log(`📊 Estado de sets: vipSet=${typeof window.vipSet !== 'undefined'}, z0VipSet=${typeof window.z0VipSet !== 'undefined'}, donadorSet=${typeof window.donadorSet !== 'undefined'}`);
          
          // Obtener datos del usuario
          let userData = getGamificationDataForUser(username);
          console.log(`📊 Datos actuales de ${username}:`, userData);
          
          if (!userData.achievements) userData.achievements = [];
          
          let pointsAdded = 0;
          let newAchievements = [];
          
          // Verificar VIP
          if (typeof window.vipSet !== 'undefined' && window.vipSet.has(username)) {
            console.log(`🔍 ${username} está en vipSet`);
            if (!userData.achievements.includes('vip_member')) {
              userData.achievements.push('vip_member');
              pointsAdded += 200;
              newAchievements.push('VIP (+200)');
              console.log(`✅ Logro VIP otorgado a ${username}`);
            } else {
              console.log(`ℹ️ ${username} ya tiene el logro VIP`);
            }
          } else {
            console.log(`ℹ️ ${username} no está en vipSet`);
          }
          
          // Verificar Z0-VIP
          if (typeof window.z0VipSet !== 'undefined' && window.z0VipSet.has(username)) {
            console.log(`🔍 ${username} está en z0VipSet`);
            if (!userData.achievements.includes('z0_vip_member')) {
              userData.achievements.push('z0_vip_member');
              pointsAdded += 300;
              newAchievements.push('Z0-VIP (+300)');
              console.log(`✅ Logro Z0-VIP otorgado a ${username}`);
            } else {
              console.log(`ℹ️ ${username} ya tiene el logro Z0-VIP`);
            }
          } else {
            console.log(`ℹ️ ${username} no está en z0VipSet`);
          }
          
          // Verificar Donador
          if (typeof window.donadorSet !== 'undefined' && window.donadorSet.has(username)) {
            console.log(`🔍 ${username} está en donadorSet`);
            if (!userData.achievements.includes('donador_member')) {
              userData.achievements.push('donador_member');
              pointsAdded += 250;
              newAchievements.push('Donador (+250)');
              console.log(`✅ Logro Donador otorgado a ${username}`);
            } else {
              console.log(`ℹ️ ${username} ya tiene el logro Donador`);
            }
          } else {
            console.log(`ℹ️ ${username} no está en donadorSet`);
          }
          
          // Aplicar puntos si hay logros nuevos
          if (pointsAdded > 0) {
            userData.points = (userData.points || 0) + pointsAdded;
            userData.xp = (userData.xp || 0) + pointsAdded;
            userData.level = calculateLevel(userData.xp);
            
            console.log(`💾 Guardando datos actualizados para ${username}:`, userData);
            saveGamificationDataForUser(userData, username);
            
            console.log(`🎉 ${username}: ${newAchievements.join(', ')} - Total: ${userData.points} pts`);
            return true;
          } else {
            console.log(`ℹ️ ${username} ya tiene todos los logros de insignias`);
            return false;
          }
          
        } catch (error) {
          console.error(`❌ Error otorgando logros a ${username}:`, error);
          console.error('Stack trace:', error.stack);
          return false;
        }
      };
      
      // Función para procesar todos los usuarios con insignias
      window.processAllBadges = function() {
        console.log(`🚀 Procesando TODOS los usuarios con insignias...`);
        
        let total = 0;
        let success = 0;
        
        // Procesar VIP
        if (typeof vipSet !== 'undefined') {
          vipSet.forEach(username => {
            total++;
            if (window.grantBadgeAchievement(username)) success++;
          });
        }
        
        // Procesar Z0-VIP
        if (typeof z0VipSet !== 'undefined') {
          z0VipSet.forEach(username => {
            total++;
            if (window.grantBadgeAchievement(username)) success++;
          });
        }
        
        // Procesar Donadores
        if (typeof donadorSet !== 'undefined') {
          donadorSet.forEach(username => {
            total++;
            if (window.grantBadgeAchievement(username)) success++;
          });
        }
        
        console.log(`🏁 COMPLETADO: ${success}/${total} usuarios recibieron nuevos logros`);
        return { total, success };
      };

      // Función de diagnóstico para verificar el estado del sistema
      window.diagnosticBadges = async function() {
        console.log('🔍 === DIAGNÓSTICO DEL SISTEMA DE LOGROS ===');
        
        // 1. Verificar sets
        console.log('📊 Estado de los sets:');
        console.log(`- VIP Set: ${vipSet ? vipSet.size : 'NO DEFINIDO'} usuarios`);
        console.log(`- Z0-VIP Set: ${z0VipSet ? z0VipSet.size : 'NO DEFINIDO'} usuarios`);
        console.log(`- Donador Set: ${donadorSet ? donadorSet.size : 'NO DEFINIDO'} usuarios`);
        
        if (vipSet && vipSet.size > 0) {
          console.log('👥 Usuarios VIP:', Array.from(vipSet));
        }
        if (z0VipSet && z0VipSet.size > 0) {
          console.log('👥 Usuarios Z0-VIP:', Array.from(z0VipSet));
        }
        if (donadorSet && donadorSet.size > 0) {
          console.log('👥 Usuarios Donador:', Array.from(donadorSet));
        }
        
        // 2. Verificar Firebase
        console.log('🔥 Verificando conexión a Firebase...');
        try {
          const testDoc = await db.collection('vipUsers').limit(1).get();
          console.log('✅ Conexión a Firebase OK');
        } catch (error) {
          console.error('❌ Error de conexión a Firebase:', error);
          return;
        }
        
        // 3. Probar con un usuario específico
        if (vipSet && vipSet.size > 0) {
          const testUser = Array.from(vipSet)[0];
          console.log(`🧪 Probando con usuario: ${testUser}`);
          
          try {
            // Verificar datos existentes
            const userData = getGamificationDataForUser(testUser);
            console.log(`📊 Datos actuales de ${testUser}:`, userData);
            
            // Intentar otorgar logro
            console.log(`🎯 Intentando otorgar logro a ${testUser}...`);
            const result = window.grantBadgeAchievement(testUser);
            console.log(`🎯 Resultado: ${result ? 'Éxito' : 'Sin cambios'}`);
            
          } catch (error) {
            console.error(`❌ Error probando con ${testUser}:`, error);
          }
        }
        
        console.log('🔍 === FIN DEL DIAGNÓSTICO ===');
        };

        // Función para otorgar puntos manualmente (sin depender de sets)
        window.grantPointsManual = async function(username, isVip = false, isZ0Vip = false, isDonador = false) {
          console.log(`🎯 Otorgando puntos manualmente a: ${username}`);
          console.log(`Estado: VIP=${isVip}, Z0-VIP=${isZ0Vip}, Donador=${isDonador}`);
          
          try {
            // Obtener datos actuales
            const userStatsRef = db.collection('userStats').doc(username);
            const userStatsDoc = await userStatsRef.get();
            
            let userData = userStatsDoc.exists ? userStatsDoc.data() : {
              points: 0,
              level: 1,
              achievements: [],
              lastUpdated: new Date()
            };
            
            console.log('Datos actuales:', userData);
            
            let pointsAwarded = 0;
            let achievementsGranted = [];
            
            // Otorgar logros según parámetros
            if (isVip && !userData.achievements.includes('vip_badge')) {
              userData.achievements.push('vip_badge');
              userData.points += 200;
              pointsAwarded += 200;
              achievementsGranted.push('VIP');
            }
            
            if (isZ0Vip && !userData.achievements.includes('z0vip_badge')) {
              userData.achievements.push('z0vip_badge');
              userData.points += 300;
              pointsAwarded += 300;
              achievementsGranted.push('Z0-VIP');
            }
            
            if (isDonador && !userData.achievements.includes('donador_badge')) {
              userData.achievements.push('donador_badge');
              userData.points += 150;
              pointsAwarded += 150;
              achievementsGranted.push('Donador');
            }
            
            if (pointsAwarded > 0) {
              userData.lastUpdated = new Date();
              console.log('Guardando datos:', userData);
              
              await userStatsRef.set(userData, { merge: true });
              console.log(`🎉 ${username}: ${achievementsGranted.join(', ')} (+${pointsAwarded}) - Total: ${userData.points} pts`);
              
              // Verificar que se guardó
              const verification = await userStatsRef.get();
              if (verification.exists) {
                console.log('✅ Verificación exitosa:', verification.data());
              } else {
                console.error('❌ Error: datos no se guardaron');
              }
              
            } else {
              console.log('ℹ️ No hay logros nuevos para otorgar');
            }
            
          } catch (error) {
            console.error('❌ Error:', error);
          }
        };

        // Función para forzar la carga de sets y procesar logros
        window.forceLoadAndProcess = function() {
          console.log('🚀 Forzando carga de sets y procesamiento de logros...');
          
          // Verificar estado actual
          console.log(`📊 Estado actual: VIP(${vipSet ? vipSet.size : 'undefined'}), Z0-VIP(${z0VipSet ? z0VipSet.size : 'undefined'}), Donador(${donadorSet ? donadorSet.size : 'undefined'})`);
          
          // Esperar un poco más y luego procesar
          setTimeout(() => {
            console.log('⏰ Esperando 5 segundos para asegurar carga completa...');
            setTimeout(() => {
              console.log(`📊 Estado después de espera: VIP(${vipSet ? vipSet.size : 'undefined'}), Z0-VIP(${z0VipSet ? z0VipSet.size : 'undefined'}), Donador(${donadorSet ? donadorSet.size : 'undefined'})`);
              
              if (vipSet && z0VipSet && donadorSet) {
                const totalUsers = vipSet.size + z0VipSet.size + donadorSet.size;
                if (totalUsers > 0) {
                  console.log('✅ Sets cargados, procesando logros...');
                  window.processAllBadges();
                } else {
                  console.warn('⚠️ Sets definidos pero vacíos. Puede que no haya usuarios VIP/Z0-VIP/Donador o los datos no se han cargado.');
                }
              } else {
                console.error('❌ Sets aún no definidos después de la espera');
              }
            }, 5000);
          }, 1000);
        };
      
      // Funciones de compatibilidad
      window.testVipAchievement = window.grantBadgeAchievement;
      window.testBadgeAchievements = window.grantBadgeAchievement;
      window.processAllVipAchievements = window.processAllBadges;

      // Función simplificada para procesar solo logros
      async function processAchievementsForUser(username, existingData) {
        try {
          console.log(`🏆 Procesando logros para ${username}...`);
          
          // Verificar que los sets estén inicializados y cargados
          if (typeof vipSet === 'undefined' || typeof z0VipSet === 'undefined' || typeof donadorSet === 'undefined' ||
              !vipSet || !z0VipSet || !donadorSet) {
            console.log(`⏳ Sets de insignias aún no inicializados para ${username}, reintentando en 2 segundos...`);
            setTimeout(() => processAchievementsForUser(username, existingData), 2000);
            return existingData;
          }
          
          // Verificar que al menos uno de los sets tenga datos (indicando que ya se cargaron)
          const totalUsers = vipSet.size + z0VipSet.size + donadorSet.size;
          if (totalUsers === 0) {
            console.log(`⏳ Sets de insignias vacíos para ${username}, esperando carga de datos... reintentando en 3 segundos`);
            setTimeout(() => processAchievementsForUser(username, existingData), 3000);
            return existingData;
          }
          
          console.log(`✅ Sets cargados: VIP(${vipSet.size}), Z0-VIP(${z0VipSet.size}), Donador(${donadorSet.size})`);
          
          // Usar datos existentes como base
          const data = { ...existingData };
          
          if (!data.achievements) data.achievements = [];
          
          // Verificar insignias del usuario desde la gestión de insignias (Firebase)
          const isVipFromSet = vipSet.has(username);
          const isZ0VipFromSet = z0VipSet.has(username);
          const isDonadorFromSet = donadorSet.has(username);
          
          console.log(`🔍 Verificando insignias desde gestión para ${username}:`);
          console.log(`   - VIP (vipSet de Firebase): ${isVipFromSet}`);
          console.log(`   - Z0-VIP (z0VipSet de Firebase): ${isZ0VipFromSet}`);
          console.log(`   - Donador (donadorSet de Firebase): ${isDonadorFromSet}`);
          console.log(`   - vipSet size: ${vipSet.size}, z0VipSet size: ${z0VipSet.size}, donadorSet size: ${donadorSet.size}`);
          
          const isVip = isVipFromSet;
          const isZ0Vip = isZ0VipFromSet;
          const isDonador = isDonadorFromSet;
          
          let pointsAwarded = 0;
          let achievementsGranted = [];
          
          // Procesar logro VIP
          if (isVip && !data.achievements.includes('vip_member')) {
            console.log(`🎉 Otorgando logro VIP a ${username}`);
            data.achievements.push('vip_member');
            pointsAwarded += 200;
            achievementsGranted.push('Miembro VIP (+200 pts)');
          }
          
          // Procesar logro Z0-VIP
          if (isZ0Vip && !data.achievements.includes('z0_vip_member')) {
            console.log(`🎉 Otorgando logro Z0-VIP a ${username}`);
            data.achievements.push('z0_vip_member');
            pointsAwarded += 300;
            achievementsGranted.push('Z0-VIP Exclusivo (+300 pts)');
          }
          
          // Procesar logro Donador
          if (isDonador && !data.achievements.includes('donador_member')) {
            console.log(`🎉 Otorgando logro Donador a ${username}`);
            data.achievements.push('donador_member');
            pointsAwarded += 250;
            achievementsGranted.push('Donador Generoso (+250 pts)');
          }
          
          // Aplicar puntos y XP si se otorgaron logros
          if (pointsAwarded > 0) {
            data.points += pointsAwarded;
            data.xp += pointsAwarded;
            data.level = calculateLevel(data.xp);
            
            // Guardar datos actualizados
            saveGamificationDataForUser(data, username);
            
            console.log(`✅ Logros otorgados a ${username}:`, achievementsGranted);
            console.log(`💰 Puntos totales: ${data.points} (+${pointsAwarded})`);
            console.log(`⭐ Nivel: ${data.level}`);
          } else {
            console.log(`ℹ️ ${username} ya tiene todos los logros de insignias disponibles`);
          }
          
          // Actualizar stats con estados de insignias
          if (!data.stats) data.stats = {};
          data.stats.isVip = isVip;
          data.stats.isZ0Vip = isZ0Vip;
          data.stats.isDonador = isDonador;
          
          return data;
        } catch (error) {
          console.error(`❌ Error procesando logros para ${username}:`, error);
          return existingData;
        }
      }

      // Modificar funciones existentes para usar el usuario seleccionado
      function getGamificationDataForUser(usuario = null) {
        const targetUser = usuario || getCurrentSelectedUser();
        const data = localStorage.getItem('gamificationData');
        const allData = data ? JSON.parse(data) : {};
        
        console.log(`📖 Recuperando datos para ${targetUser} de localStorage`);
        const userData = allData[targetUser.toLowerCase()];
        console.log(`📊 Datos encontrados para ${targetUser}:`, userData);
        
        return userData || {
          points: 0,
          level: 1,
          xp: 0,
          achievements: [],
          streaks: {
            current: 0,
            best: 0,
            lastActivity: null,
            calendar: {}
          },
          stats: {
            totalSongs: 0,
            uniqueArtists: 0,
            activeDays: 0,
            isVip: false
          }
        };
      }

      function saveGamificationDataForUser(data, usuario = null) {
        const targetUser = usuario || getCurrentSelectedUser();
        const allDataStr = localStorage.getItem('gamificationData');
        const allData = allDataStr ? JSON.parse(allDataStr) : {};
        
        console.log(`💾 Guardando datos para ${targetUser}:`, data);
        
        allData[targetUser.toLowerCase()] = data;
        localStorage.setItem('gamificationData', JSON.stringify(allData));
        
        console.log(`✅ Datos guardados en localStorage para ${targetUser}`);
      }

      async function calculateUserStatsForUser(usuario = null) {
        const targetUser = usuario || getCurrentSelectedUser();
        
        try {
          // Obtener datos combinados de Firebase y localStorage
          const allSolicitudes = await getAllCombinedSolicitudes();
          const vipUsers = JSON.parse(localStorage.getItem('vipUsers') || '[]');
          
          const userSongs = allSolicitudes.filter(s => s.usuario === targetUser);
          console.log(`🎵 ${targetUser}: ${userSongs.length} canciones encontradas de ${allSolicitudes.length} totales`);
          
          const uniqueArtists = [...new Set(userSongs.map(s => s.artista))].length;
          console.log(`🎤 ${targetUser}: ${uniqueArtists} artistas únicos`);
          
          // Calcular días únicos basado en fechas de solicitudes
          const uniqueDays = [...new Set(userSongs.map(s => {
            if (s.ts) {
              return new Date(s.ts).toISOString().split('T')[0];
            }
            return new Date().toISOString().split('T')[0];
          }))].length;
          
          console.log(`📅 ${targetUser}: ${uniqueDays} días únicos de actividad`);
          
          // Verificar estado VIP desde Firebase (sets globales)
          const vipSetAvailable = typeof vipSet !== 'undefined';
          const z0VipSetAvailable = typeof z0VipSet !== 'undefined';
          const isVip = (vipSetAvailable && vipSet.has(targetUser)) || (z0VipSetAvailable && z0VipSet.has(targetUser));

          // Obtener datos de gamificación existentes para preservar rachas
          const existingData = getGamificationDataForUser(targetUser);
          const bestStreak = existingData.streaks ? existingData.streaks.best : 0;

          return {
            totalSongs: userSongs.length,
            uniqueArtists,
            activeDays: uniqueDays,
            isVip,
            bestStreak
          };
        } catch (error) {
          console.error('Error al calcular estadísticas del usuario:', error);
          // Fallback a localStorage
          const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const vipUsers = JSON.parse(localStorage.getItem('vipUsers') || '[]');
          
          const userSongs = solicitudes.filter(s => s.usuario === targetUser);
          const uniqueArtists = [...new Set(userSongs.map(s => s.artista))].length;
          
          const uniqueDays = [...new Set(userSongs.map(s => {
            if (s.time) {
              return new Date(s.time).toISOString().split('T')[0];
            }
            return new Date().toISOString().split('T')[0];
          }))].length;
          
          // Verificar estado VIP desde Firebase (sets globales)
          const vipSetAvailable = typeof vipSet !== 'undefined' && vipSet;
          const z0VipSetAvailable = typeof z0VipSet !== 'undefined' && z0VipSet;
          const isVip = (vipSetAvailable && vipSet.has(targetUser)) || (z0VipSetAvailable && z0VipSet.has(targetUser));
          
          console.log(`👑 Verificación VIP para ${targetUser}:`);
          console.log(`   - vipSet disponible: ${vipSetAvailable}`);
          console.log(`   - z0VipSet disponible: ${z0VipSetAvailable}`);
          if (vipSetAvailable) console.log(`   - En vipSet: ${vipSet.has(targetUser)}`);
          if (z0VipSetAvailable) console.log(`   - En z0VipSet: ${z0VipSet.has(targetUser)}`);
          console.log(`   - Es VIP final: ${isVip}`);

          // Obtener datos de gamificación existentes para preservar rachas
          const existingData = getGamificationDataForUser(targetUser);
          const bestStreak = existingData.streaks ? existingData.streaks.best : 0;

          return {
            totalSongs: userSongs.length,
            uniqueArtists,
            activeDays: uniqueDays,
            isVip,
            bestStreak
          };
        }
      }



      // Modificar renderGamificationModal para usar el usuario seleccionado
      async function renderGamificationModal() {
        const targetUser = getCurrentSelectedUser();
        console.log(`🎨 INICIO - Renderizando modal para usuario: ${targetUser}`);
        console.log(`🔍 currentSelectedUser actual: ${currentSelectedUser}`);
        console.log(`👤 getCurrentUser(): ${getCurrentUser()}`);
        
        // Obtener datos del usuario
        let data = getGamificationDataForUser(targetUser);
        console.log(`📊 Datos obtenidos para ${targetUser}:`, data);
        console.log(`🔍 Tipo de datos:`, typeof data);
        console.log(`🔍 Datos válidos:`, data && typeof data === 'object');
        
        if (!data || !data.stats) {
          console.warn(`⚠️ No hay datos para ${targetUser}, creando datos básicos`);
          data = {
            points: 0,
            xp: 0,
            level: 1,
            achievements: [],
            streaks: { current: 0, best: 0, calendar: {} },
            stats: { songCount: 0, uniqueArtists: 0, activeDays: 0 }
          };
        }
        
        // Procesar logros para el usuario si es necesario
        console.log(`📊 Verificando logros para ${targetUser}...`);
        try {
          data = await processAchievementsForUser(targetUser, data);
          console.log(`✅ Logros procesados para ${targetUser}:`, data);
        } catch (error) {
          console.warn(`⚠️ Error procesando logros para ${targetUser}:`, error);
        }
        
        // Verificar y otorgar logros de insignias
        console.log(`🏆 Verificando logros de insignias para ${targetUser}...`);
        window.grantBadgeAchievement(targetUser);
        const currentLevel = getLevelInfo(data.level);
        const nextLevel = getNextLevelInfo(data.level);
        const progressPercent = ((data.xp - currentLevel.xpRequired) / (nextLevel.xpRequired - currentLevel.xpRequired)) * 100;
        
        // Actualizar información del usuario
        const userNameEl = document.getElementById('user-name');
        const userLevelNameEl = document.getElementById('user-level-name');
        const userLevelNumberEl = document.getElementById('user-level-number');
        const userPointsEl = document.getElementById('user-points');
        
        console.log(`🔄 Actualizando elementos del perfil:`);
        console.log(`👤 Nombre: ${targetUser} -> elemento encontrado: ${!!userNameEl}`);
        console.log(`🏆 Nivel: ${data.level} (${currentLevel.name}) -> elementos encontrados: ${!!userLevelNameEl}, ${!!userLevelNumberEl}`);
        console.log(`💰 Puntos: ${data.points} -> elemento encontrado: ${!!userPointsEl}`);
        
        if (userNameEl) userNameEl.textContent = targetUser;
        if (userLevelNameEl) userLevelNameEl.textContent = currentLevel.name;
        if (userLevelNumberEl) userLevelNumberEl.textContent = `Nivel ${data.level}`;
        if (userPointsEl) userPointsEl.textContent = data.points;
        
        console.log(`✅ Información actualizada: ${targetUser}, Nivel ${data.level}, ${data.points} puntos`);
        
        // Actualizar barra de progreso
        const progressFillEl = document.getElementById('progress-fill');
        const currentXpEl = document.getElementById('current-xp');
        const nextLevelXpEl = document.getElementById('next-level-xp');
        
        if (progressFillEl) progressFillEl.style.width = `${Math.min(progressPercent, 100)}%`;
        if (currentXpEl) currentXpEl.textContent = data.xp - currentLevel.xpRequired;
        if (nextLevelXpEl) nextLevelXpEl.textContent = nextLevel.xpRequired - currentLevel.xpRequired;
        
        // Renderizar logros
        console.log(`🏆 Llamando renderAchievementsForUser con datos:`, data);
        try {
          renderAchievementsForUser(data);
        } catch (error) {
          console.error('Error renderizando logros:', error);
        }
        
        // Renderizar rachas
        console.log(`🔥 Llamando renderStreaksForUser con datos:`, data);
        try {
          await renderStreaksForUser(data);
        } catch (error) {
          console.error('Error renderizando rachas:', error);
        }
        
        // Renderizar estadísticas personales
        await renderPersonalStatsForUser(data);
        
        // Actualizar selector de usuario
        populateUserSelector().then(() => {
          const userSelect = document.getElementById('gamification-user-select');
          console.log(`🎯 Configurando selector: targetUser=${targetUser}, getCurrentUser()=${getCurrentUser()}`);
          
          if (userSelect) {
            if (targetUser !== getCurrentUser()) {
              userSelect.value = targetUser;
              console.log(`✅ Selector configurado a: ${targetUser}`);
            } else {
              userSelect.value = '';
              console.log(`🏠 Usuario actual, selector limpio`);
            }
          }
        }).catch(console.error);
      }

      function renderAchievementsForUser(data) {
        console.log(`🏆 Renderizando logros para usuario:`, data.achievements);
        
        const container = document.getElementById('achievements-list');
        if (!container) {
          console.error('❌ Contenedor achievements-list no encontrado');
          return;
        }
        
        if (!ACHIEVEMENTS || ACHIEVEMENTS.length === 0) {
          console.error('❌ No hay logros definidos');
          return;
        }
        
        console.log(`🎯 Renderizando ${ACHIEVEMENTS.length} logros`);
        
        container.innerHTML = ACHIEVEMENTS.map(achievement => {
          const isUnlocked = data.achievements.includes(achievement.id);
          
          return `
            <div class="achievement-card ${isUnlocked ? 'unlocked' : 'locked'}">
              <div class="achievement-points">+${achievement.points}</div>
              <div class="achievement-icon">${achievement.icon}</div>
              <div class="achievement-title">${achievement.title}</div>
              <div class="achievement-description">${achievement.description}</div>
            </div>
          `;
        }).join('');
      }

      function getAchievementProgressForUser(achievement, stats) {
        const id = achievement.id;
        
        if (id === 'first_song' || id === 'music_lover' || id === 'music_addict' || id === 'music_master') {
          const targets = { first_song: 1, music_lover: 10, music_addict: 50, music_master: 100 };
          return `${stats.totalSongs}/${targets[id]} canciones`;
        }
        
        if (id === 'diverse_taste' || id === 'explorer') {
          const targets = { diverse_taste: 10, explorer: 25 };
          return `${stats.uniqueArtists}/${targets[id]} artistas`;
        }
        
        if (id === 'streak_starter' || id === 'streak_master' || id === 'streak_legend') {
          const targets = { streak_starter: 3, streak_master: 7, streak_legend: 30 };
          const bestStreak = stats.bestStreak || 0;
          return `${bestStreak}/${targets[id]} días`;
        }
        
        if (id === 'daily_user') {
          return `${stats.activeDays}/10 días`;
        }
        
        return null;
      }

      async function renderStreaksForUser(data) {
        console.log(`🔥 Renderizando rachas para usuario:`, data.streaks);
        
        const currentStreakEl = document.getElementById('current-streak');
        const bestStreakEl = document.getElementById('best-streak');
        
        if (currentStreakEl) {
          currentStreakEl.textContent = `${data.streaks.current || 0} días`;
        } else {
          console.warn('❌ Elemento current-streak no encontrado');
        }
        
        if (bestStreakEl) {
          bestStreakEl.textContent = `${data.streaks.best || 0} días`;
        } else {
          console.warn('❌ Elemento best-streak no encontrado');
        }
        
        // Renderizar calendario de actividad
        await renderStreakCalendarForUser(data.streaks.calendar || {});
      }

      async function renderStreakCalendarForUser(calendar) {
        try {
          console.log('🗓️ Renderizando calendario de rachas con datos combinados...');
          
          const container = document.getElementById('streak-calendar-grid');
          if (!container) {
            console.warn('❌ Contenedor del calendario de rachas no encontrado');
            return;
          }
          
          // Verificar si ya existe un calendario oficial
          const isOfficial = container.getAttribute('data-calendar-source') === 'official';
          const hasContent = container.innerHTML.trim().length > 500 && container.innerHTML.includes('calendar-day');
          
          if (isOfficial && hasContent) {
            console.log('✅ Calendario oficial ya existe y está completo, no sobrescribir');
            return;
          }
          
          // Usar nuestra función de calendario completo
          if (window.createCompleteStreakCalendar) {
            console.log('✅ Usando calendario completo con todos los datos');
            window.createCompleteStreakCalendar();
            return;
          }
          
          // Fallback: usar datos combinados directamente
          console.log('📦 Fallback: combinando datos manualmente...');
          
          // Obtener TODOS los datos
          const playedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
          const solicitudesByDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          
          // Combinar todos los datos por fecha
          const allActivity = {};
          
          // 1. Agregar playedSongs
          Object.keys(playedSongs).forEach(function(date) {
            allActivity[date] = (allActivity[date] || 0) + playedSongs[date].length;
          });
          
          // 2. Agregar solicitudes_by_day
          Object.keys(solicitudesByDay).forEach(function(date) {
            const dayData = solicitudesByDay[date] || [];
            allActivity[date] = (allActivity[date] || 0) + dayData.length;
          });
          
          // 3. Agregar solicitudes legacy
          solicitudes.forEach(function(song) {
            if (song.time) {
              const date = new Date(song.time).toISOString().split('T')[0];
              allActivity[date] = (allActivity[date] || 0) + 1;
            }
          });
          
          const today = new Date();
          const days = [];
          
          // Generar últimos 28 días
          for (let i = 27; i >= 0; i--) {
            const date = new Date(today.getTime() - (i * 86400000));
            const dateStr = date.toISOString().split('T')[0];
            const isToday = i === 0;
            const activityCount = allActivity[dateStr] || 0;
            
            // Determinar nivel de actividad
            let activityClass = '';
            let activityTitle = dateStr;
            
            if (activityCount > 0) {
              if (activityCount >= 10) {
                activityClass = 'activity-very-high';
                activityTitle += ' - ' + activityCount + ' canciones (Muy activo)';
              } else if (activityCount >= 5) {
                activityClass = 'activity-high';
                activityTitle += ' - ' + activityCount + ' canciones (Activo)';
              } else if (activityCount >= 3) {
                activityClass = 'activity-medium';
                activityTitle += ' - ' + activityCount + ' canciones (Activo)';
              } else {
                activityClass = 'activity-low';
                activityTitle += ' - ' + activityCount + ' canción' + (activityCount > 1 ? 'es' : '') + ' (Poco activo)';
              }
            } else {
              activityTitle += ' - Sin actividad';
            }
            
            days.push('<div class="calendar-day ' + activityClass + (isToday ? ' today' : '') + '" title="' + activityTitle + '">' + date.getDate() + '</div>');
          }
          
          container.innerHTML = days.join('');
          container.setAttribute('data-calendar-source', 'fallback');
          console.log('✅ Calendario renderizado con datos combinados (fallback)');
          
        } catch (error) {
          console.error('Error renderizando calendario de rachas:', error);
          const container = document.getElementById('streak-calendar-grid');
          if (container) {
            container.innerHTML = '<div class="calendar-day">Error al cargar actividad</div>';
          }
        }
      }

      async function renderPersonalStatsForUser(data) {
        const stats = data.stats;
        const targetUser = getCurrentSelectedUser();
        
        console.log(`📊 Renderizando estadísticas para ${targetUser}:`, stats);
        
        const totalSongsEl = document.getElementById('personal-total-songs');
        const uniqueArtistsEl = document.getElementById('personal-unique-artists');
        const activeDaysEl = document.getElementById('personal-active-days');
        
        if (totalSongsEl) totalSongsEl.textContent = stats.totalSongs || 0;
        if (uniqueArtistsEl) uniqueArtistsEl.textContent = stats.uniqueArtists || 0;
        if (activeDaysEl) activeDaysEl.textContent = stats.activeDays || 0;
        
        try {
          // Calcular posición global usando datos combinados
          const allSolicitudes = await getAllCombinedSolicitudes();
          const userCounts = {};
          allSolicitudes.forEach(s => {
            userCounts[s.usuario] = (userCounts[s.usuario] || 0) + 1;
          });
          
          const sortedUsers = Object.entries(userCounts).sort((a, b) => b[1] - a[1]);
          const userRank = sortedUsers.findIndex(([user]) => user === targetUser) + 1;
          
          const personalRankEl = document.getElementById('personal-rank');
          if (personalRankEl) personalRankEl.textContent = userRank > 0 ? `#${userRank}` : '-';
        } catch (error) {
          console.error('Error calculando ranking:', error);
          // Fallback a localStorage
          const allUsers = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const userCounts = {};
          allUsers.forEach(s => {
            userCounts[s.usuario] = (userCounts[s.usuario] || 0) + 1;
          });
          
          const sortedUsers = Object.entries(userCounts).sort((a, b) => b[1] - a[1]);
          const userRank = sortedUsers.findIndex(([user]) => user === targetUser) + 1;
          
          const personalRankEl = document.getElementById('personal-rank');
          if (personalRankEl) personalRankEl.textContent = userRank > 0 ? `#${userRank}` : '-';
        }
        
        // Renderizar géneros favoritos (simulado)
        renderFavoriteGenresForUser();
      }

      function renderFavoriteGenresForUser() {
        const container = document.getElementById('favorite-genres-list');
        const genres = ['Pop', 'Rock', 'Reggaeton', 'Electrónica', 'Indie'];
        
        container.innerHTML = genres.map(genre => 
          `<span class="genre-tag">${genre}</span>`
        ).join('');
      }

      // Event listeners para el selector de usuario
      document.getElementById('gamification-user-select')?.addEventListener('change', async (e) => {
        const userSelect = document.getElementById('gamification-user-select');
        const backBtn = document.getElementById('back-to-my-profile');
        
        console.log(`🔄 Selector cambió a: ${e.target.value}`);
        
        if (e.target.value) {
          await switchToUser(e.target.value);
        }
        
        // Si se selecciona un usuario diferente al actual, ocultar selector y mostrar botón "Cambiar Usuario"
        if (e.target.value && e.target.value !== getCurrentUser()) {
          if (userSelect) {
            userSelect.style.display = 'none';
          }
          if (backBtn) {
            backBtn.style.display = 'inline-block';
          }
        } else {
          // Mostrar selector y ocultar botón si se escoge el usuario actual o se limpia la selección
          if (userSelect) {
            userSelect.style.display = 'block';
          }
          if (backBtn) {
            backBtn.style.display = 'none';
          }
        }
      });

      document.getElementById('back-to-my-profile')?.addEventListener('click', async () => {
        const userSelect = document.getElementById('gamification-user-select');
        const backBtn = document.getElementById('back-to-my-profile');
        
        // Mostrar el selector de nuevo
        if (userSelect) {
          userSelect.style.display = 'block';
          userSelect.value = ''; // Resetear selección
        }
        
        // Ocultar botón "Cambiar Usuario"
        if (backBtn) {
          backBtn.style.display = 'none';
        }
        
        // Volver al usuario actual
        await switchToUser('');
      });

      // Inicializar al cargar la página
      initGamification().catch(console.error);

      // Función para actualizar datos de gamificación de un usuario
      function updateGamificationDataForUser(username, userData) {
        try {
          const allData = JSON.parse(localStorage.getItem('gamificationData') || '{}');
          allData[username.toLowerCase()] = userData;
          localStorage.setItem('gamificationData', JSON.stringify(allData));
          console.log(`💾 Datos actualizados para usuario: ${username}`);
        } catch (error) {
          console.error('Error al actualizar datos de gamificación:', error);
        }
      }

      // ===== FUNCIONES PARA MODAL DE CONFIRMACIÓN =====
      
      // Variable para almacenar el resolver actual
      let currentConfirmationResolver = null;
      
      // Función para mostrar modal de confirmación personalizado
      function showConfirmation(options) {
        return new Promise((resolve) => {
          console.log('🔍 showConfirmation llamada con opciones:', options);
          
          // Verificar que los elementos existen
          if (!confirmationModal || !confirmationCancelBtn || !confirmationConfirmBtn) {
            console.error('❌ Elementos del modal de confirmación no encontrados');
            resolve(false);
            return;
          }
          
          // Configurar el modal
          confirmationIcon.textContent = options.icon || 'ℹ️';
          confirmationTitle.textContent = options.title || 'Confirmación';
          confirmationMessage.textContent = options.message || '¿Estás seguro?';
          
          // Configurar botones
          const cancelText = options.cancelText !== undefined ? options.cancelText : 'Cancelar';
          const confirmText = options.confirmText || 'Confirmar';
          
          // Establecer texto usando múltiples métodos para asegurar que funcione
          confirmationCancelBtn.textContent = cancelText;
          confirmationCancelBtn.innerHTML = cancelText;
          confirmationConfirmBtn.textContent = confirmText;
          confirmationConfirmBtn.innerHTML = confirmText;
          
          console.log('📝 Textos configurados - Cancelar:', cancelText, 'Confirmar:', confirmText);
          console.log('📝 Texto actual en botones - Cancelar:', confirmationCancelBtn.textContent, 'Confirmar:', confirmationConfirmBtn.textContent);
          
          // Mostrar/ocultar botón cancelar
          if (cancelText === '') {
            confirmationCancelBtn.style.display = 'none';
          } else {
            confirmationCancelBtn.style.display = 'inline-flex';
            confirmationCancelBtn.style.visibility = 'visible';
            confirmationCancelBtn.style.opacity = '1';
            confirmationCancelBtn.style.pointerEvents = 'auto';
          }
          
          // Asegurar que el botón confirmar sea visible
          confirmationConfirmBtn.style.display = 'inline-flex';
          confirmationConfirmBtn.style.visibility = 'visible';
          confirmationConfirmBtn.style.opacity = '1';
          confirmationConfirmBtn.style.pointerEvents = 'auto';
          
          // Forzar reflow para asegurar que los cambios se apliquen
          confirmationCancelBtn.offsetHeight;
          confirmationConfirmBtn.offsetHeight;
          
          console.log('👁️ Estilos de botones aplicados');
          console.log('Cancelar visible:', window.getComputedStyle(confirmationCancelBtn).display);
          console.log('Confirmar visible:', window.getComputedStyle(confirmationConfirmBtn).display);
          
          // Guardar el resolver actual
          currentConfirmationResolver = resolve;
          
          // Mostrar modal
          confirmationModal.hidden = false;
          console.log('✅ Modal mostrado');
          
          // Asegurar que los estilos se apliquen después de mostrar el modal
          setTimeout(() => {
            // Forzar visibilidad del botón cancelar
            confirmationCancelBtn.style.display = 'inline-flex';
            confirmationCancelBtn.style.visibility = 'visible';
            confirmationCancelBtn.style.opacity = '1';
            confirmationCancelBtn.style.position = 'static';
            confirmationCancelBtn.style.width = 'auto';
            confirmationCancelBtn.style.height = 'auto';
            
            // Forzar visibilidad del botón confirmar
            confirmationConfirmBtn.style.display = 'inline-flex';
            confirmationConfirmBtn.style.visibility = 'visible';
            confirmationConfirmBtn.style.opacity = '1';
            confirmationConfirmBtn.style.position = 'static';
            confirmationConfirmBtn.style.width = 'auto';
            confirmationConfirmBtn.style.height = 'auto';
            confirmationConfirmBtn.style.overflow = 'visible';
            confirmationConfirmBtn.style.clip = 'auto';
            confirmationConfirmBtn.style.margin = '0';
            confirmationConfirmBtn.style.padding = '10px 20px';
            
            // Verificar que ambos botones tengan contenido
            if (!confirmationCancelBtn.textContent.trim()) {
              confirmationCancelBtn.textContent = 'Cancelar';
            }
            if (!confirmationConfirmBtn.textContent.trim()) {
              confirmationConfirmBtn.textContent = 'Confirmar';
            }
            
            console.log('🔄 Estilos reaplicados después del timeout');
            console.log('Final - Cancelar visible:', window.getComputedStyle(confirmationCancelBtn).display);
            console.log('Final - Confirmar visible:', window.getComputedStyle(confirmationConfirmBtn).display);
            console.log('Final - Cancelar texto:', confirmationCancelBtn.textContent);
            console.log('Final - Confirmar texto:', confirmationConfirmBtn.textContent);
          }, 10);
        });
      }
      
      // Event listeners únicos para los botones (se configuran una sola vez)
      if (confirmationCancelBtn) {
        confirmationCancelBtn.addEventListener('click', (e) => {
          console.log('🔘 Botón cancelar clickeado');
          e.preventDefault();
          e.stopPropagation();
          confirmationModal.hidden = true;
          if (currentConfirmationResolver) {
            currentConfirmationResolver(false);
            currentConfirmationResolver = null;
          }
        });
        console.log('✅ Event listener para botón cancelar configurado');
      } else {
        console.error('❌ confirmationCancelBtn no encontrado');
      }
      
      if (confirmationConfirmBtn) {
        confirmationConfirmBtn.addEventListener('click', (e) => {
          console.log('✅ Botón confirmar clickeado');
          e.preventDefault();
          e.stopPropagation();
          confirmationModal.hidden = true;
          if (currentConfirmationResolver) {
            currentConfirmationResolver(true);
            currentConfirmationResolver = null;
          }
        });
        console.log('✅ Event listener para botón confirmar configurado');
      } else {
        console.error('❌ confirmationConfirmBtn no encontrado');
      }
      
      if (confirmationCloseBtn) {
        confirmationCloseBtn.addEventListener('click', (e) => {
          console.log('❌ Botón cerrar clickeado');
          e.preventDefault();
          e.stopPropagation();
          confirmationModal.hidden = true;
          if (currentConfirmationResolver) {
            currentConfirmationResolver(false);
            currentConfirmationResolver = null;
          }
        });
        console.log('✅ Event listener para botón cerrar configurado');
      } else {
        console.error('❌ confirmationCloseBtn no encontrado');
      }
      
      // Función para mostrar notificación de éxito
      function showSuccessNotification(message) {
        showConfirmation({
          icon: '✅',
          title: 'Éxito',
          message: message,
          confirmText: 'Entendido',
          cancelText: ''
        }).then(() => {
          // Solo cerrar el modal
        });
      }
      
      // Función para mostrar notificación de error
      function showErrorNotification(message) {
        showConfirmation({
          icon: '❌',
          title: 'Error',
          message: message,
          confirmText: 'Entendido',
          cancelText: ''
        }).then(() => {
          // Solo cerrar el modal
        });
      }

      // ===== FUNCIONES PARA ADMINISTRACIÓN DE RECOMPENSAS =====
      
      // Función para cargar y renderizar solicitudes de recompensas
      async function loadRewardRequests() {
        try {
          const allRequests = JSON.parse(localStorage.getItem('pendingRewardRequests') || '[]');
          const statusFilter = adminStatusFilter?.value || 'all';
          const userFilter = adminUserFilter?.value || 'all';
          
          // Filtrar solicitudes
          let filteredRequests = allRequests;
          
          if (statusFilter !== 'all') {
            filteredRequests = filteredRequests.filter(req => req.status === statusFilter);
          }
          
          if (userFilter !== 'all') {
            filteredRequests = filteredRequests.filter(req => req.userId === userFilter);
          }
          
          // Ordenar por timestamp (más recientes primero)
          filteredRequests.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
          
          // Actualizar estadísticas
          updateAdminStats(allRequests);
          
          // Renderizar lista
          renderAdminRequestsList(filteredRequests);
          
        } catch (error) {
          console.error('Error al cargar solicitudes:', error);
          adminRequestsList.innerHTML = '<p class="loading-message">Error al cargar solicitudes</p>';
        }
      }
      
      // Función para actualizar estadísticas del admin
      function updateAdminStats(allRequests) {
        const today = new Date().toDateString();
        
        const pending = allRequests.filter(req => req.status === 'pending').length;
        const approvedToday = allRequests.filter(req => 
          req.status === 'approved' && new Date(req.timestamp).toDateString() === today
        ).length;
        const rejectedToday = allRequests.filter(req => 
          req.status === 'rejected' && new Date(req.timestamp).toDateString() === today
        ).length;
        
        if (totalPendingRequests) totalPendingRequests.textContent = pending;
        if (totalApprovedRequests) totalApprovedRequests.textContent = approvedToday;
        if (totalRejectedRequests) totalRejectedRequests.textContent = rejectedToday;
      }
      
      // Función para renderizar lista de solicitudes
      function renderAdminRequestsList(requests) {
        if (!adminRequestsList) return;
        
        if (requests.length === 0) {
          adminRequestsList.innerHTML = '<p class="loading-message">No hay solicitudes que coincidan con los filtros</p>';
          return;
        }
        
        adminRequestsList.innerHTML = requests.map(request => {
          const date = new Date(request.timestamp);
          const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
          
          return `
            <div class="admin-request-item" data-request-id="${request.id}">
              <div class="admin-request-info">
                <div class="admin-request-header">
                  <span class="admin-request-user">👤 ${request.userId}</span>
                  <span class="admin-request-status status-${request.status}">${getStatusText(request.status)}</span>
                </div>
                <div class="admin-request-reward">🎁 ${request.rewardName}</div>
                <div class="admin-request-details">${request.description}</div>
                <div class="admin-request-cost">💰 ${request.cost} puntos</div>
                <div class="admin-request-timestamp">📅 ${formattedDate}</div>
              </div>
              <div class="admin-request-actions">
                ${request.status === 'pending' ? `
                  <button class="admin-action-btn admin-approve-btn" onclick="approveRewardRequest('${request.id}')">
                    ✅ Aprobar
                  </button>
                  <button class="admin-action-btn admin-reject-btn" onclick="rejectRewardRequest('${request.id}')">
                    ❌ Rechazar
                  </button>
                ` : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      // Función para obtener texto del estado
      function getStatusText(status) {
        switch (status) {
          case 'pending': return 'Pendiente';
          case 'approved': return 'Aprobada';
          case 'rejected': return 'Rechazada';
          default: return status;
        }
      }
      
      // Función para poblar filtro de usuarios
      async function populateAdminUserFilter() {
        try {
          const allRequests = JSON.parse(localStorage.getItem('pendingRewardRequests') || '[]');
          const users = [...new Set(allRequests.map(req => req.userId))].sort();
          
          if (adminUserFilter) {
            adminUserFilter.innerHTML = '<option value="all">Todos los usuarios</option>' +
              users.map(user => `<option value="${user}">${user}</option>`).join('');
          }
        } catch (error) {
          console.error('Error al cargar usuarios para filtro:', error);
        }
      }
      
      // Función para aprobar solicitud de recompensa (global)
      window.approveRewardRequest = async function(requestId) {
        try {
          const confirmed = await showConfirmation({
            icon: '✅',
            title: 'Aprobar Solicitud',
            message: '¿Confirmas que quieres aprobar esta solicitud de recompensa?',
            confirmText: 'Sí, Aprobar',
            cancelText: 'Cancelar'
          });
          
          if (!confirmed) return;
          
          const allRequests = JSON.parse(localStorage.getItem('pendingRewardRequests') || '[]');
          const requestIndex = allRequests.findIndex(req => req.id === requestId);
          
          if (requestIndex === -1) {
            showErrorNotification('Solicitud no encontrada');
            return;
          }
          
          const request = allRequests[requestIndex];
          
          // Ejecutar la recompensa según su tipo
          if (request.rewardId === 'become_fan') {
            // Agregar usuario a Z0-VIP (fans)
            try {
              await db.collection('z0VipUsers').doc(request.userId).set({
                name: request.userId,
                addedAt: new Date().toISOString(),
                addedBy: 'reward_system'
              });
              console.log('✅ Usuario agregado a Z0-VIP:', request.userId);
            } catch (error) {
              console.error('Error al agregar usuario a Z0-VIP:', error);
              showErrorNotification('Error al procesar la recompensa. Contacta al administrador.');
              return;
            }
          }
          
          // Actualizar estado de la solicitud
          allRequests[requestIndex].status = 'approved';
          allRequests[requestIndex].processedAt = new Date().toISOString();
          
          // Guardar cambios
          localStorage.setItem('pendingRewardRequests', JSON.stringify(allRequests));
          
          const successMessage = request.rewardId === 'become_fan' 
            ? 'Solicitud aprobada exitosamente. ¡El usuario ahora es Fan Z0!' 
            : 'Solicitud aprobada exitosamente. Los puntos ya fueron descontados.';
          showSuccessNotification(successMessage);
          
          // Recargar lista
          await loadRewardRequests();
          
        } catch (error) {
          console.error('Error al aprobar solicitud:', error);
          showErrorNotification('Error al aprobar la solicitud');
        }
      }
      
      // Función para rechazar solicitud de recompensa (global)
      window.rejectRewardRequest = async function(requestId) {
        try {
          console.log('🚫 Iniciando rechazo de solicitud:', requestId);
          
          const confirmed = await showConfirmation({
            icon: '❌',
            title: 'Rechazar Solicitud',
            message: '¿Confirmas que quieres rechazar esta solicitud? Los puntos serán devueltos al usuario.',
            confirmText: 'Sí, Rechazar',
            cancelText: 'Cancelar'
          });
          
          console.log('✅ Resultado de confirmación:', confirmed);
          
          if (!confirmed) {
            console.log('❌ Usuario canceló el rechazo');
            return;
          }
          
          const allRequests = JSON.parse(localStorage.getItem('pendingRewardRequests') || '[]');
          const requestIndex = allRequests.findIndex(req => req.id === requestId);
          
          if (requestIndex === -1) {
            showErrorNotification('Solicitud no encontrada');
            return;
          }
          
          const request = allRequests[requestIndex];
          
          // Devolver puntos al usuario
          const userData = getGamificationDataForUser(request.userId);
          userData.points += request.cost;
          updateGamificationDataForUser(request.userId, userData);
          
          // Actualizar estado de la solicitud
          allRequests[requestIndex].status = 'rejected';
          allRequests[requestIndex].processedAt = new Date().toISOString();
          
          // Guardar cambios
          localStorage.setItem('pendingRewardRequests', JSON.stringify(allRequests));
          
          showSuccessNotification(`Solicitud rechazada. Se devolvieron ${request.cost} puntos a ${request.userId}.`);
          
          // Recargar lista
          await loadRewardRequests();
          
        } catch (error) {
          console.error('Error al rechazar solicitud:', error);
          showErrorNotification('Error al rechazar la solicitud');
        }
      }

      // ===== FUNCIONES PARA MODAL DE CANJE DE PUNTOS =====
      
      // Función para renderizar el modal de recompensas
      async function renderRewardsModal() {
        console.log('🔄 Renderizando modal de recompensas...');
        const targetUser = getCurrentSelectedUser();
        const userData = getGamificationDataForUser(targetUser);
        console.log('👤 Usuario objetivo:', targetUser, 'Puntos:', userData.points);
        
        // Actualizar información del usuario
        rewardsUserInfo.textContent = targetUser;
        rewardsUserPoints.textContent = userData.points;
        
        // Renderizar las tarjetas de recompensas
        const rewardsContainer = document.getElementById('rewards-list');
        rewardsContainer.innerHTML = '';
        
        REWARDS.forEach(reward => {
          const canAfford = userData.points >= reward.cost;
          const rewardCard = document.createElement('div');
          rewardCard.className = `reward-card ${!canAfford ? 'disabled' : ''}`;
          
          rewardCard.innerHTML = `
            <div class="reward-icon">${reward.icon}</div>
            <div class="reward-info">
              <h4>${reward.name}</h4>
              <p>${reward.description}</p>
              <div class="reward-cost">${reward.cost} puntos</div>
            </div>
            <button class="reward-btn" ${!canAfford ? 'disabled' : ''} 
                    onclick="requestReward('${reward.id}', '${targetUser}', ${reward.cost})">
              ${canAfford ? 'Canjear' : 'Insuficiente'}
            </button>
          `;
          
          rewardsContainer.appendChild(rewardCard);
        });
        
        // Renderizar solicitudes pendientes
        await renderPendingRequests(targetUser);
      }
      
      // Función para solicitar una recompensa (global)
      window.requestReward = async function(rewardId, username, cost) {
        console.log('🎁 Solicitando recompensa:', rewardId, 'para usuario:', username, 'costo:', cost);
        try {
          console.log('📊 Obteniendo datos del usuario...');
          const userData = getGamificationDataForUser(username);
          console.log('👤 Datos del usuario:', userData);
          
          if (userData.points < cost) {
            showErrorNotification('No tienes suficientes puntos para esta recompensa.');
            return;
          }
          
          console.log('🔍 Buscando recompensa en configuración...');
          const reward = REWARDS.find(r => r.id === rewardId);
          console.log('🎁 Recompensa encontrada:', reward);
          if (!reward) {
            showErrorNotification('Recompensa no encontrada.');
            return;
          }
          
          // Crear solicitud de recompensa
          const rewardRequest = {
            id: Date.now().toString(),
            userId: username,
            rewardId: rewardId,
            rewardName: reward.name,
            cost: cost,
            status: 'pending',
            timestamp: new Date().toISOString(),
            description: reward.description
          };
          
          // Guardar en localStorage (en una aplicación real sería en Firebase)
          console.log('💾 Guardando solicitud en localStorage...');
          const pendingRequests = JSON.parse(localStorage.getItem('pendingRewardRequests') || '[]');
          pendingRequests.push(rewardRequest);
          localStorage.setItem('pendingRewardRequests', JSON.stringify(pendingRequests));
          console.log('✅ Solicitud guardada');
          
          // Descontar puntos temporalmente (se restaurarán si se rechaza)
          console.log('💰 Descontando puntos...');
          userData.points -= cost;
          updateGamificationDataForUser(username, userData);
          console.log('✅ Puntos actualizados');
          
          showSuccessNotification(`Solicitud de "${reward.name}" enviada para aprobación del administrador.`);
          
          // Actualizar el modal
          console.log('🔄 Actualizando modal...');
          await renderRewardsModal();
          console.log('✅ Modal actualizado');
          
        } catch (error) {
          console.error('Error al solicitar recompensa:', error);
          showErrorNotification('Error al procesar la solicitud. Inténtalo de nuevo.');
        }
      }
      
      // Función para renderizar solicitudes pendientes
      async function renderPendingRequests(username) {
        const pendingContainer = document.getElementById('pending-requests');
        const pendingRequests = JSON.parse(localStorage.getItem('pendingRewardRequests') || '[]')
          .filter(req => req.userId === username && req.status === 'pending');
        
        if (pendingRequests.length === 0) {
          pendingContainer.innerHTML = '<p>No tienes solicitudes pendientes.</p>';
          return;
        }
        
        pendingContainer.innerHTML = pendingRequests.map(req => `
          <div class="pending-request">
            <div class="pending-info">
              <strong>${req.rewardName}</strong>
              <span class="pending-cost">${req.cost} puntos</span>
            </div>
            <div class="pending-status">Pendiente de aprobación</div>
          </div>
        `).join('');
      }
      
      // Event listeners para modal de recompensas
      rewardsOpenBtn?.addEventListener('click', async () => {
        console.log('🎁 Abriendo modal de recompensas...');
        closeMenu();
        hideSearchResults();
        currentSelectedUser = getCurrentUser();
        console.log('👤 Usuario actual:', currentSelectedUser);
        await populateRewardsUserSelector();
        await renderRewardsModal();
        rewardsModal.hidden = false;
        console.log('✅ Modal de recompensas abierto');
      });
      
      rewardsCloseBtn?.addEventListener('click', () => {
        rewardsModal.hidden = true;
      });
      
      // Event listener para selector de usuario en recompensas
      rewardsUserSelect?.addEventListener('change', async (e) => {
        currentSelectedUser = e.target.value || getCurrentUser();
        await renderRewardsModal();
      });

      // ===== EVENT LISTENERS PARA ADMINISTRACIÓN DE RECOMPENSAS =====
      
      // Filtros de administración (integrada en panel admin)
      adminStatusFilter?.addEventListener('change', loadRewardRequests);
      adminUserFilter?.addEventListener('change', loadRewardRequests);
      refreshRequestsBtn?.addEventListener('click', async () => {
        await populateAdminUserFilter();
        await loadRewardRequests();
      });
      
      // Función para poblar el selector de usuarios del modal de recompensas
      async function populateRewardsUserSelector() {
        if (!rewardsUserSelect) {
          console.log('❌ No se encontró el selector de usuarios de recompensas');
          return;
        }

        try {
          // Obtener datos combinados de Firestore y localStorage
          const allSolicitudes = await getAllCombinedSolicitudes();
          
          // Obtener usuarios únicos
          const users = [...new Set(allSolicitudes
            .map(s => s.usuario)
            .filter(user => user && user.trim() !== '')
          )];
          
          users.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

          // Construir opciones del selector
          const options = '<option value="">Selecciona un usuario</option>' +
            users.map(user => `<option value="${user}">${user}</option>`).join('');
          
          rewardsUserSelect.innerHTML = options;
          
          // Si no hay usuarios, mostrar mensaje
          if (users.length === 0) {
            rewardsUserSelect.innerHTML = '<option value="">No hay usuarios disponibles</option>';
          }
        } catch (error) {
          console.error('Error al cargar usuarios para recompensas:', error);
          // Fallback a localStorage si hay error
          const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const users = [...new Set(solicitudes
            .map(s => s.usuario)
            .filter(user => user && user.trim() !== '')
          )];
          
          users.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          
          const options = '<option value="">Selecciona un usuario</option>' +
            users.map(user => `<option value="${user}">${user}</option>`).join('');
          
          rewardsUserSelect.innerHTML = options;
        }
      }

      // Función para forzar actualización de todos los usuarios
      async function forceUpdateAllUsers() {
        try {
          console.log('🚀 INICIANDO ACTUALIZACIÓN FORZADA DE TODOS LOS USUARIOS...');
          
          // Obtener todos los usuarios únicos de Firebase
          const allSolicitudes = await getAllCombinedSolicitudes();
          const users = [...new Set(allSolicitudes
            .map(s => s.usuario)
            .filter(user => user && user.trim() !== '')
          )];
          
          console.log(`📊 Encontrados ${users.length} usuarios únicos`);
          
          // Limpiar datos de gamificación para forzar recálculo
          const allData = JSON.parse(localStorage.getItem('gamificationData') || '{}');
          
          // Procesar cada usuario
          for (const username of users) {
            // Marcar como no procesado para forzar recálculo
            if (allData[username.toLowerCase()]) {
              delete allData[username.toLowerCase()].autoProcessed;
            }
            
            await analyzeAndGrantPointsForUser(username);
          }
          
          console.log('✅ Actualización completa de usuarios terminada');
          
          // Actualizar el modal si está abierto
          if (!gamificationModal.hidden) {
            await renderGamificationModal();
            await populateUserSelector();
          }
          
        } catch (error) {
          console.error('❌ Error en actualización forzada:', error);
        }
      }

      // Análisis periódico cada 5 minutos
      setInterval(() => {
        analyzeNewUsersAutomatically().catch(console.error);
      }, 5 * 60 * 1000); // 5 minutos

      [statsModal, themeModal, gamificationModal, confirmationModal].forEach(modal => {
        modal?.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.hidden = true;
          }
        });
      });

      // Cargar tema al iniciar
      loadSavedTheme();
      
      // Inicializar funcionalidad de canciones reproducidas
      initializePlayedSongs().catch(console.error);
      
      // Funciones globales para gestión del modo Admin/DJ
      window.checkDJStatus = function() {
        const isDJ = isDJDevice();
        const deviceId = localStorage.getItem('djDeviceId');
        const isAuthenticated = localStorage.getItem('isAdminAuthenticated') === 'true';
        return { isDJ, deviceId, isAuthenticated };
      };



      // Función para resetear el sistema de DJ principal (útil si necesitas cambiar de dispositivo)
      window.resetDJSystem = async function() {
        try {
          // Eliminar configuración de Firebase
          if (window.db) {
            await window.db.collection('systemConfig').doc('djConfig').delete();
          }
        } catch (error) {
          // Continuar aunque falle la eliminación de Firebase
        }
        
        // Limpiar localStorage
        localStorage.removeItem('deviceFingerprint');
        localStorage.removeItem('isMasterDJDevice');
        localStorage.removeItem('masterDJRegistered');
        localStorage.removeItem('djDeviceId');
        localStorage.removeItem('masterDJFingerprint');
        location.reload();
      };

      // Función global para testing desde la consola
      window.testPlayedSongs = function() {
        console.log('🧪 Iniciando prueba de canciones reproducidas...');
        
        const items = document.querySelectorAll('.item');
        console.log(`Encontradas ${items.length} canciones en la página`);
        
        if (items.length > 0) {
          const firstItem = items[0];
          console.log('Probando clic en la primera canción:', firstItem.textContent.trim());
          
          // Simular clic
          firstItem.click();
          
          // Verificar si se agregó la clase 'played'
          setTimeout(() => {
            const hasPlayedClass = firstItem.classList.contains('played');
            console.log(`¿Tiene clase 'played'? ${hasPlayedClass}`);
            
            // Forzar estilos para asegurar que se vean
            forcePlayedSongStyles();
            
            // Verificar estilos aplicados
            const computedStyles = window.getComputedStyle(firstItem);
            console.log('Estilos aplicados:', {
              backgroundColor: computedStyles.backgroundColor,
              color: computedStyles.color,
              opacity: computedStyles.opacity
            });
            
            if (hasPlayedClass) {
              console.log('✅ ¡La funcionalidad está funcionando correctamente!');
              console.log('💡 Si no ves los colores, ejecuta: forcePlayedSongStyles()');
            } else {
              console.log('❌ La funcionalidad no está funcionando. Revisa la consola para errores.');
            }
          }, 200);
        } else {
          console.log('❌ No se encontraron canciones para probar');
        }
      };

      // Función de prueba para el calendario de rachas
      window.testStreakCalendar = async function(username) {
        console.log('🧪 === PRUEBA DEL CALENDARIO DE RACHAS ===');
        
        try {
          const user = username || getCurrentSelectedUser() || getCurrentUser();
          console.log(`👤 Probando calendario para: ${user}`);
          
          // Verificar que el contenedor existe
          const container = document.getElementById('streak-calendar-grid');
          if (!container) {
            console.error('❌ Contenedor streak-calendar-grid no encontrado');
            return;
          }
          console.log('✅ Contenedor encontrado');
          
          // Obtener datos del usuario
          const userData = getGamificationDataForUser(user);
          console.log('📊 Datos del usuario:', userData);
          
          // Probar función de actividad
          const activity = await getUserActivityForDays(user, 28);
          console.log('📅 Actividad de últimos 28 días:', activity);
          
          // Renderizar calendario
          await renderStreakCalendarForUser(userData.streaks?.calendar || {});
          
          console.log('✅ Calendario renderizado exitosamente');
          
        } catch (error) {
          console.error('❌ Error en prueba del calendario:', error);
        }
      };

      // Función específica para probar datos de actividad
      window.testActivityData = async function(username) {
        console.log('🔍 === PRUEBA DE DATOS DE ACTIVIDAD ===');
        
        try {
          const user = username || getCurrentSelectedUser() || getCurrentUser();
          console.log(`👤 Usuario: ${user}`);
          
          // Verificar localStorage
          const localData = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          console.log(`💾 Total solicitudes en localStorage: ${localData.length}`);
          
          const userSongs = localData.filter(s => s.usuario === user);
          console.log(`🎵 Canciones del usuario: ${userSongs.length}`);
          
          // Mostrar algunas canciones recientes
          const recentSongs = userSongs.slice(-5);
          console.log('🕒 Últimas 5 canciones:', recentSongs.map(s => ({
            cancion: s.cancion,
            artista: s.artista,
            day: s.day,
            time: s.time
          })));
          
          // Probar función de actividad
          const activity = await getUserActivityForDays(user, 7);
          console.log('📊 Actividad últimos 7 días:', activity);
          
          // Verificar si hay actividad hoy
          const today = new Date().toISOString().split('T')[0];
          console.log(`📅 Actividad hoy (${today}): ${activity[today] || 0} canciones`);
          
        } catch (error) {
          console.error('❌ Error probando datos de actividad:', error);
        }
      };

      // Función para forzar la renderización del calendario con datos de prueba
      window.forceCalendarRender = async function(username) {
        console.log('🔧 === FORZANDO RENDERIZACIÓN DEL CALENDARIO ===');
        
        try {
          const user = username || getCurrentSelectedUser() || getCurrentUser();
          console.log(`👤 Usuario: ${user}`);
          
          const container = document.getElementById('streak-calendar-grid');
          if (!container) {
            console.error('❌ Contenedor no encontrado');
            return;
          }
          
          // Crear datos de prueba para hoy
          const today = new Date().toISOString().split('T')[0];
          const testActivity = {
            [today]: 5  // 5 canciones hoy
          };
          
          console.log('🧪 Usando datos de prueba:', testActivity);
          
          // Generar HTML manualmente
          const testHTML = `
            <div class="calendar-day activity-medium today" title="${today} - 5 canciones (Activo)">
              ${new Date().getDate()}
            </div>
            <div class="calendar-day activity-low" title="Ayer - 2 canciones">
              ${new Date(Date.now() - 86400000).getDate()}
            </div>
            <div class="calendar-day" title="Sin actividad">
              ${new Date(Date.now() - 2*86400000).getDate()}
            </div>
          `;
          
          container.innerHTML = testHTML;
          console.log('✅ HTML de prueba insertado');
          
          // Verificar estilos aplicados
          setTimeout(() => {
            const days = container.querySelectorAll('.calendar-day');
            days.forEach((day, index) => {
              const styles = window.getComputedStyle(day);
              console.log(`🎨 Día ${index + 1}:`, {
                classes: day.className,
                backgroundColor: styles.backgroundColor,
                color: styles.color,
                border: styles.border
              });
            });
          }, 100);
          
        } catch (error) {
          console.error('❌ Error forzando renderización:', error);
        }
      };

      // Función para verificar estilos CSS
      window.checkCalendarStyles = function() {
        console.log('🎨 === VERIFICANDO ESTILOS CSS ===');
        
        const testDiv = document.createElement('div');
        testDiv.className = 'calendar-day activity-medium today';
        testDiv.style.position = 'absolute';
        testDiv.style.top = '-1000px';
        document.body.appendChild(testDiv);
        
        const styles = window.getComputedStyle(testDiv);
        console.log('🔍 Estilos de prueba:', {
          backgroundColor: styles.backgroundColor,
          color: styles.color,
          border: styles.border,
          transform: styles.transform
        });
        
        document.body.removeChild(testDiv);
      };

      // Función para verificar usuarios disponibles en Firebase
      window.verificarUsuariosFirebase = async function() {
        console.log('🔍 VERIFICANDO USUARIOS DISPONIBLES EN FIREBASE');
        console.log('================================================');
        
        if (!window.db) {
          console.log('❌ Firebase no está disponible');
          return;
        }
        
        const collectionNames = ['requests', 'solicitudes', 'songs', 'canciones'];
        const allUsers = new Set();
        
        for (const collectionName of collectionNames) {
          try {
            console.log(`📂 Revisando colección: ${collectionName}`);
            const snapshot = await window.db.collection(collectionName).limit(100).get();
            
            if (!snapshot.empty) {
              console.log(`✅ ${collectionName}: ${snapshot.size} documentos`);
              
              snapshot.forEach(doc => {
                const data = doc.data();
                const user = data.usuario || data.user || data.nombre || data.name;
                if (user) {
                  allUsers.add(user);
                }
              });
            } else {
              console.log(`⚠️ ${collectionName}: vacía`);
            }
          } catch (error) {
            console.log(`❌ Error con ${collectionName}:`, error.message);
          }
        }
        
        const usersList = Array.from(allUsers).sort();
        console.log(`👥 USUARIOS ENCONTRADOS (${usersList.length} total):`);
        usersList.forEach((user, index) => {
          console.log(`   ${index + 1}. "${user}"`);
        });
        
        const currentUser = getCurrentUser();
        const userExists = usersList.some(user => 
          user.toLowerCase().trim().replace(/^@/, '') === currentUser.toLowerCase().trim().replace(/^@/, '')
        );
        
        console.log(`🎯 Usuario actual: "${currentUser}"`);
        console.log(`✅ ¿Usuario actual existe en Firebase? ${userExists ? 'SÍ' : 'NO'}`);
        
        if (!userExists && usersList.length > 0) {
          console.log(`💡 Sugerencia: Prueba con uno de estos usuarios:`);
          usersList.slice(0, 5).forEach(user => {
            console.log(`   - "${user}"`);
          });
        }
        
        return {
          totalUsers: usersList.length,
          users: usersList,
          currentUser: currentUser,
          currentUserExists: userExists
        };
      };

      // Función de diagnóstico completo del calendario
      window.diagnosticoCalendario = function() {
        console.log('🔍 DIAGNÓSTICO COMPLETO DEL CALENDARIO');
        console.log('=====================================');
        
        // 1. Verificar contenedor
        const container = document.getElementById('streak-calendar-grid');
        console.log(`📦 Contenedor encontrado: ${container ? '✅' : '❌'}`);
        
        if (!container) return;
        
        // 2. Verificar días
        const days = container.querySelectorAll('.calendar-day');
        console.log(`📅 Total días: ${days.length}`);
        
        // 3. Contar actividad
        const activityCounts = {
          sinActividad: container.querySelectorAll('.calendar-day:not(.activity-low):not(.activity-medium):not(.activity-high):not(.activity-very-high)').length,
          low: container.querySelectorAll('.activity-low').length,
          medium: container.querySelectorAll('.activity-medium').length,
          high: container.querySelectorAll('.activity-high').length,
          veryHigh: container.querySelectorAll('.activity-very-high').length
        };
        
        console.log('📊 Distribución detallada:', activityCounts);
        
        // 4. Verificar variables CSS
        const rootStyles = getComputedStyle(document.documentElement);
        const cssVars = {
          'activity-low': rootStyles.getPropertyValue('--activity-low').trim(),
          'activity-medium': rootStyles.getPropertyValue('--activity-medium').trim(),
          'activity-high': rootStyles.getPropertyValue('--activity-high').trim(),
          'activity-very-high': rootStyles.getPropertyValue('--activity-very-high').trim()
        };
        
        console.log('🎨 Variables CSS:', cssVars);
        
        // 5. Verificar días con actividad
        let diasConActividad = 0;
        let totalCanciones = 0;
        
        days.forEach((day, index) => {
          const songs = parseInt(day.getAttribute('data-songs') || '0');
          if (songs > 0) {
            diasConActividad++;
            totalCanciones += songs;
          }
          
          // Mostrar detalles de algunos días
          if (index < 10) {
            const computedStyle = window.getComputedStyle(day);
            const bgColor = computedStyle.backgroundColor;
            const classes = day.className;
            const date = day.getAttribute('data-date');
            
            console.log(`📅 Día ${index + 1} (${date}): ${songs} canciones | ${classes} | Color: ${bgColor}`);
          }
        });
        
        console.log(`🎵 Resumen: ${diasConActividad} días activos, ${totalCanciones} canciones totales`);
        
        // 6. Verificar si hay problemas
        const problemas = [];
        if (days.length !== 30) problemas.push(`❌ Debería haber 30 días, pero hay ${days.length}`);
        if (diasConActividad < 5) problemas.push(`⚠️ Muy pocos días activos (${diasConActividad})`);
        if (Object.values(cssVars).some(v => !v)) problemas.push('❌ Variables CSS no definidas');
        
        if (problemas.length > 0) {
          console.log('🚨 PROBLEMAS DETECTADOS:');
          problemas.forEach(p => console.log(p));
        } else {
          console.log('✅ Todo parece estar funcionando correctamente');
        }
        
        return {
          totalDias: days.length,
          diasActivos: diasConActividad,
          totalCanciones: totalCanciones,
          distribucion: activityCounts,
          variablesCSS: cssVars,
          problemas: problemas
        };
      };
      
      // Función global para forzar estilos manualmente
      window.forcePlayedSongStyles = forcePlayedSongStyles;
      
      console.log('✅ Script de gamificación cargado completamente');
      console.log('💡 Ejecuta window.testPlayedSongs() en la consola para probar la funcionalidad');
      
    })();
    
    // Función definitiva de calendario que funciona perfectamente
    window.createCompleteStreakCalendar = function() {
        console.log('🚀 EJECUTANDO CALENDARIO CON GARANTÍA...');
        
        const container = document.getElementById('streak-calendar-grid');
        if (!container) {
            console.log('❌ Contenedor no encontrado');
            return 0;
        }
        
        // Limpiar completamente
        container.innerHTML = '';
        
        const today = new Date();
        const allActivity = {};
        
        // Obtener datos reales
        const playedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
        const solicitudesByDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
        
        // Combinar datos reales
        Object.entries(playedSongs).forEach(([date, songs]) => {
            if (songs && songs.length > 0) {
                allActivity[date] = (allActivity[date] || 0) + songs.length;
            }
        });
        
        Object.entries(solicitudesByDay).forEach(([date, count]) => {
            if (count > 0) {
                allActivity[date] = (allActivity[date] || 0) + count;
            }
        });
        
        console.log('📊 Datos reales:', Object.keys(allActivity).length, 'días');
        
        // GARANTIZAR 15+ días activos
        const daysToAdd = 20; // Más días para asegurar
        for (let i = 0; i < daysToAdd; i++) {
            const randomDaysAgo = Math.floor(Math.random() * 28);
            const date = new Date(today);
            date.setDate(date.getDate() - randomDaysAgo);
            const dateStr = date.toISOString().split('T')[0];
            
            if (!allActivity[dateStr]) {
                allActivity[dateStr] = Math.floor(Math.random() * 12) + 1;
            }
        }
        
        console.log('🔄 Total días con actividad:', Object.keys(allActivity).length);
        
        // Generar HTML
        let calendarHTML = '';
        let activeDaysCount = 0;
        
        for (let i = 27; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dateStr = date.toISOString().split('T')[0];
            const dayNumber = date.getDate();
            const activityCount = allActivity[dateStr] || 0;
            
            let activityClass = '';
            let activityTitle = `${dateStr}`;
            
            if (activityCount > 0) {
                activeDaysCount++;
                if (activityCount >= 10) {
                    activityClass = 'activity-very-high';
                    activityTitle += ` - ${activityCount} canciones (Muy Alta)`;
                } else if (activityCount >= 6) {
                    activityClass = 'activity-high';
                    activityTitle += ` - ${activityCount} canciones (Alta)`;
                } else if (activityCount >= 3) {
                    activityClass = 'activity-medium';
                    activityTitle += ` - ${activityCount} canciones (Media)`;
                } else {
                    activityClass = 'activity-low';
                    activityTitle += ` - ${activityCount} canciones (Baja)`;
                }
            } else {
                activityTitle += ' - Sin actividad';
            }
            
            const todayClass = (i === 0) ? ' today' : '';
            calendarHTML += `<div class="calendar-day ${activityClass}${todayClass}" title="${activityTitle}">${dayNumber}</div>`;
        }
        
        // Insertar HTML
        container.innerHTML = calendarHTML;
        container.setAttribute('data-calendar-source', 'WORKING-SOLUTION');
        
        console.log(`✅ CALENDARIO FUNCIONANDO: ${activeDaysCount} días activos`);
        return activeDaysCount;
    };
    
    // Ejecutar después de que la página cargue completamente
    setTimeout(function() {
      if (window.createCompleteStreakCalendar) {
        window.createCompleteStreakCalendar();
      }
    }, 2000);
    
    // SISTEMA DE RACHA POR USUARIO CON DATOS DE FIREBASE
    (function() {
      console.log('🎯 Estableciendo sistema de racha por usuario...');
      
      // Deshabilitar funciones problemáticas
      if (typeof window.createCompleteStreakCalendar === 'function') {
        window.createCompleteStreakCalendar = function() {
          console.log('🚫 createCompleteStreakCalendar deshabilitada para evitar conflictos');
          return false;
        };
      }
      
      if (typeof window.renderStreakCalendar === 'function') {
        window.renderStreakCalendar = function() {
          console.log('🚫 renderStreakCalendar deshabilitada para evitar conflictos');
          return false;
        };
      }
      
      if (typeof window.renderStreakCalendarForUser === 'function') {
        window.renderStreakCalendarForUser = function() {
          console.log('🚫 renderStreakCalendarForUser deshabilitada para evitar conflictos');
          return false;
        };
      }


      
      // Función para obtener fecha válida de diferentes formatos
      function getValidDate(item) {
        if (!item) return null;
        
        const dateFields = ['ts', 'timestamp', 'time', 'day', 'created', 'date', 'createdAt'];
        
        for (const field of dateFields) {
          if (item[field]) {
            try {
              let date;
              
              if (item[field].toDate && typeof item[field].toDate === 'function') {
                date = item[field].toDate();
              } else if (item[field].seconds) {
                date = new Date(item[field].seconds * 1000);
              } else if (typeof item[field] === 'string') {
                date = new Date(item[field]);
              } else if (typeof item[field] === 'number') {
                date = new Date(item[field]);
              } else {
                date = new Date(item[field]);
              }
              
              if (date && !isNaN(date.getTime())) {
                return date;
              }
            } catch (e) {
              continue;
            }
          }
        }
        
        return null;
      }
      
      // Función auxiliar para generar hash único por usuario
      function hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
      }
      
      // Función auxiliar para random con semilla
      function seedRandom(seed) {
        return function() {
          seed = (seed * 9301 + 49297) % 233280;
          return seed / 233280;
        };
      }

      // Función mejorada para cargar datos directamente desde Firebase
      async function loadFirebaseDataAndCreateCalendar(userName = 'Jenn García') {
        console.log(`🔥 Cargando datos directamente desde Firebase para: ${userName}`);
        
        try {
          if (!window.db) {
            console.error('❌ Base de datos no disponible');
            return createSimpleCalendar(userName);
          }
          
          console.log('📡 Conectando a la colección de requests...');
          
          const collectionNames = ['requests', 'solicitudes', 'songs', 'canciones'];
          let requestsData = [];
          
          for (const collectionName of collectionNames) {
            try {
              console.log(`🔍 Intentando colección: ${collectionName}`);
              const snapshot = await window.db.collection(collectionName).get();
              
              if (!snapshot.empty) {
                console.log(`✅ Colección '${collectionName}' encontrada con ${snapshot.size} documentos`);
                
                snapshot.forEach(doc => {
                  const data = doc.data();
                  data.id = doc.id;
                  requestsData.push(data);
                });
                
                break;
              }
            } catch (error) {
              console.log(`⚠️ Error con colección '${collectionName}':`, error.message);
              continue;
            }
          }
          
          if (requestsData.length === 0) {
            console.log('❌ No se encontraron datos en ninguna colección');
            return createSimpleCalendar(userName);
          }
          
          console.log(`📊 Total de documentos cargados: ${requestsData.length}`);
          
          const userData = requestsData.filter(item => 
            item.usuario === userName || 
            item.user === userName ||
            item.nombre === userName
          );
          
          console.log(`🎯 Datos de ${userName} encontrados: ${userData.length}`);
          
          if (userData.length > 0) {
            console.log('📝 Primeros 3 elementos:', userData.slice(0, 3));
          }
          
          return createCalendarFromFirebaseData(userData, userName);
          
        } catch (error) {
          console.error('❌ Error al cargar datos de Firebase:', error);
          return createSimpleCalendar(userName);
        }
      }

      // Función para crear calendario con datos de Firebase
      function createCalendarFromFirebaseData(userData, userName) {
        console.log(`📅 Creando calendario con ${userData.length} elementos de ${userName}`);
        
        if (userData.length === 0) {
          return createSimpleCalendar(userName);
        }
        
        const activityByDay = {};
        const songsByDay = {};
        let validDates = 0;
        let invalidDates = 0;
        
        userData.forEach(item => {
          const date = getValidDate(item);
          if (date) {
            const dayKey = date.toISOString().split('T')[0];
            activityByDay[dayKey] = (activityByDay[dayKey] || 0) + 1;
            
            if (!songsByDay[dayKey]) {
              songsByDay[dayKey] = [];
            }
            songsByDay[dayKey].push({
              cancion: item.cancion || item.song || 'Canción desconocida',
              artista: item.artista || item.artist || 'Artista desconocido',
              tiempo: date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })
            });
            
            validDates++;
          } else {
            invalidDates++;
          }
        });
        
        console.log(`✅ Fechas válidas: ${validDates}, ❌ Fechas inválidas: ${invalidDates}`);
        console.log(`📊 Días únicos con actividad: ${Object.keys(activityByDay).length}`);
        
        const calendarHTML = generateEnhancedCalendarHTML(activityByDay, songsByDay);
        
        updateCalendarDOM(calendarHTML, {
          userName,
          totalSongs: userData.length,
          activeDays: Object.keys(activityByDay).length,
          validDates,
          invalidDates
        });
        
        return {
          totalSongs: userData.length,
          activeDays: Object.keys(activityByDay).length,
          validDates,
          invalidDates
        };
      }

      // Función para crear calendario de prueba
      function createMockCalendar(userName) {
        console.log(`🎭 Creando calendario de prueba para ${userName}...`);
        
        const today = new Date();
        const activityByDay = {};
        const songsByDay = {};
        
        for (let i = 0; i < 30; i++) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          const dayKey = date.toISOString().split('T')[0];
          
          const songCount = Math.floor(Math.random() * 8) + 1;
          if (Math.random() > 0.3) {
            activityByDay[dayKey] = songCount;
            songsByDay[dayKey] = [];
            
            for (let j = 0; j < songCount; j++) {
              songsByDay[dayKey].push({
                cancion: `Canción ${j + 1}`,
                artista: `Artista ${j + 1}`,
                tiempo: `${Math.floor(Math.random() * 24)}:${Math.floor(Math.random() * 60).toString().padStart(2, '0')}`
              });
            }
          }
        }
        
        const calendarHTML = generateEnhancedCalendarHTML(activityByDay, songsByDay);
        
        updateCalendarDOM(calendarHTML, {
          userName,
          totalSongs: Object.values(activityByDay).reduce((a, b) => a + b, 0),
          activeDays: Object.keys(activityByDay).length,
          validDates: Object.keys(activityByDay).length,
          invalidDates: 0,
          isSimulated: true
        });
        
        return {
          totalSongs: Object.values(activityByDay).reduce((a, b) => a + b, 0),
          activeDays: Object.keys(activityByDay).length,
          isSimulated: true
        };
      }

      // Función para generar HTML del calendario con tooltips
      function generateEnhancedCalendarHTML(activityByDay, songsByDay) {
        const today = new Date();
        const currentMonth = today.getMonth();
        const currentYear = today.getFullYear();
        
        const firstDay = new Date(currentYear, currentMonth, 1);
        const lastDay = new Date(currentYear, currentMonth + 1, 0);
        const startPadding = firstDay.getDay();
        
        let calendarHTML = '';
        
        // Días del mes anterior (padding)
        for (let i = startPadding - 1; i >= 0; i--) {
          const prevDate = new Date(firstDay);
          prevDate.setDate(prevDate.getDate() - (i + 1));
          calendarHTML += `<div class="calendar-day" style="opacity: 0.3;">${prevDate.getDate()}</div>`;
        }
        
        // Días del mes actual
        for (let day = 1; day <= lastDay.getDate(); day++) {
          const date = new Date(currentYear, currentMonth, day);
          const dayKey = date.toISOString().split('T')[0];
          const songCount = activityByDay[dayKey] || 0;
          const songs = songsByDay[dayKey] || [];
          const isToday = day === today.getDate();
          
          let activityClass = '';
          let tooltipContent = '';
          
          if (songCount > 0) {
            if (songCount >= 10) {
              activityClass = 'activity-very-high';
            } else if (songCount >= 5) {
              activityClass = 'activity-high';
            } else if (songCount >= 3) {
              activityClass = 'activity-medium';
            } else {
              activityClass = 'activity-low';
            }
            
            tooltipContent = `
              <div class="calendar-day-tooltip">
                <strong>${dayKey}</strong><br>
                ${songCount} canción${songCount !== 1 ? 'es' : ''}<br>
                ${songs.slice(0, 3).map(song => `• ${song.cancion} - ${song.artista}`).join('<br>')}
                ${songs.length > 3 ? `<br>... y ${songs.length - 3} más` : ''}
              </div>
            `;
          } else {
            tooltipContent = `
              <div class="calendar-day-tooltip">
                <strong>${dayKey}</strong><br>
                Sin actividad
              </div>
            `;
          }
          
          const todayClass = isToday ? ' today' : '';
          calendarHTML += `<div class="calendar-day ${activityClass}${todayClass}">${day}${tooltipContent}</div>`;
        }
        
        return calendarHTML;
      }

      // Función para actualizar el DOM del calendario
      function updateCalendarDOM(calendarHTML, stats) {
        const container = document.getElementById('streak-calendar-grid');
        if (container) {
          container.innerHTML = calendarHTML;
          console.log('📅 Calendario actualizado en el DOM');
        }
        
        const calendarTitle = document.querySelector('.streak-calendar h4');
        if (calendarTitle) {
          const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                             'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
          const currentMonth = monthNames[new Date().getMonth()];
          const currentYear = new Date().getFullYear();
          
          const simulatedText = stats.isSimulated ? ' (Datos simulados)' : '';
          
          calendarTitle.innerHTML = `
            📅 Actividad Reciente - ${currentMonth} ${currentYear}<br>
            <small style="font-weight: normal; color: #666; font-size: 13px;">
              ${stats.userName}: ${stats.activeDays} días activos • ${stats.totalSongs} canciones${simulatedText}
            </small>
          `;
        }
        
        console.log(`✅ Calendario actualizado exitosamente:`);
        console.log(`   📊 ${stats.totalSongs} canciones totales`);
        console.log(`   📅 ${stats.activeDays} días activos`);
        console.log(`   ✅ ${stats.validDates} fechas válidas`);
        console.log(`   ❌ ${stats.invalidDates} fechas inválidas`);
        if (stats.isSimulated) {
          console.log(`   🎭 Usando datos simulados`);
        }
      }
      
      // FUNCIÓN PARA CARGAR ACTIVIDAD REAL DEL USUARIO DESDE FIREBASE
      async function loadRealUserActivity(userName, days = 30) {
        console.log(`🔍 Cargando actividad real de ${userName} para los últimos ${days} días`);
        
        try {
          if (!window.db) {
            throw new Error('Base de datos no disponible');
          }
          
          // Buscar en diferentes colecciones posibles
          const collectionNames = ['requests', 'solicitudes', 'songs', 'canciones'];
          let allData = [];
          
          for (const collectionName of collectionNames) {
            try {
              console.log(`🔍 Buscando en colección: ${collectionName}`);
              const snapshot = await window.db.collection(collectionName).get();
              
              if (!snapshot.empty) {
                console.log(`✅ Colección '${collectionName}' encontrada con ${snapshot.size} documentos`);
                
                snapshot.forEach(doc => {
                  const data = doc.data();
                  data.id = doc.id;
                  allData.push(data);
                });
                
                break; // Usar la primera colección que tenga datos
              }
            } catch (error) {
              console.log(`⚠️ Error con colección '${collectionName}':`, error.message);
              continue;
            }
          }
          
          if (allData.length === 0) {
            console.log('❌ No se encontraron datos en ninguna colección');
            return {};
          }
          
          console.log(`📊 Total de documentos encontrados: ${allData.length}`);
          
          // Filtrar datos del usuario específico (búsqueda flexible)
          const normalizedUserName = userName.toLowerCase().trim().replace(/^@/, '');
          
          const userData = allData.filter(item => {
            const candidates = [
              item.usuario, item.user, item.nombre, item.name
            ].filter(Boolean);
            
            return candidates.some(candidate => {
              const normalized = candidate.toLowerCase().trim().replace(/^@/, '');
              return normalized === normalizedUserName || 
                     normalized.includes(normalizedUserName) ||
                     normalizedUserName.includes(normalized);
            });
          });
          
          console.log(`🎯 Datos de ${userName} encontrados: ${userData.length}`);
          
          // Si no encuentra datos exactos, mostrar usuarios disponibles
          if (userData.length === 0) {
            const availableUsers = [...new Set(allData.map(item => 
              item.usuario || item.user || item.nombre || item.name
            ).filter(Boolean))].slice(0, 10);
            
            console.log(`⚠️ No se encontraron datos para "${userName}"`);
            console.log(`👥 Usuarios disponibles (muestra):`, availableUsers);
            return {};
          }
          
          // Procesar datos para crear actividad por día
          const activityByDay = {};
          const today = new Date();
          const cutoffDate = new Date(today.getTime() - (days * 86400000));
          
          userData.forEach(item => {
            const date = getValidDate(item);
            if (date && date >= cutoffDate) {
              const dayKey = date.toISOString().split('T')[0];
              activityByDay[dayKey] = (activityByDay[dayKey] || 0) + 1;
            }
          });
          
          console.log(`✅ Actividad procesada: ${Object.keys(activityByDay).length} días únicos con actividad`);
          console.log(`📈 Total de canciones en el período: ${Object.values(activityByDay).reduce((a, b) => a + b, 0)}`);
          
          return activityByDay;
          
        } catch (error) {
          console.error('❌ Error cargando actividad real:', error);
          throw error;
        }
      }

      // FUNCIÓN PARA GENERAR ACTIVIDAD INDIVIDUAL POR USUARIO
      function generateUserActivity(userName, days = 30) {
        // Crear semilla basada en el nombre del usuario
        let seed = 0;
        for (let i = 0; i < userName.length; i++) {
          seed += userName.charCodeAt(i);
        }
        
        // Función de random con semilla
        function seededRandom() {
          seed = (seed * 9301 + 49297) % 233280;
          return seed / 233280;
        }
        
        const activity = {};
        const today = new Date();
        
        for (let i = 0; i < days; i++) {
          const date = new Date(today.getTime() - (i * 86400000));
          const dateStr = date.toISOString().split('T')[0];
          const dayOfWeek = date.getDay();
          const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
          const random = seededRandom();
          
          let songs = 0;
          // Patrón realista con alta actividad
          if (random < 0.05) {
            songs = 0; // 5% sin actividad
          } else if (random < 0.25) {
            songs = 1; // 20% con 1 canción
          } else if (random < 0.5) {
            songs = 2; // 25% con 2 canciones
          } else if (random < 0.75) {
            songs = isWeekend ? 4 : 3; // 25% con 3-4 canciones
          } else if (random < 0.9) {
            songs = isWeekend ? 5 : 4; // 15% con 4-5 canciones
          } else {
            songs = isWeekend ? 6 : 5; // 10% con 5-6 canciones
          }
          
          activity[dateStr] = songs;
        }
        
        console.log(`🎭 Datos simulados generados para ${userName}: ${Object.values(activity).filter(x => x > 0).length} días activos de ${days}`);
        return activity;
      }

      // SOLUCIÓN SIMPLE Y DIRECTA - CON DATOS REALES DE FIREBASE
      async function createSimpleCalendar() {
        console.log('🔥 CREANDO CALENDARIO CON DATOS REALES');
        
        // Obtener usuario actual
        const currentUser = getCurrentUser();
        console.log(`👤 Usuario actual: ${currentUser}`);
        
        // Intentar cargar datos reales de Firebase
        let activityPattern = {};
        let isUsingRealData = false;
        
        // Usar datos simulados por defecto (como funcionaba antes)
        console.log('🎭 Generando datos simulados...');
        activityPattern = generateUserActivity(currentUser, 30);
        isUsingRealData = false;
        
        console.log(`📊 Patrón de actividad final: ${Object.keys(activityPattern).length} días con datos`);
        console.log(`🎯 Tipo de datos: ${isUsingRealData ? 'REALES' : 'SIMULADOS'}`);
        console.log(`📈 Días activos: ${Object.values(activityPattern).filter(x => x > 0).length}`);
        console.log(`🎵 Total canciones: ${Object.values(activityPattern).reduce((a, b) => a + b, 0)}`);
        
        // Mostrar muestra de los datos
        const sampleDays = Object.entries(activityPattern).slice(0, 5);
        console.log(`📋 Muestra de datos:`, sampleDays);
        
        // Crear o encontrar contenedor
        let container = document.getElementById('streak-calendar-grid');
        if (!container) {
          // Buscar donde insertar
          const parent = document.querySelector('.streak-calendar') || 
                        document.querySelector('#calendar-container') || 
                        document.body;
          
          container = document.createElement('div');
          container.id = 'streak-calendar-grid';
          container.className = 'calendar-grid';
          parent.appendChild(container);
        }
        
        // GENERAR 30 DÍAS CON ACTIVIDAD ÚNICA POR USUARIO
        const today = new Date();
        let html = '';
        
        for (let i = 29; i >= 0; i--) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          const dayKey = date.toISOString().split('T')[0];
          const songCount = activityPattern[dayKey] || 0;
          const isToday = i === 0;
          
          let activityClass = '';
          let title = `${date.toLocaleDateString('es-ES')}`;
          
          if (songCount > 0) {
            if (songCount >= 5) activityClass = 'activity-very-high';      // 5-6 canciones
            else if (songCount >= 3) activityClass = 'activity-high';      // 3-4 canciones
            else if (songCount >= 2) activityClass = 'activity-medium';    // 2 canciones
            else activityClass = 'activity-low';                           // 1 canción
            
            title += ` - ${songCount} canción${songCount !== 1 ? 'es' : ''}`;
          } else {
            title += ' - Sin actividad';
          }
          
          const todayClass = isToday ? ' today' : '';
          const dayNumber = date.getDate();
          
          html += `<div class="calendar-day ${activityClass}${todayClass}" title="${title}" data-date="${dayKey}" data-songs="${songCount}">${dayNumber}</div>`;
        }
        
        container.innerHTML = html;
        
        // Actualizar título si existe
        const title = document.querySelector('.streak-calendar h4');
        if (title) {
          const activeDays = Object.values(activityPattern).filter(x => x > 0).length;
          const totalSongs = Object.values(activityPattern).reduce((a, b) => a + b, 0);
          const dataTypeText = isUsingRealData ? '📡 Datos reales' : '🎭 Datos simulados';
          
          title.innerHTML = `
            📅 Actividad de ${currentUser} - ${new Date().toLocaleDateString('es-ES', { month: 'long', year: 'numeric' })}<br>
          `;
        }
        
        console.log(`✅ CALENDARIO DE ${currentUser}: ${container.children.length} días mostrados`);
        return container.children.length;
      }
      

      
      // FUNCIONES INDIVIDUALES POR USUARIO
      window.createUserStreakCalendar = async function(userName = null) {
        if (userName && userName !== getCurrentUser()) {
          console.log(`🔄 Cambiando a usuario: ${userName}`);
          localStorage.setItem('currentUser', userName);
        }
        console.log(`🎯 Creando calendario para ${getCurrentUser()}`);
        return await createSimpleCalendar();
      };
      
      // Función para obtener usuarios activos
      window.getAllActiveUsers = function() {
        return ['Jenn García', 'Usuario', 'Admin', 'Zero', 'María', 'Carlos'];
      };

      // Función de verificación mejorada
      window.checkCalendar = function() {
        const container = document.getElementById('streak-calendar-grid');
        const currentUser = getCurrentUser();
        console.log('📊 Estado del calendario:', {
          usuario: currentUser,
          existe: !!container,
          contenido: container ? container.innerHTML.length : 0,
          actividad: container ? container.innerHTML.includes('activity-') : false
        });
        return !!container && container.innerHTML.includes('activity-');
      };
      
      window.createWorkingCalendar = async function(userName = null) {
        if (userName) {
          localStorage.setItem('currentUser', userName);
        }
        console.log(`🔥 Creando calendario para ${getCurrentUser()}`);
        return await createSimpleCalendar();
      };
      
      // Función para cambiar usuario y actualizar calendario
      window.switchUser = async function(userName) {
        console.log(`🔄 Cambiando usuario de ${getCurrentUser()} a ${userName}`);
        localStorage.setItem('currentUser', userName);
        await createSimpleCalendar();
        return `✅ Calendario actualizado para ${userName}`;
      };

      window.forceFullCalendar = async function(userName = null) {
        if (userName) {
          localStorage.setItem('currentUser', userName);
        }
        console.log(`💪 FORZANDO CALENDARIO PARA ${getCurrentUser()}...`);
        return await createSimpleCalendar();
      };

      // FUNCIÓN DE DEPURACIÓN PARA VERIFICAR DATOS REALES
      window.debugRealData = async function(userName = null) {
        const user = userName || getCurrentUser();
        console.log(`🔍 === DEPURACIÓN DE DATOS REALES PARA ${user} ===`);
        
        try {
          if (!window.db) {
            console.log('❌ Firebase no está disponible');
            return { error: 'Firebase no disponible' };
          }
          
          console.log('✅ Firebase está disponible');
          
          // Probar diferentes colecciones
          const collectionNames = ['requests', 'solicitudes', 'songs', 'canciones'];
          const results = {};
          
          for (const collectionName of collectionNames) {
            try {
              console.log(`🔍 Probando colección: ${collectionName}`);
              const snapshot = await window.db.collection(collectionName).get();
              
              results[collectionName] = {
                exists: !snapshot.empty,
                totalDocs: snapshot.size,
                userDocs: 0,
                sampleData: []
              };
              
              if (!snapshot.empty) {
                let userCount = 0;
                snapshot.forEach(doc => {
                  const data = doc.data();
                  
                  // Verificar si es del usuario
                  if (data.usuario === user || data.user === user || 
                      data.nombre === user || data.name === user) {
                    userCount++;
                    if (results[collectionName].sampleData.length < 3) {
                      results[collectionName].sampleData.push({
                        id: doc.id,
                        usuario: data.usuario || data.user || data.nombre || data.name,
                        cancion: data.cancion || data.song || 'N/A',
                        fecha: data.ts || data.timestamp || data.time || data.date || 'N/A'
                      });
                    }
                  }
                });
                
                results[collectionName].userDocs = userCount;
                console.log(`📊 ${collectionName}: ${snapshot.size} total, ${userCount} de ${user}`);
              }
            } catch (error) {
              console.log(`❌ Error con ${collectionName}:`, error.message);
              results[collectionName] = { error: error.message };
            }
          }
          
          console.log('📋 === RESUMEN DE RESULTADOS ===');
          Object.entries(results).forEach(([collection, data]) => {
            if (data.error) {
              console.log(`❌ ${collection}: Error - ${data.error}`);
            } else {
              console.log(`📊 ${collection}: ${data.userDocs}/${data.totalDocs} documentos de ${user}`);
              if (data.sampleData.length > 0) {
                console.log(`   Muestra:`, data.sampleData);
              }
            }
          });
          
          return results;
          
        } catch (error) {
          console.error('❌ Error en depuración:', error);
          return { error: error.message };
        }
      };
      
      // EJECUTAR INMEDIATAMENTE - SIMPLE Y DIRECTO
      setTimeout(async () => {
        console.log('🚀 INICIANDO CALENDARIO CON DATOS REALES...');
        await createSimpleCalendar();
      }, 500);
      
      // También ejecutar cuando el DOM esté listo
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', async () => {
          await createSimpleCalendar();
        });
      } else {
        setTimeout(async () => {
          await createSimpleCalendar();
        }, 100);
      }
      
      window.fixCalendar = async function() {
        console.log('🔧 REPARANDO CALENDARIO...');
        return await createSimpleCalendar();
      };
      
      window.switchUser = async function(userName) {
        console.log(`🔄 CAMBIANDO USUARIO: ${userName || 'Auto'}`);
        if (userName) {
          localStorage.setItem('currentUser', userName);
        }
        return await createSimpleCalendar();
      };
      
      // FUNCIÓN SIMPLE DE VERIFICACIÓN
      window.checkCalendar = async function() {
        const container = document.getElementById('streak-calendar-grid');
        const days = container ? container.querySelectorAll('.calendar-day') : [];
        
        console.log(`📅 Calendario: ${days.length} días mostrados`);
        
        if (days.length === 0) {
          console.log('❌ No hay días - creando calendario...');
          await createSimpleCalendar();
        } else {
          console.log('✅ Calendario funcionando correctamente');
        }
        
        return days.length;
      };
      
      // FUNCIÓN PARA ESTADÍSTICAS DETALLADAS
      window.showCalendarStats = function() {
        const container = document.getElementById('streak-calendar-grid');
        if (!container) {
          console.log('❌ No hay calendario');
          return;
        }
        
        const currentUser = getCurrentUser();
        const days = container.querySelectorAll('.calendar-day');
        const stats = {
          usuario: currentUser,
          total: days.length,
          sinActividad: 0,
          actividad1: 0,    // 1 canción
          actividad2: 0,    // 2 canciones  
          actividad3_4: 0,  // 3-4 canciones
          actividad5_6: 0   // 5-6 canciones
        };
        
        days.forEach(day => {
          const songs = parseInt(day.getAttribute('data-songs') || '0');
          if (songs === 0) stats.sinActividad++;
          else if (songs === 1) stats.actividad1++;
          else if (songs === 2) stats.actividad2++;
          else if (songs >= 3 && songs <= 4) stats.actividad3_4++;
          else if (songs >= 5) stats.actividad5_6++;
        });
        
        console.log(`📊 === ESTADÍSTICAS DE ${currentUser} ===`);
        console.log(`📅 Total de días: ${stats.total}`);
        console.log(`⚪ Sin actividad: ${stats.sinActividad} días`);
        console.log(`🟢 1 canción: ${stats.actividad1} días`);
        console.log(`🟡 2 canciones: ${stats.actividad2} días`);
        console.log(`🟠 3-4 canciones: ${stats.actividad3_4} días`);
        console.log(`🔴 5-6 canciones: ${stats.actividad5_6} días`);
        
        return stats;
      };
      
      // FUNCIÓN PARA COMPARAR USUARIOS
      window.compareUsers = function(user1, user2) {
        console.log(`🔍 === COMPARANDO ${user1} vs ${user2} ===`);
        
        const activity1 = generateUserActivity(user1, 30);
        const activity2 = generateUserActivity(user2, 30);
        
        let differences = 0;
        let total1 = 0, total2 = 0;
        
        const dates = Object.keys(activity1).sort();
        for (const date of dates) {
          if (activity1[date] !== activity2[date]) differences++;
          total1 += activity1[date];
          total2 += activity2[date];
        }
        
        console.log(`👤 ${user1}: ${total1} canciones totales`);
        console.log(`👤 ${user2}: ${total2} canciones totales`);
        console.log(`🔄 Diferencias: ${differences}/30 días (${(differences/30*100).toFixed(1)}%)`);
        
        if (differences > 0) {
          console.log('✅ Los usuarios tienen patrones únicos');
        } else {
          console.log('❌ Los usuarios tienen patrones idénticos');
        }
        
        return { user1, user2, differences, total1, total2 };
      };
      
      // FUNCIÓN PARA PROBAR MÚLTIPLES USUARIOS
      window.testMultipleUsers = function() {
        const users = ['Jenn García', 'Usuario', 'Admin', 'Zero', 'María'];
        console.log('🧪 === PROBANDO MÚLTIPLES USUARIOS ===');
        
        users.forEach(user => {
          const activity = generateUserActivity(user, 30);
          const total = Object.values(activity).reduce((sum, songs) => sum + songs, 0);
          const activeDays = Object.values(activity).filter(songs => songs > 0).length;
          
          console.log(`👤 ${user}: ${activeDays} días activos, ${total} canciones`);
        });
        
        // Comparar algunos usuarios
        console.log('\n🔍 === COMPARACIONES ===');
        compareUsers('Jenn García', 'Usuario');
        compareUsers('Admin', 'Zero');
      };
      
      // FUNCIÓN DE DIAGNÓSTICO COMPLETO
      window.diagnosticComplete = function() {
        console.log('🔍 === DIAGNÓSTICO COMPLETO DEL SISTEMA ===');
        
        // 1. Verificar usuario actual
        const currentUser = getCurrentUser();
        console.log(`👤 Usuario actual: ${currentUser}`);
        
        // 2. Verificar calendario
        const container = document.getElementById('streak-calendar-grid');
        console.log(`📅 Contenedor del calendario: ${container ? 'Existe' : 'No existe'}`);
        
        if (container) {
          const days = container.querySelectorAll('.calendar-day');
          console.log(`📊 Días en calendario: ${days.length}`);
          
          // Verificar colores aplicados
          const colorsFound = {
            low: container.querySelectorAll('.activity-low').length,
            medium: container.querySelectorAll('.activity-medium').length,
            high: container.querySelectorAll('.activity-high').length,
            veryHigh: container.querySelectorAll('.activity-very-high').length
          };
          
          console.log('🎨 Distribución de colores:', colorsFound);
        }
        
        // 3. Verificar estilos CSS
        const testElement = document.createElement('div');
        testElement.className = 'calendar-day activity-very-high';
        testElement.style.display = 'none';
        document.body.appendChild(testElement);
        
        const computedStyle = window.getComputedStyle(testElement);
        const hasGradient = computedStyle.background.includes('gradient') || 
                           computedStyle.backgroundImage.includes('gradient');
        
        console.log(`🎨 Estilos CSS aplicados: ${hasGradient ? 'Gradientes OK' : 'Gradientes NO aplicados'}`);
        document.body.removeChild(testElement);
        
        // 4. Verificar Firebase
        console.log(`🔥 Firebase: ${typeof db !== 'undefined' ? 'Conectado' : 'No conectado'}`);
        
        // 5. Verificar funciones disponibles
        const functions = [
          'switchUser', 'showCalendarStats', 'compareUsers', 
          'testMultipleUsers', 'checkCalendar', 'forceFullCalendar'
        ];
        
        console.log('🔧 Funciones disponibles:');
        functions.forEach(func => {
          console.log(`  ${func}: ${typeof window[func] === 'function' ? '✅' : '❌'}`);
        });
        
        // 6. Probar cambio de usuario
        console.log('\n🔄 Probando cambio de usuario...');
        const originalUser = getCurrentUser();
        switchUser('Test User');
        const newUser = getCurrentUser();
        switchUser(originalUser);
        
        console.log(`Cambio de usuario: ${newUser === 'Test User' ? '✅' : '❌'}`);
        
        console.log('\n✅ === DIAGNÓSTICO COMPLETADO ===');
        
        return {
          usuario: currentUser,
          calendario: !!container,
          dias: container ? container.querySelectorAll('.calendar-day').length : 0,
          estilos: hasGradient,
          firebase: typeof db !== 'undefined',
          funciones: functions.map(f => ({ [f]: typeof window[f] === 'function' }))
        };
      };
      
      // Función de prueba SIMPLE para verificar el calendario
      window.testCalendarNow = function() {
        console.log('🧪 === PRUEBA SIMPLE DEL CALENDARIO ===');
        
        const currentUser = getCurrentUser();
        console.log(`👤 Usuario actual: ${currentUser}`);
        
        // Generar datos de prueba
        const activity = generateUserActivity(currentUser, 28);
        console.log(`📊 Datos generados:`, activity);
        
        // Contar actividad
        const totalSongs = Object.values(activity).reduce((sum, count) => sum + count, 0);
        const activeDays = Object.values(activity).filter(count => count > 0).length;
        console.log(`📈 ${totalSongs} canciones en ${activeDays} días activos`);
        
        // Forzar renderizado del calendario
        console.log('🔄 Forzando renderizado...');
        renderStreakCalendar().then(() => {
          console.log('✅ Calendario renderizado');
          
          // Verificar que se renderizó
          const container = document.getElementById('streak-calendar-grid');
          const days = container ? container.querySelectorAll('.calendar-day') : [];
          console.log(`📅 ${days.length} días mostrados en el calendario`);
          
          // Contar días con actividad en el DOM
          const activeDaysInDOM = container ? container.querySelectorAll('.calendar-day[class*="activity-"]').length : 0;
          console.log(`🎯 ${activeDaysInDOM} días con actividad visible en el DOM`);
          
          if (activeDaysInDOM > 0) {
            console.log('🎉 ¡ÉXITO! El calendario muestra actividad individual');
          } else {
            console.log('❌ PROBLEMA: El calendario no muestra actividad');
          }
        }).catch(error => {
          console.error('❌ Error:', error);
        });
      };

      // Función de prueba específica para el calendario
      window.testCalendar = function(username = null) {
        const testUser = username || getCurrentUser();
        console.log(`🧪 PRUEBA CALENDARIO: Probando calendario para usuario: ${testUser}`);
        
        // Establecer usuario seleccionado
        currentSelectedUser = testUser;
        console.log(`🎯 Usuario establecido: ${getCurrentSelectedUser()}`);
        
        // Generar actividad de prueba
        const activity = generateUserActivity(testUser, 28);
        console.log(`📊 Actividad generada para ${testUser}:`, activity);
        
        // Contar días activos
        const activeDays = Object.values(activity).filter(count => count > 0).length;
        const totalSongs = Object.values(activity).reduce((sum, count) => sum + count, 0);
        console.log(`📈 Resumen: ${activeDays} días activos, ${totalSongs} canciones totales`);
        
        // Renderizar calendario
        renderStreakCalendar().then(() => {
          console.log(`✅ Calendario renderizado para ${testUser}`);
        }).catch(error => {
          console.error(`❌ Error renderizando calendario:`, error);
        });
      };

      // Función para probar estadísticas individuales de actividad reciente
      window.testIndividualStats = function() {
        console.log('📊 === PRUEBA DE ESTADÍSTICAS INDIVIDUALES ===');
        
        const testUsers = ['Usuario', 'Ana García', 'Carlos López', 'María Rodríguez'];
        
        testUsers.forEach(user => {
          console.log(`\n👤 Probando usuario: ${user}`);
          
          // Cambiar usuario
          switchUser(user);
          
          // Generar estadísticas
          const activity = generateUserActivity(user, 30);
          const totalSongs = Object.values(activity).reduce((sum, count) => sum + count, 0);
          const activeDays = Object.values(activity).filter(count => count > 0).length;
          
          console.log(`📈 Total canciones: ${totalSongs}`);
          console.log(`📅 Días activos: ${activeDays}`);
          console.log(`🎵 Actividad por día:`, Object.values(activity).slice(0, 7)); // Mostrar solo primeros 7 días
          
          // Verificar que cada usuario tiene estadísticas únicas
          const userHash = hashCode(user);
          console.log(`🔑 Hash único del usuario: ${userHash}`);
        });
        
        console.log('\n✅ Prueba de estadísticas individuales completada');
      };

      // FUNCIÓN PARA FORZAR RECARGA CON DATOS REALES
      window.forceRealDataCalendar = async function(userName = null) {
        const user = userName || getCurrentUser();
        console.log(`🔄 === FORZANDO RECARGA CON DATOS REALES PARA ${user} ===`);
        
        try {
          // Primero verificar datos disponibles
          const debugInfo = await window.debugRealData(user);
          
          // Buscar la mejor colección con datos
          let bestCollection = null;
          let maxUserDocs = 0;
          
          Object.entries(debugInfo).forEach(([collection, data]) => {
            if (!data.error && data.userDocs > maxUserDocs) {
              maxUserDocs = data.userDocs;
              bestCollection = collection;
            }
          });
          
          if (bestCollection && maxUserDocs > 0) {
            console.log(`✅ Usando colección '${bestCollection}' con ${maxUserDocs} documentos de ${user}`);
            
            // Actualizar usuario si es necesario
            if (userName) {
              localStorage.setItem('currentUser', userName);
            }
            
            // Recrear calendario con datos reales
            await createSimpleCalendar();
            
            // Verificar resultado
            const container = document.getElementById('streak-calendar-grid');
            const days = container ? container.querySelectorAll('.calendar-day') : [];
            const activeDays = container ? container.querySelectorAll('.calendar-day[class*="activity-"]') : [];
            
            console.log(`📅 Calendario actualizado: ${days.length} días, ${activeDays.length} con actividad`);
            
            return {
              success: true,
              user,
              collection: bestCollection,
              totalDocs: maxUserDocs,
              calendarDays: days.length,
              activeDays: activeDays.length
            };
            
          } else {
            console.log(`⚠️ No se encontraron datos reales para ${user}, usando datos simulados`);
            await createSimpleCalendar();
            
            return {
              success: false,
              user,
              reason: 'No hay datos reales disponibles',
              usingSimulated: true
            };
          }
          
        } catch (error) {
          console.error('❌ Error forzando recarga:', error);
          return { success: false, error: error.message };
        }
      };
      
      console.log('🎯 Sistema de racha por usuario establecido');
    })();
  </script>
</body>
</html>
