<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Lista d'Canciones - Zero Radio</title>
  <link rel="stylesheet" href="styles.css?v=2.11" />
  <style>
    .calendar-navigation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin: 8px 0 10px;
    }
    .calendar-nav-btn {
      border: none;
      background: var(--btn-bg, #eee);
      color: var(--btn-fg, #333);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      transition: background 0.2s ease, transform 0.1s ease;
    }
    .calendar-nav-btn:hover { transform: translateY(-1px); }
    .dark-theme .calendar-nav-btn { background: #2f3237; color: #ddd; }

    .calendar-month-selector { display: flex; gap: 6px; align-items: center; }
    .calendar-select {
      appearance: none;
      -webkit-appearance: none;
      border: 1px solid rgba(0,0,0,0.1);
      background: var(--select-bg, #fff);
      color: var(--select-fg, #111);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 14px;
    }
    .dark-theme .calendar-select { background: #1f2328; color: #e5e7eb; border-color: rgba(255,255,255,0.15); }

    .calendar-weekdays {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      margin-bottom: 6px;
      font-weight: 600;
      opacity: 0.8;
    }
    .weekday { text-align: center; font-size: 12px; }
    .dark-theme .calendar-weekdays { opacity: 0.9; }

    .calendar-day.other-month { opacity: 0.35; }
    @media (max-width: 480px) {
      .calendar-select { font-size: 13px; }
      .calendar-nav-btn { font-size: 16px; }
    }
    /* Puntos modal cards */
    #points-breakdown .points-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 10px;
    }
    #points-breakdown .points-card {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      padding: 12px;
      border-radius: 8px;
      background: #f8f9fa;
      border: 2px solid #e9ecef;
    }
    #points-breakdown .points-title {
      font-weight: 600;
      color: #333;
    }
    #points-breakdown .points-desc {
      color: #555;
      line-height: 1.4;
    }
    #points-breakdown .points-formula {
      margin-top: 12px;
      color: #333;
    }
    /* Transparencia: scroll y responsivo en mÃ³viles */
    #gamification-breakdown .personal-stats-container {
      max-height: 70vh;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding-right: 8px;
      box-sizing: border-box;
      width: 100%;
    }
    @media (max-width: 420px) {
      #gamification-breakdown .personal-stats-grid {
        grid-template-columns: 1fr;
        gap: 10px;
      }
      #gamification-breakdown .stat-card {
        align-items: center;
        text-align: center;
        padding: 12px;
      }
    }
  </style>
  <style>
    /* Estilos dinÃ¡micos para fondo inmersivo */
    #immersive-bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100vh; /* Fallback */
      height: 100dvh; /* Asegurar altura completa en mÃ³viles */
      pointer-events: none;
      z-index: 0; /* Fondo base (visible si body es transparente) */
      background: #fff;
    }

    body.dark-theme #immersive-bg {
      background: #000;
    }

    .immersive-layer {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%; height: 100%;
      display: block;
    }
    
    .orb-background-canvas { 
      z-index: 1; /* Capa intermedia (encima del fondo, detrÃ¡s del contenido 10/20) */
      pointer-events: none; 
      position: fixed;
      top: 0; left: 0;
    }
  </style>
  
  <!-- Script de sincronizaciÃ³n de temas -->
  <script>
    // SincronizaciÃ³n global de temas entre pestaÃ±as/ventanas
    window.addEventListener('focus', function() {
      // Cuando la ventana recibe foco, verificar si hay cambios de tema
      if (typeof window.applyTheme === 'function') {
        window.applyTheme();
      }
      if (typeof window.updateActiveStates === 'function') {
        window.updateActiveStates();
      }
    });
  </script>
  <!-- Barra moderna desactivada -->

  <!-- Widget React Desactivado por conflicto con lista de admin
  <script>
    (function(){
      var target = document.getElementById('react-modern-widget');
      if (!target || typeof React === 'undefined' || typeof ReactDOM === 'undefined') return;
      // ... (cÃ³digo desactivado)
    })();
  </script>
  -->

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script>
    (function(){
      return; // Widget React desactivado para evitar conflictos con la lista principal
      function tryMount(){
        var container = document.querySelector('#stats-ticker .ticker-content');
        if (!container || typeof React === 'undefined' || typeof ReactDOM === 'undefined') return;
        if (container.getAttribute('data-react-root') === 'true') return;
        container.setAttribute('data-react-root','true');
        var e = React.createElement;
        function useDay(){
          var ref = React.useRef(null);
          var st = React.useState({ items: [], day: '' });
          var dayState = st[0]; var setDayState = st[1];
          React.useEffect(function(){
            function getDay(){ var el = document.getElementById('day-select'); return el && el.value ? el.value : ''; }
            function resub(){ 
              if (ref.current) { ref.current(); ref.current = null; }
              var d = getDay();
              // Si no hay db, reintentar pronto
              if (!window.db) { 
                 setDayState({ items: [], day: d }); 
                 setTimeout(resub, 500);
                 return; 
              }
              if (!d) { setDayState({ items: [], day: d }); return; }
              var q = window.db.collection('solicitudes').where('day','==',d).orderBy('ts','desc');
              ref.current = q.onSnapshot(function(snap){ var items = []; snap.forEach(function(doc){ var x = doc.data()||{}; if (String(x.usuario||'').trim().toLowerCase() === 'prueba') return; items.push({ usuario:x.usuario, cancion:x.cancion, artista:x.artista, day:d }); }); setDayState({ items: items, day: d }); });
            }
            resub();
            var el = document.getElementById('day-select');
            function onChange(){ resub(); }
            el && el.addEventListener('change', onChange);
            // Escuchar evento personalizado por si el cambio de dÃ­a no dispara 'change' nativo
            window.addEventListener('day-changed', onChange);
            return function(){ 
               el && el.removeEventListener('change', onChange); 
               window.removeEventListener('day-changed', onChange);
               if (ref.current) { ref.current(); ref.current = null; } 
            };
          }, []);
          return dayState;
        }
        function useGlobal(){
          var ref = React.useRef(null);
          var refPoints = React.useRef(null);
          var st = React.useState({ total: 0, topArtists3: [], topUsers3: [], topSong: '', topSongCount: 0, topPoints3: [] });
          var g = st[0]; var setG = st[1];
          
          React.useEffect(function(){
            if (ref.current) { ref.current(); ref.current = null; }
            
            function connect() {
               if (!window.db) { setTimeout(connect, 500); return; }
               
               // VOLVEMOS A: Escuchar 'solicitudes' para calcular totales en tiempo real (Client-side aggregation).
               // Esto garantiza que todos vean los mismos datos calculados desde la base de datos viva.
               ref.current = window.db.collection('solicitudes').orderBy('ts', 'desc').onSnapshot(function(snap){
                 var artistCount = {}; var artistOriginal = {}; var songCount = {}; var userCount = {}; var userOriginal = {}; var total = 0;
                 
                 snap.forEach(function(doc){
                   var d = doc.data()||{};
                   if (String(d.usuario||'').trim().toLowerCase() === 'prueba') return;
                   var a=(String(d.artista||'').trim().toLowerCase());
                   var ao=(String(d.artista||'').trim());
                   var s=(String(d.cancion||'').trim().toLowerCase());
                   var so=(String(d.cancion||'').trim());
                   var u=(String(d.usuario||'').trim().toLowerCase());
                   var uo=(String(d.usuario||'').trim());
                   
                   if (a){ artistCount[a]=(artistCount[a]||0)+1; if(!artistOriginal[a]) artistOriginal[a]=ao; }
                   if (s){ 
                      songCount[s] = (songCount[s]||0)+1; 
                      if (!songCount[s+'_name']) songCount[s+'_name'] = so;
                   }
                   if (u){ userCount[u]=(userCount[u]||0)+1; if(!userOriginal[u]) userOriginal[u]=uo; }
                   total++;
                 });
                 
                 function getTop3(countObj, originalObj) {
                    return Object.keys(countObj)
                       .map(function(k){ return { k: k, c: countObj[k], o: originalObj[k]||k }; })
                       .sort(function(a,b){ 
                           var diff = b.c - a.c;
                           if (diff !== 0) return diff;
                           return a.k.localeCompare(b.k); // Desempate alfabÃ©tico
                       })
                       .slice(0, 3)
                       .map(function(it){ return it.o + ' (' + it.c + ')'; });
                 }
                 
                 function getTop1(countObj, nameSuffix) {
                    var max = 0; var maxK = ''; 
                    for(var k in countObj) { 
                       if(k.endsWith('_name')) continue; 
                       if(countObj[k] > max) { max = countObj[k]; maxK = k; }
                       else if(countObj[k] === max) { if(!maxK || k < maxK) maxK = k; } // Desempate alfabÃ©tico
                    }
                    var name = maxK ? (countObj[maxK+'_name'] || maxK) : 'N/D';
                    if(name === maxK && name !== 'N/D') name = name.charAt(0).toUpperCase() + name.slice(1);
                    return { name: name, count: max };
                 }
                 
                 var ta = getTop3(artistCount, artistOriginal);
                 var tu = getTop3(userCount, userOriginal);
                 var ts = getTop1(songCount, '_name');
                 
                 setG(function(prev){ 
                    return Object.assign({}, prev, { 
                       total: total, 
                       topArtists3: ta, 
                       topUsers3: tu, 
                       topSong: ts.name, 
                       topSongCount: ts.count 
                    }); 
                 });
               });
            }
            connect();
            
            return function(){ if (ref.current) { ref.current(); ref.current = null; } };
          }, []);

          React.useEffect(function(){
             if (refPoints.current) { refPoints.current(); refPoints.current = null; }
             
             function connectPoints() {
                if (!window.db) { setTimeout(connectPoints, 500); return; }
                
                refPoints.current = window.db.collection('userStats')
                   .orderBy('totalPoints', 'desc')
                   .limit(3)
                   .onSnapshot(function(snap){
                      var arr = [];
                      snap.forEach(function(doc){
                         var d = doc.data() || {};
                         var u = doc.id;
                         var name = u.charAt(0).toUpperCase() + u.slice(1);
                         var points = d.totalPoints || 0;
                         arr.push(name + ' (' + points + ')');
                      });
                      setG(function(prev){ return Object.assign({}, prev, { topPoints3: arr }); });
                   });
             }
             connectPoints();
                
             return function(){ if (refPoints.current) { refPoints.current(); refPoints.current = null; } };
          }, []);

          return g;
        }
        function StatsTicker(){
          var day = useDay();
          var g = useGlobal();
          function fmt(x){ return x && x.length ? x : 'N/D'; }
          var ac = {}; var sc = {}; var uc = {}; var artistOriginal = {}; var userOriginal = {}; var songOriginal = {};
          (Array.isArray(day.items) ? day.items : []).forEach(function(it){
            var a=String(it.artista||'').trim().toLowerCase();
            var s=String(it.cancion||'').trim().toLowerCase();
            var u=String(it.usuario||'').trim().toLowerCase();
            var ao=String(it.artista||'').trim();
            var so=String(it.cancion||'').trim();
            var uo=String(it.usuario||'').trim();
            if(a) { ac[a]=(ac[a]||0)+1; if(!artistOriginal[a]) artistOriginal[a]=ao; }
            if(s) { sc[s]=(sc[s]||0)+1; if(!songOriginal[s]) songOriginal[s]=so; }
            if(u) { uc[u]=(uc[u]||0)+1; if(!userOriginal[u]) userOriginal[u]=uo; }
          });
          function top(m, o){ var k=''; var v=0; for(var key in m){ var val=m[key]; if(val>v){ v=val; k=key; } else if(val===v && (!k || key<k)){ k=key; } } return {k:o[k]||k,v:v}; }
          var ts = top(sc, songOriginal);
          var usersTop3Day = Object.keys(uc).map(function(k){ return {k:k,c:uc[k],o:userOriginal[k]||k}; }).sort(function(a,b){ var d=b.c-a.c; if(d!==0)return d; return a.k.localeCompare(b.k); }).slice(0,3).map(function(it){ return it.o+' ('+it.c+')'; });
          var artistsTop3Day = Object.keys(ac).map(function(k){ return {k:k,c:ac[k],o:artistOriginal[k]||k}; }).sort(function(a,b){ var d=b.c-a.c; if(d!==0)return d; return a.k.localeCompare(b.k); }).slice(0,3).map(function(it){ return it.o+' ('+it.c+')'; });
          var latest = Array.isArray(day.items) && day.items.length ? day.items[0] : null;
          var latestTxt = latest ? (String(latest.cancion||'').trim() + (latest.artista ? ' â€” ' + String(latest.artista).trim() : '')) : 'N/D';
          var globalUsersTop3 = Array.isArray(g.topUsers3) && g.topUsers3.length ? g.topUsers3.join(', ') : 'N/D';
          var globalArtistsTop3 = Array.isArray(g.topArtists3) && g.topArtists3.length ? g.topArtists3.join(', ') : 'N/D';
          var globalPointsTop3 = Array.isArray(g.topPoints3) && g.topPoints3.length ? g.topPoints3.join(', ') : 'Calculando...';
          var avgTxtGlobal = 'N/D';
          if (typeof window.__globalTotalSolicitudes === 'number' && typeof window.__globalDistinctUsers === 'number' && window.__globalDistinctUsers > 0) {
            avgTxtGlobal = (window.__globalTotalSolicitudes / window.__globalDistinctUsers).toFixed(1);
          }
          // Verificar si estamos cargando totales
          var totalDisplay = g.total ? String(g.total) : '...';
          
          var globalText = '<strong>HISTORIA:</strong> â€¢ <strong>ğŸ† Top Puntos:</strong> '+globalPointsTop3+' â€¢ <strong>ğŸµ MÃ¡s pedida:</strong> '+fmt(g.topSong)+(typeof g.topSongCount==='number'?' ('+g.topSongCount+')':'')+'  â€¢  <strong>ğŸ‘¥ Top Usuarios:</strong> '+globalUsersTop3+'  â€¢  <strong>ğŸ¤ Top Artistas:</strong> '+globalArtistsTop3+'  â€¢  <strong>ğŸ“Š Total:</strong> '+totalDisplay;
          var dayText = 'ğŸ“… <strong>HOY</strong> â€¢ <strong>ğŸµ Ãšltima:</strong> '+fmt(latestTxt)+' â€¢ <strong>ğŸ‘¥ Top Usuarios:</strong> '+(usersTop3Day.length?usersTop3Day.join(', '):'N/D')+' â€¢ <strong>ğŸ¤ Top Artistas:</strong> '+(artistsTop3Day.length?artistsTop3Day.join(', '):'N/D')+' â€¢ <strong>ğŸ“ Solicitudes:</strong> '+String(day.items.length||0);
          var sep = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
          return e('span', { dangerouslySetInnerHTML: { __html: dayText + sep + globalText } });
        }
        var root = ReactDOM.createRoot(container);
        root.render(e(StatsTicker));
      }
      if (!window.__reactTickerWait) window.__reactTickerWait = setInterval(tryMount, 500);
      tryMount();
    })();
  </script>
  
  <!-- Firebase SDK (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <!-- DetecciÃ³n de Nubia/iPhone ELIMINADA para uniformidad visual -->

  <style>
    /* Puntos modal tabs */
    .points-panel { display: none; }
    .points-panel.active { display: block; }
    .points-tab { border: none; background: var(--btn-bg,#eee); padding: 8px 10px; border-radius: 8px; margin-right: 6px; cursor: pointer; }
    .points-tab.active { background: #2563eb; color: #fff; }
    .admin-section-tabs { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
    .admin-section-tabs .points-tab { margin-right: 0; }
    .edit-actions-bar { display: flex; gap: 8px; margin: 10px 0 6px; }
    .badge-selector { display: flex; flex-direction: column; gap: 14px; align-items: stretch; }
    .badge-selector-title { color: #fff; font-weight: 800; font-size: 28px; line-height: 1.1; text-align: center; }
    .badge-tabs { width: 100%; display: grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: 12px; align-items: center; }
    .badge-tabs .badge-tab { width: 100%; margin-right: 0; background: rgba(255,255,255,0.92); color: #111; padding: 14px 16px; border-radius: 14px; font-weight: 800; }
    .badge-tabs .badge-tab.active { background: #2563eb; color: #fff; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.65); }
    .admin-panel .admin-row.badge-selector { display: flex; flex-direction: column; grid-template-columns: none; gap: 14px; align-items: stretch; }
    .admin-panel .admin-row.badge-selector > .badge-selector-title { width: 100%; text-align: center; }
    .admin-panel .admin-row.badge-selector > .badge-tabs { width: 100%; }
    @media (max-width: 720px) {
      .badge-selector-title { text-align: center; font-size: 22px; }
      .badge-tabs { grid-template-columns: repeat(2, minmax(140px, 1fr)); }
    }

    #edit-actions-bar {
      position: sticky;
      top: 0;
      z-index: 5;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 8px;
      align-items: center;
      justify-content: flex-start;
    }
    #edit-actions-bar .btn {
      flex: 0 0 auto;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 800;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
    }
    #edit-actions-bar .btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    #edit-actions-bar .btn-primary {
      background: rgba(37,99,235,0.20);
      border-color: rgba(37,99,235,0.55);
    }
    #edit-actions-bar .btn-warn {
      background: rgba(251,191,36,0.16);
      border-color: rgba(251,191,36,0.55);
    }
    #edit-actions-bar .edit-spacer {
      flex: 1 1 auto;
      min-width: 8px;
    }
    #deleted-count-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 22px;
      height: 22px;
      padding: 0 8px;
      border-radius: 999px;
      background: rgba(251,191,36,0.22);
      border: 1px solid rgba(251,191,36,0.6);
      font-size: 12px;
      font-weight: 900;
      margin-left: 8px;
    }
    #deleted-modal .modal {
      max-width: 720px;
    }
    .deleted-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
      max-height: 55vh;
      overflow: auto;
      padding-right: 6px;
    }
    .deleted-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      padding: 12px;
    }
    .deleted-row .meta {
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .deleted-row .meta .title {
      font-weight: 900;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .deleted-row .meta .sub {
      font-size: 12px;
      opacity: 0.85;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .deleted-row .meta .fine {
      font-size: 12px;
      opacity: 0.75;
    }
    .deleted-row .restore-btn {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(34,197,94,0.55);
      background: rgba(34,197,94,0.16);
      color: #fff;
      font-weight: 900;
      cursor: pointer;
      white-space: nowrap;
    }
    .deleted-row .restore-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

  </style>
</head>
<body>
  <main class="container">
    <section class="card" aria-labelledby="titulo">
      <div class="title-bar" role="group" aria-label="Barra de tÃ­tulo y filtro">
        <h1 id="titulo">Lista de canciones</h1>
        <div class="title-tools">
          <form class="search-box" role="search" autocomplete="off" data-lpignore="true" data-1p-ignore="true">
            <span class="search-icon" aria-hidden="true">ğŸ”</span>
            <input id="search-input" name="song-search-query" type="search" placeholder="Buscar canciÃ³n..." aria-label="Buscar canciÃ³n" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" data-form-type="search" data-lpignore="true" data-1p-ignore="true" inputmode="search" enterkeyhint="search" readonly onfocus="this.removeAttribute('readonly');" />
            <div id="search-results" class="search-results" hidden></div>
          </form>
          <button id="theme-btn" class="theme-btn" type="button" aria-label="Cambiar tema" title="Cambiar tema">
            ğŸ¨
          </button>
          <!-- BotÃ³n de lÃ¡piz para modo ediciÃ³n (visible solo en modo admin) -->
          <button id="edit-toggle-btn" class="edit-toggle-btn" type="button" title="Editar lista (eliminar / mover)" aria-pressed="false" hidden>
            âœï¸
          </button>
          <button id="menu-btn" class="menu-btn" type="button" aria-label="Abrir menÃº" aria-haspopup="true" aria-expanded="false" aria-controls="menu-dropdown">
            <span class="bar bar1"></span>
            <span class="bar bar2"></span>
            <span class="bar bar3"></span>
          </button>
          <div id="menu-dropdown" class="menu-dropdown" hidden>
            <ul class="menu-list" role="menu" aria-label="Acciones">
              <li><a href="index.html" class="menu-item" role="menuitem">ğŸµ Pedir nueva canciÃ³n</a></li>
              <li><button type="button" id="menu-search-open" class="menu-item" role="menuitem">ğŸ” Buscar canciÃ³n</button></li>
              <li><button type="button" id="menu-stats-open" class="menu-item" role="menuitem">ğŸ“Š EstadÃ­sticas</button></li>
              <li><button type="button" id="menu-gamification-open" class="menu-item" role="menuitem">ğŸ† Mi Perfil</button></li>
              <li><button type="button" id="menu-rewards-open" class="menu-item" role="menuitem">ğŸ Puntos</button></li>
              <li><button type="button" id="menu-changelog-open" class="menu-item" role="menuitem">ğŸš€ Mejoras (v2.1)</button></li>
              <li><button type="button" id="menu-admin-open" class="menu-item" role="menuitem">
                âš™ï¸ Modo Admin <span id="admin-badge" class="notification-badge" hidden>0</span>
              </button></li>
            </ul>
          </div>

        </div>
        
        
      </div>

      <div class="filter-controls-row" role="group" aria-label="Filtros de lista">
        <div class="day-filter">
          <label for="day-select" style="margin-right: 8px;">Ver dÃ­a:</label>
          <select id="day-select"></select>
        </div>
        <div class="day-filter">
          <label for="sort-select" style="margin-right: 8px;">Orden:</label>
          <select id="sort-select">
            <option value="recent">MÃ¡s recientes arriba</option>
            <option value="oldest">MÃ¡s antiguas arriba</option>
            <option value="manual_recent">Manual + recientes</option>
            <option value="manual_fifo">Manual (FIFO)</option>
          </select>
        </div>
        <div class="vip-filter">
          <label><input type="checkbox" id="vip-only" /> Ver solo VIP</label>
        </div>
      </div>

      <!-- BUSCADOR -->
      <div id="search-modal" class="modal-overlay" hidden>
         <div class="modal" role="dialog" aria-modal="true" aria-labelledby="search-modal-title">
            <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
            <h2 id="search-modal-title">Buscar CanciÃ³n</h2>
            <div class="field">
               <input type="text" id="search-input" placeholder="Escribe artista, canciÃ³n o usuario..." class="search-input">
            </div>
            <div id="search-results" class="search-results-list">
               <!-- Resultados aquÃ­ -->
            </div>
            <button type="button" id="search-load-more" class="btn btn-secondary" hidden style="width: 100%; margin-top: 10px;">Cargar mÃ¡s resultados...</button>
            <div class="actions modal-actions">
               <button type="button" id="search-close" class="btn">Cerrar</button>
            </div>
         </div>
      </div>

      <div id="admin-panel" class="admin-panel" hidden>
        
        <div class="admin-sections-tabs" role="tablist" aria-label="Secciones de administraciÃ³n">
          <button type="button" class="admin-menu-tab admin-section-tab active" data-section="badges" role="tab" aria-selected="true">ğŸ‘‘ Insignias</button>
          <button type="button" class="admin-menu-tab admin-section-tab" data-section="rewards" role="tab" aria-selected="false">ğŸ Recompensas</button>
          <button type="button" class="admin-menu-tab admin-section-tab" data-section="maintenance" role="tab" aria-selected="false">ğŸ”§ Mantenimiento</button>
          <select id="admin-section-select" class="admin-select" hidden aria-hidden="true" tabindex="-1">
            <option value="badges">ğŸ‘‘ GestiÃ³n de Insignias</option>
            <option value="rewards">ğŸ AdministraciÃ³n de Recompensas</option>
            <option value="maintenance">ğŸ”§ Mantenimiento</option>
          </select>
        </div>

        <!-- SecciÃ³n de GestiÃ³n de Insignias -->
        <div id="badges-section" class="admin-section">
          <!-- Selector de Insignia -->
          <div class="admin-row badge-selector">
            <div class="badge-selector-title">Selecciona tipo de insignia</div>
            <div class="badge-tabs" role="tablist" aria-label="Tipos de insignia">
              <button type="button" class="points-tab badge-tab active" data-badge="vip" role="tab" aria-selected="true">ğŸ‘‘ VIP</button>
              <button type="button" class="points-tab badge-tab" data-badge="z0-vip" role="tab" aria-selected="false">â­ Z0-VIP</button>
              <button type="button" class="points-tab badge-tab" data-badge="donador" role="tab" aria-selected="false">ğŸ’ Donador</button>
              <button type="button" class="points-tab badge-tab" data-badge="z0-fan" role="tab" aria-selected="false">ğŸ¤ z0-Fan</button>
              <button type="button" class="points-tab badge-tab" data-badge="z0-platino" role="tab" aria-selected="false">ğŸ¥ˆ z0-Platino</button>
            </div>
            <select id="badge-type-select" class="admin-select" hidden aria-hidden="true" tabindex="-1">
              <option value="vip">ğŸ‘‘ VIP</option>
              <option value="z0-vip">â­ Z0-VIP</option>
              <option value="donador">ğŸ’ Donador</option>
              <option value="z0-fan">ğŸ¤ z0-Fan</option>
              <option value="z0-platino">ğŸ¥ˆ z0-Platino</option>
            </select>
          </div>

          <!-- GestiÃ³n de VIP -->
          <div id="vip-management" class="badge-management">
            <div class="admin-row">
              <label for="all-users-select">Selecciona usuario registrado para VIP:</label>
              <select id="all-users-select" class="user-select" aria-label="Usuarios registrados">
                <option value="">Selecciona un usuario</option>
              </select>
              <div class="admin-btns">
                <button type="button" id="vip-add" class="btn">Agregar</button>
                <button type="button" id="user-delete" class="btn">Borrar usuario</button>
              </div>
              <div class="admin-list-section">
                <strong>Usuarios VIP:</strong>
                <ul id="vip-list" class="vip-list"></ul>

              </div>
            </div>
          </div>

          <!-- GestiÃ³n de Z0-VIP -->
          <div id="z0-vip-management" class="badge-management" hidden>
            <div class="admin-row">
              <label for="all-users-select-z0">Selecciona usuario registrado para Z0-VIP:</label>
              <select id="all-users-select-z0" class="user-select" aria-label="Usuarios registrados para Z0-VIP">
                <option value="">Selecciona un usuario</option>
              </select>
              <div class="admin-btns">
                <button type="button" id="z0-vip-add" class="btn">Agregar Z0-VIP</button>
              </div>
              <div class="admin-list-section">
                <strong>Usuarios Z0-VIP:</strong>
                <ul id="z0-vip-list" class="vip-list"></ul>
              </div>
            </div>
      </div>

      <!-- GestiÃ³n de Donador -->
      <div id="donador-management" class="badge-management" hidden>
            <div class="admin-row">
              <label for="all-users-select-donador">Selecciona usuario registrado para Donador (1 dÃ­a):</label>
              <select id="all-users-select-donador" class="user-select" aria-label="Usuarios registrados para Donador">
                <option value="">Selecciona un usuario</option>
              </select>
              <div class="admin-btns">
                <button type="button" id="donador-add" class="btn">Agregar Donador</button>
              </div>
              <div class="admin-list-section">
                <strong>Usuarios Donadores (temporales):</strong>
                <ul id="donador-list" class="vip-list"></ul>
              </div>
            </div>
          </div>

          <div id="z0-fan-management" class="badge-management" hidden>
            <div class="admin-row">
              <label for="all-users-select-z0-fan">Selecciona usuario para z0-Fan:</label>
              <select id="all-users-select-z0-fan" class="user-select" aria-label="Usuarios registrados para z0-Fan">
                <option value="">Selecciona un usuario</option>
              </select>
              <div class="admin-btns">
                <button type="button" id="z0-fan-add" class="btn">Agregar z0-Fan</button>
              </div>
              <div class="admin-list-section">
                <strong>Usuarios z0-Fan:</strong>
                <ul id="z0-fan-list" class="vip-list"></ul>
              </div>
            </div>
          </div>

          <div id="z0-platino-management" class="badge-management" hidden>
            <div class="admin-row">
              <label for="all-users-select-z0-platino">Selecciona usuario para z0-Platino:</label>
              <select id="all-users-select-z0-platino" class="user-select" aria-label="Usuarios registrados para z0-Platino">
                <option value="">Selecciona un usuario</option>
              </select>
              <div class="admin-btns">
                <button type="button" id="z0-platino-add" class="btn">Agregar z0-Platino</button>
              </div>
              <div class="admin-list-section">
                <strong>Usuarios z0-Platino:</strong>
                <ul id="z0-platino-list" class="vip-list"></ul>
              </div>
            </div>
          </div>
        </div>
        <!-- SecciÃ³n de AdministraciÃ³n de Recompensas -->
        <div id="rewards-section" class="admin-section" hidden>
          <div class="admin-rewards-section">
            <h3>ğŸ AdministraciÃ³n de Recompensas</h3>
            
            <!-- EstadÃ­sticas de Recompensas -->
            <div class="admin-rewards-stats">
              <div class="reward-stat-item">
                <span class="stat-number" id="admin-total-pending">0</span>
                <span class="stat-label">Pendientes</span>
              </div>
              <div class="reward-stat-item">
                <span class="stat-number" id="admin-total-approved">0</span>
                <span class="stat-label">Aprobadas Hoy</span>
              </div>
              <div class="reward-stat-item">
                <span class="stat-number" id="admin-total-rejected">0</span>
                <span class="stat-label">Rechazadas Hoy</span>
              </div>
            </div>
            
            <!-- Filtros de Recompensas -->
            <div class="admin-rewards-filters">
              <select id="admin-rewards-status-filter" class="admin-select">
                <option value="all">Todas las solicitudes</option>
                <option value="pending" selected>Solo pendientes</option>
                <option value="approved">Solo aprobadas</option>
                <option value="rejected">Solo rechazadas</option>
              </select>
              <select id="admin-rewards-user-filter" class="admin-select">
                <option value="all">Todos los usuarios</option>
              </select>
              <button type="button" id="admin-refresh-rewards" class="btn">ğŸ”„ Actualizar</button>
            </div>
            
            <!-- Lista de Solicitudes de Recompensas -->
            <div class="admin-rewards-list-container">
              <div id="admin-rewards-list" class="admin-rewards-list">
                <p class="loading-message">Cargando solicitudes...</p>
              </div>
            </div>
          </div>
        </div>

        <!-- SecciÃ³n de Mantenimiento -->
        <div id="maintenance-section" class="admin-section" hidden>
          <div class="admin-section-tabs">
             <button type="button" class="points-tab active" data-tab="system">ğŸ”§ Sistema</button>
             <button type="button" class="points-tab" data-tab="compensation">ğŸ’° CompensaciÃ³n</button>
             <button type="button" class="points-tab" data-tab="links">ğŸ”— Enlaces</button>
          </div>

          <div class="admin-tab-content">
             <!-- Panel Sistema -->
             <div id="admin-tab-system" class="admin-tab-panel active">
                <div class="admin-card maintenance-card">
                  <div class="card-header">
                    <h3>ğŸ”§ Acciones de Sistema</h3>
                  </div>
                  <div class="card-body">
                   <div class="action-grid">
                      <button type="button" id="recalculate-users" class="btn btn-outline-success" title="Recalcular puntos de todos los usuarios">
                        <span class="btn-icon">ğŸ”„</span>
                        <span class="btn-text">Recalcular Puntos</span>
                      </button>
                      <button type="button" id="rebuild-played-btn" class="btn btn-outline-secondary" title="Recontar canciones reproducidas del dÃ­a">
                        <span class="btn-icon">ğŸ“Š</span>
                        <span class="btn-text">Recontar Reprod.</span>
                      </button>
                      <button type="button" id="wipe-all" class="btn btn-outline-danger" title="Borrar todas las solicitudes del dÃ­a actual">
                        <span class="btn-icon">ğŸ—‘ï¸</span>
                        <span class="btn-text">Borrar DÃ­a</span>
                      </button>
                   </div>
                   
                   <div class="dj-control-wrapper">
                      <button type="button" id="set-master-dj" class="btn btn-dj-master">
                        ğŸ›ï¸ Establecer ESTE dispositivo como DJ Maestro
                      </button>
                      <p class="help-text">Solo el DJ Maestro puede marcar canciones como sonadas/pendientes.</p>
                   </div>
                  </div>
                </div>
             </div>

             <!-- Panel CompensaciÃ³n -->
             <div id="admin-tab-compensation" class="admin-tab-panel">
                <div class="admin-card compensation-card">
                  <div class="card-header">
                    <h3>ğŸ’° CompensaciÃ³n Manual</h3>
                  </div>
                  <div class="card-body">
                   <div class="form-grid">
                      <div class="field full-width">
                        <label>Usuario a compensar</label>
                        <select id="comp-user-select" class="admin-select">
                          <option value="">Seleccionar usuario...</option>
                        </select>
                      </div>
                      <div class="field-row">
                        <div class="field">
                          <label>Puntos (+/-)</label>
                          <input type="number" id="comp-points-input" placeholder="Ej: 500" class="admin-input">
                        </div>
                        <div class="field flex-grow">
                          <label>Motivo</label>
                          <input type="text" id="comp-reason-input" placeholder="Ej: Bono especial" class="admin-input">
                        </div>
                      </div>
                      <div class="field full-width">
                        <button type="button" id="grant-comp-points-btn" class="btn btn-primary btn-block">ğŸ Otorgar Puntos</button>
                      </div>
                   </div>
                  </div>
                </div>
             </div>

             <!-- Panel Enlaces -->
             <div id="admin-tab-links" class="admin-tab-panel">
                <div class="admin-card overlay-links-card">
                  <div class="card-header">
                    <h3>ğŸ”— Enlaces Overlay (OBS)</h3>
                  </div>
                  <div class="card-body">
                   <div class="action-grid">
                      <button type="button" onclick="copyOverlayLink('overlay.html')" class="btn btn-outline-primary" title="Copiar enlace del Overlay de Pedidos">
                        <span class="btn-icon">ğŸ“‹</span>
                        <span class="btn-text">Overlay Pedidos</span>
                      </button>
                      <button type="button" onclick="copyOverlayLink('queue_overlay.html')" class="btn btn-outline-primary" title="Copiar enlace del Overlay de Cola">
                        <span class="btn-icon">ğŸ“‹</span>
                        <span class="btn-text">Overlay Cola</span>
                      </button>
                   </div>
                   <p class="help-text" style="margin-top: 10px;">Copia estos enlaces y pÃ©galos como "Fuente de Navegador" en OBS.</p>
                  </div>
                </div>
             </div>
          </div>
        </div>

        <!-- Acciones Generales del Admin -->
        <div class="admin-row admin-actions">
          <button type="button" id="admin-exit" class="btn">Salir del modo Admin</button>
        </div>
      </div>

      

      <!-- Modales -->
      <!-- Log de Actualizaciones (Para el usuario) -->
      <div id="updates-log-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="updates-log-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="updates-log-title">ğŸš€ Novedades y Mejoras</h2>
          <div class="updates-content">
            <div class="update-item">
               <h4>ğŸ“Š EstadÃ­sticas 100% Precisas</h4>
               <p>Hemos rediseÃ±ado el sistema de conteo para asegurar que tus nÃºmeros en "Mi Perfil" y "Transparencia" sean idÃ©nticos y exactos.</p>
               <ul>
                 <li>"Canciones Pedidas" ahora cuenta todo tu historial completo.</li>
                 <li>"Canciones Reproducidas" se actualiza al instante al marcar/desmarcar.</li>
                 <li>Los nÃºmeros son consistentes entre todas las vistas.</li>
               </ul>
            </div>
            <div class="update-item">
               <h4>ğŸ“… Calendario de Rachas Mejorado</h4>
               <p>El calendario ahora pinta correctamente todos los dÃ­as que tuviste actividad, sin saltarse fechas por cambios de hora.</p>
            </div>
            <div class="update-item">
               <h4>âš¡ ActualizaciÃ³n InstantÃ¡nea</h4>
               <p>Ahora verÃ¡s los cambios en tus puntos y estadÃ­sticas inmediatamente, sin tener que recargar la pÃ¡gina.</p>
            </div>
          </div>
          <div class="actions modal-actions">
            <button type="button" id="close-updates-log" class="btn btn-primary">Entendido</button>
          </div>
        </div>
      </div>

      <!-- Modal de Mensajes GenÃ©ricos (Error/Ã‰xito) -->
      <div id="message-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="message-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="message-modal-title">Mensaje</h2>
          <p id="message-modal-content">Contenido del mensaje</p>
          <div class="actions modal-actions">
            <button type="button" id="message-modal-ok" class="btn btn-primary">Aceptar</button>
          </div>
        </div>
      </div>

      <div id="admin-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="admin-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="admin-modal-title">Modo Admin</h2>
          <p>Inicia sesiÃ³n para administrar VIP y mantenimiento</p>
          <div class="field">
            <label for="admin-email-input">Correo</label>
            <input id="admin-email-input" type="email" placeholder="correo@ejemplo.com" autocomplete="off" spellcheck="false" data-form-type="other" />
          </div>
          <div class="field">
            <label for="admin-pass-input">ContraseÃ±a</label>
            <input id="admin-pass-input" type="password" placeholder="ContraseÃ±a" autocomplete="new-password" spellcheck="false" data-form-type="other" />
            <p id="admin-auth-error" class="error" hidden>Credenciales incorrectas o no eres admin.</p>
          </div>
          <div class="actions modal-actions">
            <button type="button" id="admin-pass-cancel" class="btn">Cancelar</button>
            <button type="button" id="admin-pass-confirm" class="btn">Entrar</button>
          </div>
        </div>
      </div>

      <div id="user-delete-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="user-delete-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="user-delete-modal-title">Borrar usuario</h2>
          <p>Â¿Borrar al usuario "<span id="user-delete-name"></span>" de la lista de registrados?</p>
          <div class="actions modal-actions">
            <button type="button" id="user-delete-cancel" class="btn">Cancelar</button>
            <button type="button" id="user-delete-confirm" class="btn">Borrar</button>
          </div>
        </div>
      </div>

      <div id="vip-remove-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="vip-remove-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="vip-remove-modal-title">Quitar VIP</h2>
          <p>Â¿Quitar VIP a "<span id="vip-remove-user"></span>"?</p>
          <div class="actions modal-actions">
            <button type="button" id="vip-remove-cancel" class="btn">Cancelar</button>
            <button type="button" id="vip-remove-confirm" class="btn">Quitar</button>
          </div>
        </div>
      </div>

      <div id="wipe-all-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="wipe-all-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="wipe-all-modal-title">Borrar todas las solicitudes</h2>
          <p>Â¿Borrar todas las solicitudes del dÃ­a "<span id="wipe-all-day"></span>"?</p>
          <div class="actions modal-actions">
            <button type="button" id="wipe-all-cancel" class="btn">Cancelar</button>
            <button type="button" id="wipe-all-confirm" class="btn">Borrar</button>
          </div>
        </div>
      </div>

      <!-- Modal de cambios por versiÃ³n (changelog) -->
      <div id="changelog-modal" class="modal-overlay" hidden>
        <div class="modal changelog-modal" role="dialog" aria-modal="true" aria-labelledby="changelog-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="changelog-modal-title">Mejoras por versiÃ³n</h2>
          
          <div class="changelog-content">
            <h3>v2.1 (ACTUAL) ğŸš€</h3>
            <ul>
              <li>âœ¨ <strong>Nuevas Figuras y Temas:</strong> Se aÃ±adieron figuras visuales (partÃ­culas) y mejoras en los temas para una experiencia mÃ¡s inmersiva.</li>
              <li>ğŸ” <strong>Transparencia:</strong> Nueva pestaÃ±a para ver el desglose detallado de puntos y acciones.</li>
              <li>ğŸ” <strong>Nuevo MenÃº:</strong> MenÃº rediseÃ±ado y mejorado para facilitar la navegaciÃ³n.</li>
              <li>ğŸ† <strong>Puntos Mejorados:</strong> Sistema de puntos optimizado y mÃ¡s justo.</li>
            </ul>

            <h3>v2.0</h3>
            <ul>
              <li>ğŸ“Š <strong>EstadÃ­sticas Precisas:</strong> CorrecciÃ³n total en el cÃ¡lculo de puntos y lecturas de canciones pedidas/reproducidas.</li>
              <li>ğŸ“ˆ <strong>Barra de EstadÃ­sticas en Vivo:</strong> Nuevo ticker superior con datos en tiempo real de Top usuarios, canciones y artistas.</li>
              <li>âœ¨ <strong>Mejora Visual:</strong> Interfaz refinada y mÃ¡s limpia para una mejor experiencia.</li>
              <li>ğŸ” <strong>Transparencia Total:</strong> Nueva secciÃ³n de desglose detallado de puntos para que sepas exactamente de dÃ³nde viene cada punto.</li>
              <li>ğŸ’° <strong>CompensaciÃ³n:</strong> Se detectaron errores previos en el cÃ¡lculo de puntos. Los usuarios activos recibirÃ¡n una bonificaciÃ³n automÃ¡tica por las molestias.</li>
            </ul>

            <h3>v1.9 (actual)</h3>
          <ul>
            <li>ğŸ“‹ MenÃº reparado en laptops: posicionamiento en desktop (>768px), ancho fijo 220px y reubicaciÃ³n arriba si no cabe.</li>
            <li>ğŸ–ï¸ Insignias: z0-fan muestra â€œz0â€, VIP negro estÃ¡ndar y VIP Platino muestra â€œVIPâ€ en plata.</li>
            <li>ğŸ‘¤ Cambio de insignias desde â€œMi Perfilâ€ para cualquier usuario.</li>
            <li>âœ¨ Notificaciones estilizadas en perfil para feedback de acciones.</li>
          </ul>

            <h3>v1.7</h3>
          <ul>
            <li>ğŸ¯ BotÃ³n dedicado para marcar canciones: Cada canciÃ³n ahora tiene un botÃ³n especÃ­fico (âœ“) para marcar/desmarcar.</li>
            <li>ğŸ“ Texto seleccionable: Ahora puedes seleccionar y copiar el texto de las canciones sin interferir con la funcionalidad de marcado.</li>
            <li>ğŸ–±ï¸ SeparaciÃ³n de funciones: El botÃ³n maneja el marcado y el texto permite selecciÃ³n independiente.</li>
            <li>ğŸ“± OptimizaciÃ³n responsive: El botÃ³n se adapta perfectamente a diferentes tamaÃ±os de pantalla.</li>
            <li>ğŸ¨ Estados visuales mejorados: El botÃ³n cambia de apariencia cuando la canciÃ³n estÃ¡ marcada (verde).</li>
            <li>ğŸŒ™ Compatibilidad con temas: Funciona perfectamente en tema claro y oscuro.</li>
            <li>âš¡ Experiencia de usuario mejorada: InteracciÃ³n mÃ¡s intuitiva y sin conflictos entre acciones.</li>
            <li>ğŸ† CorrecciÃ³n de puntos VIP: Los usuarios VIP y Z0-VIP ahora reciben correctamente sus puntos de logro.</li>
            <li>ğŸ§ Nueva recompensa "ConviÃ©rtete en fan": Los usuarios pueden obtener el estado de Fan Z0 permanente por 2000 puntos.</li>
            <li>ğŸ”„ Sistema de recÃ¡lculo mejorado: Corrige automÃ¡ticamente inconsistencias en puntos e insignias de usuarios.</li>
            <li>ğŸ› ï¸ Herramienta de mantenimiento: BotÃ³n de recÃ¡lculo masivo en el panel de administraciÃ³n para corregir datos.</li>
            <li>ğŸ”§ Mejorado cÃ¡lculo de puntos de logros existentes y nuevos.</li>
            <li>ğŸ”§ Implementada validaciÃ³n y correcciÃ³n automÃ¡tica de datos.</li>
            <li>ğŸ”§ PreservaciÃ³n correcta de estructura de rachas y estadÃ­sticas.</li>
            <li>ğŸ“… Calendario de rachas mensual con navegaciÃ³n por mes y aÃ±o.</li>
            <li>ğŸ—“ï¸ DÃ­as de otros meses atenuados y cabecera de dÃ­as de la semana.</li>
            <li>ğŸŒ™ğŸ“± Controles del calendario con soporte para tema oscuro y responsive.</li>
            <li>ğŸ¨ Leyenda de niveles de actividad mostrada en una sola lÃ­nea.</li>
            <li>ğŸ”¥ Reglas de racha refinadas: dÃ­a vÃ¡lido con 2+ usuarios distintos y tÃº participando; continuidad solo si el dÃ­a previo fue vÃ¡lido; rÃ©cord preservado.</li>
          </ul>

            <h3>v1.6</h3>
          <ul>
            <li>ğŸµ Canciones clickeables: Marcado de las canciones como reproducidas con un simple clic.</li>
            <li>ğŸ”’ Sistema de clics restringido: Solo el dispositivo ADMIN puede modificar canciones, otros solo ven cambios.</li>
            <li>âœ… Indicador visual: Las canciones reproducidas se muestran con colores contrastantes segÃºn el tema.</li>
            <li>ğŸ’¾ Persistencia local: El estado de las canciones se guarda automÃ¡ticamente por dÃ­a.</li>
            <li>ğŸ¨ AdaptaciÃ³n temÃ¡tica: Los colores de las canciones reproducidas se adaptan al tema seleccionado.</li>
            <li>ğŸ›¡ï¸ Seguridad de doble capa: ValidaciÃ³n tanto en interfaz como en base de datos Firebase.</li>
          </ul>

          <h3>v1.5</h3>
          <ul>
            <li>ğŸ Sistema de canje de puntos: intercambia tus puntos por recompensas exclusivas.</li>
            <li>ğŸ’° Costos de recompensas rebalanceados: ahora desde 600 puntos mÃ­nimo para mayor valor.</li>
            <li>ğŸ¯ Sistema de puntos mejorado: 25 puntos por canciÃ³n, bonos VIP de 40 puntos.</li>
            <li>ğŸ† Recompensas exclusivas: Cambia tus puntos por recompensas</li>
            <li>âš¡ Bonificaciones especiales: primer canciÃ³n del dÃ­a (+50), fines de semana (+10).</li>
            <li>ğŸ“± Experiencia mÃ³vil perfeccionada: botones touch-friendly de 44px mÃ­nimo.</li>
            <li>âœ¨ Modales de confirmaciÃ³n mejorados: visibilidad garantizada en todos los dispositivos.</li>
            <li>ğŸ”§ Interfaz responsive optimizada: diseÃ±o adaptativo para mÃ³viles y tablets.</li>
            <li>ğŸ® Sistema de gamificaciÃ³n balanceado: progresiÃ³n mÃ¡s satisfactoria y justa.</li>
            <li>âš¡ Solicitudes de recompensas: sistema de aprobaciÃ³n con notificaciones.</li>
          </ul>

          <h3>v1.4</h3>
          <ul>
            <li>ğŸ® Modal de gamificaciÃ³n con logros, rachas y estadÃ­sticas personales.</li>
            <li>ğŸ“Š Sistema de estadÃ­sticas avanzadas con grÃ¡ficos y mÃ©tricas detalladas.</li>
            <li>ğŸ” BÃºsqueda global mejorada: navega a cualquier fecha con un click.</li>
            <li>ğŸ“… Resultados de bÃºsqueda con fechas formateadas ("Hoy", "Ayer", etc.).</li>
            <li>ğŸ¨ Sistema de temas completo: modo claro/oscuro con 5 colores de acento.</li>
            <li>ğŸ”„ SincronizaciÃ³n de temas en tiempo real entre todas las pÃ¡ginas abiertas.</li>
            <li>ğŸ’¾ Persistencia de preferencias de tema con migraciÃ³n automÃ¡tica de datos.</li>
            <li>ğŸ¯ Modal de temas rediseÃ±ado con botones de cerrar y restablecer funcionales.</li>
            <li>ğŸ“± Centrado perfecto del contenido en pantallas pequeÃ±as y mÃ³viles.</li>
            <li>âš¡ BÃºsqueda con debounce y indicadores de carga para mejor UX.</li>
            <li>ğŸ¨ Scrollbars personalizados en secciones de gamificaciÃ³n.</li>
            <li>ğŸ“± Calendario de actividad reciente centrado y optimizado.</li>
          </ul>

          <h3>v1.3</h3>
          <ul>
            <li>Buscador con lupita y opciÃ³n en menÃº; resultados en tiempo real.</li>
            <li>Modal para "Borrar todas las solicitudes" (sin pop-up nativo).</li>
            <li>Borrar usuario en Admin con modal y permisos ajustados.</li>
            <li>TipografÃ­a global Avenir y mejoras de responsive en mÃ³viles.</li>
            <li>Panel Admin: botones "Agregar/Borrar" apilados y selector ajustado.</li>
          </ul>

          <h3>v1.2</h3>
          <ul>
            <li>Quitar VIP con modal (botÃ³n â€œÃ—â€).</li>
            <li>Selector de usuarios registrados y gestiÃ³n de VIP desde Admin.</li>
            <li>Correcciones de eventos en Admin y limpieza de cÃ³digo.</li>
          </ul>

          <h3>v1.1</h3>
          <ul>
            <li>Modo Admin bÃ¡sico, filtro VIP y selecciÃ³n de dÃ­a.</li>
            <li>SuscripciÃ³n en tiempo real a solicitudes y VIP.</li>
          </ul>
          </div>

          <div class="actions modal-actions">
            <button type="button" id="changelog-close" class="btn">Cerrar</button>
          </div>
        </div>
      </div>

      <!-- Modal de EstadÃ­sticas -->
      <div id="stats-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="stats-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="stats-modal-title">ğŸ“Š EstadÃ­sticas</h2>
          
          <div class="stats-tabs">
            <button type="button" class="stats-tab active" data-tab="general">General</button>
            <button type="button" class="stats-tab" data-tab="songs">Canciones</button>
            <button type="button" class="stats-tab" data-tab="artists">Artistas</button>
            <button type="button" class="stats-tab" data-tab="users">Usuarios</button>
          </div>

          <div class="stats-content">
            <div id="stats-general" class="stats-panel active">
              <div class="stats-grid">
                <div class="stat-card">
                  <div class="stat-number" id="total-songs">0</div>
                  <div class="stat-label">Total de canciones</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number" id="total-users">0</div>
                  <div class="stat-label">Usuarios Ãºnicos</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number" id="total-artists">0</div>
                  <div class="stat-label">Artistas Ãºnicos</div>
                </div>
                <div class="stat-card">
                  <div class="stat-number" id="today-songs">0</div>
                  <div class="stat-label">Canciones hoy</div>
                </div>
              </div>
            </div>

            <div id="stats-songs" class="stats-panel">
              <h3>ğŸµ Top Canciones</h3>
              <div id="top-songs-list" class="stats-list"></div>
            </div>

            <div id="stats-artists" class="stats-panel">
              <h3>ğŸ¤ Top Artistas</h3>
              <div id="top-artists-list" class="stats-list"></div>
            </div>

            <div id="stats-users" class="stats-panel">
              <h3>ğŸ‘¥ Usuarios MÃ¡s Activos</h3>
              <div id="top-users-list" class="stats-list"></div>
            </div>
          </div>

          <div class="actions modal-actions">
            <button type="button" id="stats-close" class="btn">Cerrar</button>
          </div>
        </div>
      </div>

      <!-- Modal de GamificaciÃ³n -->
      <div id="gamification-modal" class="modal-overlay" hidden>
        <div class="modal gamification-modal" role="dialog" aria-modal="true" aria-labelledby="gamification-modal-title">
          <button type="button" id="gamification-close-x" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="gamification-modal-title">ğŸ† Mi Perfil Musical</h2>
          
          <!-- InformaciÃ³n del Usuario -->
          <div class="user-profile">
            <div class="user-avatar">ğŸµ</div>
            <div class="user-info">
              <h3 id="user-name">Usuario</h3>
              <div class="user-level">
                <span id="user-level-name">Novato</span>
                <span id="user-level-number">Nivel 1</span>
              </div>
            </div>
            <div class="user-points">
              <div class="points-display">
                <span id="user-points">0</span>
                <span class="points-label">puntos</span>
              </div>
            </div>
          </div>

          <!-- Selector de Usuario -->
          <div class="user-selector">
            <label for="gamification-user-select">ğŸ‘¤ Ver perfil de usuario:</label>
            <div class="user-selector-controls">
              <select id="gamification-user-select" class="user-select">
                <option value="">Selecciona un usuario</option>
              </select>
              <button type="button" id="back-to-my-profile" class="btn btn-primary" style="display: none;">
                ğŸ‘¥ Cambiar Usuario
              </button>
            </div>
          </div>

          <div class="badge-display">
            <label for="badge-select">ğŸ–ï¸ Insignia a mostrar:</label>
            <select id="badge-select" class="user-select">
              <option value="">Ninguna</option>
              <option value="z0-fan">z0-Fan</option>
              <option value="z0-vip">z0Vip</option>
              <option value="z0-platino">VIP Platino</option>
              <option value="vip">VIP</option>
              <option value="donador">Donador</option>
            </select>
            <div id="earned-badges" class="earned-badges"></div>
          </div>

          <!-- Barra de Progreso -->
          <div class="level-progress">
            <div class="progress-bar">
              <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-text">
              <span id="current-xp">0</span> / <span id="next-level-xp">100</span> XP para el siguiente nivel
            </div>
          </div>

          <!-- Tabs de GamificaciÃ³n -->
          <div class="gamification-tabs">
            <button type="button" class="gamification-tab active" data-tab="achievements">ğŸ… Logros</button>
            <button type="button" class="gamification-tab" data-tab="streaks">ğŸ”¥ Rachas</button>
            <button type="button" class="gamification-tab" data-tab="stats">ğŸ“ˆ EstadÃ­sticas</button>
            <button type="button" class="gamification-tab" data-tab="breakdown">ğŸ” Transparencia</button>
          </div>

          <div class="gamification-content">
            <!-- Panel de Logros -->
            <div id="gamification-achievements" class="gamification-panel active">
              <div id="achievements-list" class="achievements-grid">
                <!-- Los logros se cargarÃ¡n dinÃ¡micamente -->
              </div>
            </div>

            <!-- Panel de Rachas -->
            <div id="gamification-streaks" class="gamification-panel">
              <div class="streaks-container">
                <div class="streak-card">
                  <div class="streak-icon">ğŸ”¥</div>
                  <div class="streak-info">
                    <h4>Racha Actual</h4>
                    <div class="streak-count" id="current-streak">0 dÃ­as</div>
                    <div class="streak-desc">DÃ­as consecutivos pidiendo canciones</div>
                  </div>
                </div>
                
                <div class="streak-card">
                  <div class="streak-icon">â­</div>
                  <div class="streak-info">
                    <h4>Mejor Racha</h4>
                    <div class="streak-count" id="best-streak">0 dÃ­as</div>
                    <div class="streak-desc">Tu rÃ©cord personal</div>
                  </div>
                </div>

                <div class="streak-calendar">
                  <h4>ğŸ“… Actividad Reciente</h4>
                  <!-- Controles de navegaciÃ³n del calendario de rachas -->
                  <div class="calendar-navigation" aria-label="NavegaciÃ³n de calendario">
                    <button type="button" id="prev-month" class="calendar-nav-btn" title="Mes anterior" aria-label="Mes anterior">â€¹</button>
                    <div class="calendar-month-selector">
                      <select id="month-select" class="calendar-select" aria-label="Seleccionar mes">
                        <option value="0">Enero</option>
                        <option value="1">Febrero</option>
                        <option value="2">Marzo</option>
                        <option value="3">Abril</option>
                        <option value="4">Mayo</option>
                        <option value="5">Junio</option>
                        <option value="6">Julio</option>
                        <option value="7">Agosto</option>
                        <option value="8">Septiembre</option>
                        <option value="9">Octubre</option>
                        <option value="10">Noviembre</option>
                        <option value="11">Diciembre</option>
                      </select>
                      <select id="year-select" class="calendar-select" aria-label="Seleccionar aÃ±o">
                        <!-- Se llena dinÃ¡micamente -->
                      </select>
                    </div>
                    <button type="button" id="next-month" class="calendar-nav-btn" title="Mes siguiente" aria-label="Mes siguiente">â€º</button>
                  </div>
                  <!-- Cabecera de dÃ­as de la semana -->
                  <div class="calendar-weekdays" aria-hidden="true">
                    <div class="weekday">Dom</div>
                    <div class="weekday">Lun</div>
                    <div class="weekday">Mar</div>
                    <div class="weekday">MiÃ©</div>
                    <div class="weekday">Jue</div>
                    <div class="weekday">Vie</div>
                    <div class="weekday">SÃ¡b</div>
                  </div>
                  <div id="streak-calendar-grid" class="calendar-grid" aria-live="polite">
                    <!-- El calendario se generarÃ¡ dinÃ¡micamente -->
                  </div>
                  <div class="activity-legend">
                    <div class="legend-title">Nivel de actividad:</div>
                    <div class="legend-items">
                      <div class="legend-item">
                        <div class="legend-color activity-low"></div>
                        <span>1 canciÃ³n</span>
                      </div>
                      <div class="legend-item">
                        <div class="legend-color activity-medium"></div>
                        <span>2 canciones</span>
                      </div>
                      <div class="legend-item">
                        <div class="legend-color activity-high"></div>
                        <span>3-4 canciones</span>
                      </div>
                      <div class="legend-item">
                        <div class="legend-color activity-very-high"></div>
                        <span>5-6 canciones</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Panel de EstadÃ­sticas Personales -->
            <div id="gamification-stats" class="gamification-panel">
              <div class="personal-stats-container">
                <div class="personal-stats-grid">
                  <div class="stat-card">
                    <div class="stat-icon">ğŸµ</div>
                    <div class="stat-number" id="personal-total-songs">0</div>
                    <div class="stat-label">Canciones pedidas</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">â–¶ï¸</div>
                    <div class="stat-number" id="personal-total-played">0</div>
                    <div class="stat-label">Canciones reproducidas</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">ğŸ¤</div>
                    <div class="stat-number" id="personal-unique-artists">0</div>
                    <div class="stat-label">Artistas Ãºnicos</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">ğŸ“…</div>
                    <div class="stat-number" id="personal-active-days">0</div>
                    <div class="stat-label">DÃ­as activos</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">ğŸ†</div>
                    <div class="stat-number" id="personal-rank">-</div>
                    <div class="stat-label">PosiciÃ³n global</div>
                  </div>
                </div>

                <div class="favorite-genres">
                  <h4>ğŸ¼ Tus GÃ©neros Favoritos</h4>
                  <div id="favorite-genres-list" class="genres-list">
                    <!-- Se generarÃ¡ dinÃ¡micamente -->
                  </div>
                </div>
              </div>
            </div>
            <div id="gamification-breakdown" class="gamification-panel">
              <div class="personal-stats-container">
                <div class="personal-stats-grid">
                  <div class="stat-card">
                    <div class="stat-icon">â–¶ï¸</div>
                    <div class="stat-number" id="breakdown-played-base">0</div>
                    <div class="stat-label">Canciones reproducidas Ã— 25</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">ğŸ‘‘</div>
                    <div class="stat-number" id="breakdown-vip-bonus">0</div>
                    <div class="stat-label">Bono VIP Ã— 40</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">ğŸ“…</div>
                    <div class="stat-number" id="breakdown-daily-bonus">0</div>
                    <div class="stat-label">Bono diario Ã— 5</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">ğŸ…</div>
                    <div class="stat-number" id="breakdown-achievements">0</div>
                    <div class="stat-label">Logros / Racha / Ajustes</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">ğŸ</div>
                    <div class="stat-number" id="breakdown-streak-residual">0</div>
                    <div class="stat-label">Canjes</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-icon">ğŸ’°</div>
                    <div class="stat-number" id="breakdown-total">0</div>
                    <div class="stat-label">Total</div>
                  </div>
                </div>
                <div class="favorite-genres">
                  <h4>ğŸ“‹ Detalle</h4>
                  <div id="breakdown-detail-list" class="genres-list"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="actions modal-actions">
          </div>
        </div>
      </div>

      <!-- Modal de Puntos -->
      <div id="rewards-modal" class="modal-overlay" hidden>
        <div class="modal rewards-modal" role="dialog" aria-modal="true" aria-labelledby="rewards-modal-title">
          <button type="button" id="rewards-close-x" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <h2 id="rewards-modal-title">ğŸ Puntos</h2>
          
          <!-- Selector de Usuario -->
          <div class="user-selector">
            <label for="rewards-user-select">ğŸ‘¤ Selecciona tu usuario:</label>
            <select id="rewards-user-select" class="user-select">
              <option value="">Selecciona un usuario</option>
            </select>
          </div>

          <!-- InformaciÃ³n del Usuario Seleccionado -->
          <div class="user-info-section">
            <div class="user-display">
              <span class="user-icon">ğŸ‘¤</span>
              <span id="rewards-user-info">Selecciona un usuario</span>
            </div>
            <div class="user-points-display">
              <span class="points-icon">ğŸ’°</span>
              <span id="rewards-user-points">0</span>
              <span class="points-label">puntos disponibles</span>
            </div>
          </div>

          <div class="gamification-tabs">
            <button type="button" class="points-tab active" data-tab="redeem">ğŸ Canje de Puntos</button>
            <button type="button" class="points-tab" data-tab="breakdown">ğŸ“‹ Desglose de Puntos</button>
          </div>
          <div class="gamification-content">
            <div id="points-redeem" class="points-panel active">
              <div class="rewards-section">
                <h3>ğŸ Recompensas Disponibles</h3>
                <div id="rewards-list" class="rewards-grid"></div>
              </div>
              <div class="pending-rewards-section">
                <h3>ğŸ“‹ Solicitudes Pendientes de AprobaciÃ³n</h3>
                <div id="pending-requests" class="pending-rewards-list">
                  <p class="no-pending">No tienes solicitudes pendientes</p>
                </div>
              </div>
            </div>
            <div id="points-breakdown" class="points-panel">
              <div id="points-breakdown-content" class="favorite-genres"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Modal de ConfirmaciÃ³n -->
      <div id="confirmation-modal" class="modal-overlay" hidden>
        <div class="modal confirmation-modal" role="dialog" aria-modal="true" aria-labelledby="confirmation-modal-title">
          <button type="button" id="confirmation-close-x" class="modal-close-btn" aria-label="Cerrar">Ã—</button>
          <div class="confirmation-content">
            <div class="confirmation-icon" id="confirmation-icon">â„¹ï¸</div>
            <h3 id="confirmation-title">ConfirmaciÃ³n</h3>
            <p id="confirmation-message">Â¿EstÃ¡s seguro?</p>
            <div class="confirmation-buttons">
              <button type="button" id="confirmation-cancel" class="btn-secondary">Cancelar</button>
              <button type="button" id="confirmation-confirm" class="btn-primary">Confirmar</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Modal de Temas -->
      <div id="theme-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="theme-modal-title">
          <button type="button" class="modal-close-btn" aria-label="Cerrar modal">&times;</button>
          <h2 id="theme-modal-title">ğŸ¨ Personalizar Tema</h2>
          
          <div class="theme-options accordion">
            <!-- SecciÃ³n: Modo de Color (Abierto por defecto) -->
            <div class="accordion-item active">
              <button type="button" class="accordion-header">
                 <span>Modo de Color</span>
                 <span class="accordion-icon">â–¼</span>
              </button>
              <div class="accordion-content">
                <div class="theme-grid">
                  <button type="button" class="theme-option active" data-theme="light">
                    <div class="theme-preview light-preview"></div>
                    <span>Claro</span>
                  </button>
                  <button type="button" class="theme-option" data-theme="dark">
                    <div class="theme-preview dark-preview"></div>
                    <span>Oscuro</span>
                  </button>
                </div>
              </div>
            </div>

            <!-- SecciÃ³n: Colores de Acento -->
            <div class="accordion-item">
              <button type="button" class="accordion-header">
                 <span>Colores de Acento</span>
                 <span class="accordion-icon">â–¼</span>
              </button>
              <div class="accordion-content">
                <div class="theme-grid">
                  <button type="button" class="theme-color active" data-color="default">
                    <div class="color-preview" style="background: #000;"></div>
                    <span>Negro</span>
                  </button>
                  <button type="button" class="theme-color" data-color="blue">
                    <div class="color-preview" style="background: #2563eb;"></div>
                    <span>Azul</span>
                  </button>
                  <button type="button" class="theme-color" data-color="green">
                    <div class="color-preview" style="background: #16a34a;"></div>
                    <span>Verde</span>
                  </button>
                  <button type="button" class="theme-color" data-color="purple">
                    <div class="color-preview" style="background: #9333ea;"></div>
                    <span>Morado</span>
                  </button>
                  <button type="button" class="theme-color" data-color="red">
                    <div class="color-preview" style="background: #dc2626;"></div>
                    <span>Rojo</span>
                  </button>
                  <button type="button" class="theme-color" data-color="pink">
                    <div class="color-preview" style="background: #ec4899;"></div>
                    <span>Rosa</span>
                  </button>
                  <button type="button" class="theme-color" data-color="magenta">
                    <div class="color-preview" style="background: #d946ef;"></div>
                    <span>Magenta</span>
                  </button>
                  <button type="button" class="theme-color" data-color="cyan">
                    <div class="color-preview" style="background: #06b6d4;"></div>
                    <span>Cian</span>
                  </button>
                  <button type="button" class="theme-color" data-color="orange">
                    <div class="color-preview" style="background: #f97316;"></div>
                    <span>Naranja</span>
                  </button>
                </div>
              </div>
            </div>

            <!-- SecciÃ³n: Forma del Fondo -->
            <div class="accordion-item">
              <button type="button" class="accordion-header">
                 <span>Forma del Fondo</span>
                 <span class="accordion-icon">â–¼</span>
              </button>
              <div class="accordion-content">
                <div class="theme-grid">
                  <button type="button" class="theme-shape active" data-shape="orb">
                    <div class="shape-preview shape-orb"></div>
                    <span>Orb</span>
                  </button>
                  <button type="button" class="theme-shape" data-shape="triangle">
                    <div class="shape-preview shape-triangle"></div>
                    <span>TriÃ¡ngulo</span>
                  </button>
                  <button type="button" class="theme-shape" data-shape="hexagon">
                    <div class="shape-preview shape-hexagon"></div>
                    <span>Teseracto</span>
                  </button>
                </div>
              </div>
            </div>

            <!-- SecciÃ³n: Cantidad de PartÃ­culas -->
            <div class="accordion-item">
              <button type="button" class="accordion-header">
                 <span>Cantidad de PartÃ­culas</span>
                 <span class="accordion-icon">â–¼</span>
              </button>
              <div class="accordion-content">
                <div class="particle-control" style="padding: 0 4px;">
                  <input type="range" id="theme-particles" min="100" max="2000" step="100" value="800" style="width: 100%; margin-bottom: 8px; cursor: pointer;">
                  <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-secondary, #666);">
                    <span>Pocas</span>
                    <span>Muchas</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- SecciÃ³n: Transparencia -->
            <div class="accordion-item">
              <button type="button" class="accordion-header">
                 <span>Transparencia de Fondo</span>
                 <span class="accordion-icon">â–¼</span>
              </button>
              <div class="accordion-content">
                <div class="transparency-control" style="padding: 0 4px;">
                  <input type="range" id="theme-transparency" min="0" max="100" value="0" style="width: 100%; margin-bottom: 8px; cursor: pointer;">
                  <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-secondary, #666);">
                    <span>Opaco</span>
                    <span>Transparente</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="actions modal-actions">
            <button type="button" id="theme-reset" class="btn">Restablecer</button>
            <button type="button" id="theme-close" class="btn">Cerrar</button>
          </div>
        </div>
      </div>

      <div class="list-scroll-container">
        <section class="list" aria-live="polite">
          <div class="list-header" role="group" aria-label="Encabezados de lista">
            <span class="col col-time">Hora</span>
            <span class="col col-usuario">Usuario</span>
            <span class="col col-cancion">CanciÃ³n</span>
            <span class="col col-artista">Artista</span>
            <span class="col col-cancion-artista">CanciÃ³n / Artista</span>
            <span class="col col-action">âœ“</span>
          </div>
          <div id="edit-actions-bar" class="edit-actions-bar" hidden>
            <button type="button" id="undo-delete-btn" class="btn btn-primary" disabled>â†©ï¸ Deshacer</button>
            <button type="button" id="redo-delete-btn" class="btn btn-primary" disabled>â†ªï¸ Rehacer</button>
            <button type="button" id="open-deleted-btn" class="btn btn-warn">
              ğŸ—‘ï¸ Eliminadas <span id="deleted-count-badge" hidden>0</span>
            </button>
            <span class="edit-spacer"></span>
            <button type="button" id="clear-deleted-btn" class="btn" title="Vaciar eliminadas del dÃ­a">ğŸ§¹ Limpiar</button>
          </div>
          <ul id="solicitudes-list" class="items"></ul>
          <p id="empty" class="empty" hidden>AÃºn no hay solicitudes.</p>
        </section>
      </div>
    </section>
  </main>

  <div id="deleted-modal" class="modal-overlay" hidden>
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="deleted-modal-title">
      <button type="button" class="modal-close-btn" id="deleted-close-x" aria-label="Cerrar">Ã—</button>
      <h2 id="deleted-modal-title">Canciones eliminadas</h2>
      <div class="field" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <label for="deleted-day-select" style="font-weight:800;">Ver dÃ­a:</label>
        <select id="deleted-day-select"></select>
        <span style="flex:1 1 auto;"></span>
        <button type="button" id="restore-all-deleted" class="btn btn-primary">Restaurar todo</button>
      </div>
      <div id="deleted-list" class="deleted-list"></div>
      <div class="actions modal-actions">
        <button type="button" id="deleted-close" class="btn">Cerrar</button>
      </div>
    </div>
  </div>

  <script>
    (function () {
      console.log('ğŸš€ Iniciando aplicaciÃ³n v2.1 - Fixes applied');
       window.playedSongsCache = {};
      const firebaseConfig = {
        apiKey: "AIzaSyA6c3EaIvuPEfM6sTV0YHqCBHuz35ZmNIU",
        authDomain: "zero-strom-web.firebaseapp.com",
        projectId: "zero-strom-web",
        storageBucket: "zero-strom-web.firebasestorage.app",
        messagingSenderId: "758369466349",
        appId: "1:758369466349:web:f2ced362a5a049c70b59e4"
      };
      
      let db = null;
      try {
        if (typeof firebase !== 'undefined' && firebase.apps) {
          if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
          }
          db = firebase.firestore();
          console.log('Firebase initialized successfully');
        } else {
          console.warn('Firebase SDK not loaded - Offline mode');
        }
      } catch (e) {
        console.error('Error initializing Firebase:', e);
      }
      
      window.db = db;
      window.START_POINTS_DAY = window.START_POINTS_DAY || '';
      function normalizeDay(str){
        const raw = String(str||'').trim();
        if (!raw) return '';
        // YYYY-MM-DD or YYYY/MM/DD
        if (/^\d{4}[-\/]\d{2}[-\/]\d{2}$/.test(raw)) return raw.replace(/\//g,'-');
        // DD-MM-YYYY or DD.MM.YYYY or DD/MM/YYYY
        const m = raw.match(/^(\d{2})[\-\/.](\d{2})[\-\/.](\d{4})$/);
        if (m) return `${m[3]}-${m[2]}-${m[1]}`;
        return raw;
      }
      window.isOnOrAfterStart = function(day){
        const d = normalizeDay(day);
        const s = normalizeDay(window.START_POINTS_DAY||'2025-10-27'); // Default fallback
        return d && s ? (d >= s) : true;
      }
      async function determineStartDay(){
        // HARDCODED START DATE per user requirement: 27 Oct 2025
        window.START_POINTS_DAY = '2025-10-27';
        return window.START_POINTS_DAY;
      }

      async function computeQuickUserPlayedSet(usuario) {
        const rawUser = String(usuario||'').trim();
        const user = rawUser.replace(/^@/, '');
        const sanitize = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
        const prefix = sanitize(`${user}-`);
        const out = new Set();
        
        // Prioritize local storage for days we have locally
        const localPlayedMap = JSON.parse(localStorage.getItem('playedSongs') || '{}');
        const localDays = new Set(Object.keys(localPlayedMap));

        try {
          const snap = await db.collection('playedSongs').get();
          snap.forEach(doc => {
            const dayId = normalizeDay(doc.id||'');
            if (dayId && typeof window.isOnOrAfterStart === 'function' && !window.isOnOrAfterStart(dayId)) return;
            
            // If we have local data for this day, skip Firestore (Local is authoritative for this device)
            if (localDays.has(dayId)) return;

            const d = doc.data()||{};
            const arr = Array.isArray(d.songs) ? d.songs : (Array.isArray(d.list) ? d.list : (Array.isArray(d.songIds) ? d.songIds : []));
            for (let i=0;i<arr.length;i++) {
              const id = sanitize(arr[i]);
              if (id.startsWith(prefix)) {
                out.add(id);
              }
            }
          });
        } catch (_) {}
        
        // Add local data
        localDays.forEach(day => {
            if (typeof window.isOnOrAfterStart === 'function' && !window.isOnOrAfterStart(day)) return;
            const arr = Array.isArray(localPlayedMap[day]) ? localPlayedMap[day] : [];
            arr.forEach(x => {
                const id = sanitize(x);
                if (id.startsWith(prefix)) out.add(id);
            });
        });

        return out;
      }

      function buildLocalUserPlayedSet(usuario) {
        const norm = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
        const localPlayedMap = JSON.parse(localStorage.getItem('playedSongs') || '{}');
        const sanitize = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
        const prefix = sanitize(`${norm}-`);
        const ids = new Set();
        const days = Object.keys(localPlayedMap||{});
        for (let i=0;i<days.length;i++) {
          const arr = Array.isArray(localPlayedMap[days[i]]) ? localPlayedMap[days[i]] : [];
          for (let j=0;j<arr.length;j++) {
            const id = sanitize(arr[j]);
            if (id.startsWith(prefix)) ids.add(id);
          }
        }
        return ids;
      }

      async function getConsistentPlayedCountForUser(usuario) {
        try {
          const userKey = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
        

          // 2) Conjuntos de IDs (Local + Firestore)
          const setPlayed = await computeQuickUserPlayedSet(usuario);
          
          try {
            const qs = await db.collection('systemEvents').where('type','==','togglePlayed').where('usuario','==',userKey).get();
            const sanitize = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
            const latest = {};
            qs.forEach(doc => {
              const d = doc.data()||{};
              const day = String(d.day||'');
              const sid = sanitize(String(d.songId||''));
              if (!sid) return;
              const ts = d.ts && d.ts.toMillis ? d.ts.toMillis() : 0;
              const k = `${sid}|${day}`;
              const cur = latest[k];
              if (!cur || ts >= cur.ts) latest[k] = { action:String(d.action||'').toLowerCase(), sid };
            });
            Object.keys(latest).forEach(k => { 
              const it = latest[k]; 
              if (it && it.action==='mark') setPlayed.add(it.sid); 
              else if (it && it.action==='unmark') setPlayed.delete(it.sid);
            });
          } catch(_){ }
          
          return setPlayed.size;
        } catch(_){ return 0; }
      }
      async function auditPlayedSourcesForUser(usuario) {
        const userKey = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
        const out = { user: userKey, totalsDoc: 0, events: 0, playedByDay: 0, localStorage: 0, union: 0 };
        try { out.totalsDoc = await getQuickPlayedTotalFromHistory(usuario) || 0; } catch(_){ }
        try {
          const qs = await db.collection('systemEvents').where('type','==','togglePlayed').where('usuario','==',userKey).get();
          const latest = {}; qs.forEach(doc => { const d = doc.data()||{}; const day = String(d.day||''); const sid = String(d.songId||'').toLowerCase().replace(/[^a-z0-9-]/g,''); const ts = d.ts && d.ts.toMillis ? d.ts.toMillis() : 0; const k = `${sid}|${day}`; const cur = latest[k]; if (!cur || ts >= cur.ts) latest[k] = { action:String(d.action||'').toLowerCase(), sid }; });
          const set = new Set(); Object.keys(latest).forEach(k => { const it = latest[k]; if (it && it.action==='mark') set.add(it.sid); });
          out.events = set.size;
          const union = new Set([...set]);
          const snap = await db.collection('playedSongs').get();
          snap.forEach(doc => { const arr = ((doc.data()||{}).songs)||[]; (arr||[]).forEach(x => { const id = String(x||'').toLowerCase().replace(/[^a-z0-9-]/g,''); if (id.startsWith(`${userKey}-`)) { union.add(id); } }); });
          out.playedByDay = union.size - set.size;
          try { const setLocal = buildLocalUserPlayedSet(usuario); out.localStorage = setLocal.size; setLocal.forEach(id=>union.add(id)); } catch(_){ }
          out.union = union.size;
        } catch(_){ }
        return out;
      }

      async function updateUserPlayedCounter(usuario, day, delta) {
        try {
          const u = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
          const d = normalizeDay(day||'');
          if (!u || !d) return;
          const ref = db.collection('playedSongs').doc('userTotals');
          await ref.set({ totals: {}, counts: {}, lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
          const payload = { lastUpdated: firebase.firestore.FieldValue.serverTimestamp() };
          payload[`totals.${u}`] = firebase.firestore.FieldValue.increment(delta);
          payload[`counts.${d}.${u}`] = firebase.firestore.FieldValue.increment(delta);
          await ref.set(payload, { merge: true });
        } catch(_){}
      }
      async function getQuickPlayedTotalFromHistory(usuario) {
        try {
          const u = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
          if (!u) return 0;
          const doc = await db.collection('playedSongs').doc('userTotals').get();
          if (!doc.exists) return 0;
          const data = doc.data()||{};
          const totals = data.totals || {};
          return Number(totals[u]||0) || 0;
        } catch(_){ return 0; }
      }
      // ======= Aggregador incremental por usuario (evita recorrer dÃ­a por dÃ­a) =======
      window.__userPlayedAgg = window.__userPlayedAgg || { ids:{}, totals:{} };
      function loadUserPlayedAgg(){
        try {
          const idsRaw = localStorage.getItem('user_played_ids') || '{}';
          const totalsRaw = localStorage.getItem('user_played_totals') || '{}';
          const idsObj = JSON.parse(idsRaw);
          const totalsObj = JSON.parse(totalsRaw);
          const ids = {};
          Object.keys(idsObj).forEach(k => { ids[k] = new Set(Array.isArray(idsObj[k]) ? idsObj[k] : []); });
          window.__userPlayedAgg = { ids, totals: totalsObj };
        } catch(_){ window.__userPlayedAgg = { ids:{}, totals:{} }; }
      }
      function saveUserPlayedAgg(){
        try {
          const idsObj = {};
          Object.keys(window.__userPlayedAgg.ids||{}).forEach(k => { idsObj[k] = Array.from(window.__userPlayedAgg.ids[k]||new Set()); });
          localStorage.setItem('user_played_ids', JSON.stringify(idsObj));
          localStorage.setItem('user_played_totals', JSON.stringify(window.__userPlayedAgg.totals||{}));
        } catch(_){ }
      }
      function updateAggForDocForUser(u, reqPrefixes, day, arr){
        const user = String(u||'').trim().replace(/^@/,'');
        const sanitize = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
        const prefix = sanitize(`${user}-`);
        const idsMap = window.__userPlayedAgg.ids || (window.__userPlayedAgg.ids = {});
        const totalsMap = window.__userPlayedAgg.totals || (window.__userPlayedAgg.totals = {});
        const key = user.toLowerCase();
        const set = idsMap[key] || (idsMap[key] = new Set());
        if (day && !isOnOrAfterStart(day)) return;
        for (let i=0;i<arr.length;i++){
          const id = sanitize(arr[i]);
          if (!id.startsWith(prefix)) continue;
          if (reqPrefixes && reqPrefixes.size){
            let ok = false;
            for (const pf of reqPrefixes){ if (id.startsWith(pf)) { ok = true; break; } }
            if (!ok) continue;
          }
          if (!set.has(id)) {
            set.add(id);
            totalsMap[key] = (totalsMap[key]||0) + 1;
          }
        }
      }
      function getImmediatePlayedCountFromAgg(usuario){
        try {
          const key = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
          const totals = window.__userPlayedAgg.totals || {};
          const ids = window.__userPlayedAgg.ids || {};
          if (typeof totals[key] === 'number') return totals[key];
          const set = ids[key];
          return (set && set.size) ? set.size : 0;
        } catch(_){ return 0; }
      }

      firebase.auth().onAuthStateChanged((user) => {
        if (!user) {
          firebase.auth().signInAnonymously().catch((err) => {
            console.error('Error al iniciar sesiÃ³n anÃ³nima:', err);
          });
        }
        determineStartDay().then(() => {
          try {
            const u = (typeof getCurrentSelectedUser === 'function' ? getCurrentSelectedUser() : getCurrentUser());
            if (u) startCloudRealtimeForUser(u);
          } catch(_){ }
        }).catch(()=>{});
      });
      (function subscribeAllUserPoints(){
        try {
          db.collection('userStats').onSnapshot((snap) => {
            const allStr = localStorage.getItem('gamificationData') || '{}';
            const all = JSON.parse(allStr);
            snap.forEach((doc) => {
              const u = (doc.id || '').toLowerCase();
              const d = all[u] || {
                points: 0,
                level: 1,
                xp: 0,
                achievements: [],
                streaks: { current: 0, best: 0, lastActivity: null, calendar: {} },
                stats: { totalSongs: 0, uniqueArtists: 0, activeDays: 0, isVip: false }
              };
              const data = doc.data() || {};
              if (typeof data.totalPoints === 'number') d.points = data.totalPoints;
              if (typeof data.currentStreak === 'number') d.streaks.current = data.currentStreak;
              if (typeof data.bestStreak === 'number') d.streaks.best = data.bestStreak;
              if (typeof data.lastActivity === 'string') d.streaks.lastActivity = data.lastActivity;
              all[u] = d;
          });
          localStorage.setItem('gamificationData', JSON.stringify(all));
          try { if (typeof window.refreshStatsTicker === 'function') window.refreshStatsTicker(); } catch (_)
          {}
        });
      } catch (_){ }
      })();

      // VerificaciÃ³n integral de toggle y estadÃ­sticas
      window.runToggleVerification = async function(targetUser){
        const usuario = String(targetUser||getCurrentUser()||'').trim().toLowerCase();
        const day = document.getElementById('day-select')?.value || '';
        const items = Array.from(document.querySelectorAll('#solicitudes-list .item'));
        const li = items.find(x => String(x.dataset.username||'').toLowerCase() === usuario) || items[0];
        if (!li) return { ok:false, reason:'no_items' };
        const songId = li.dataset.songId;
        const beforeLocal = countLocalPlayedForUser(usuario);
        const beforeCloud = await getQuickPlayedTotalFromHistory(usuario);
        await toggleSongPlayed(li, songId, day);
        await new Promise(r => setTimeout(r, 300));
        const afterLocal = countLocalPlayedForUser(usuario);
        const afterCloud = await getQuickPlayedTotalFromHistory(usuario);
        const deltaLocal = afterLocal - beforeLocal;
        const deltaCloud = afterCloud - beforeCloud;
        console.log('AUTOTEST TOGGLE:', { usuario, day, songId, beforeLocal, afterLocal, deltaLocal, beforeCloud, afterCloud, deltaCloud });
        return { ok:true, usuario, day, beforeLocal, afterLocal, deltaLocal, beforeCloud, afterCloud, deltaCloud };
      }

      const solicitudesList = document.getElementById('solicitudes-list');
      const emptyEl = document.getElementById('empty');
      const vipOnly = document.getElementById('vip-only');
      const daySelect = document.getElementById('day-select');
      const sortSelect = document.getElementById('sort-select');

      const allUsersSelect = document.getElementById('all-users-select');
      const vipAddBtn = document.getElementById('vip-add');
      const vipListEl = document.getElementById('vip-list');
      const wipeAllBtn = document.getElementById('wipe-all');

      // Elementos para donadores
      const allUsersSelectDonador = document.getElementById('all-users-select-donador');
      const donadorAddBtn = document.getElementById('donador-add');
      const donadorListEl = document.getElementById('donador-list');

      const vipRemoveModal = document.getElementById('vip-remove-modal');
      const vipRemoveUserSpan = document.getElementById('vip-remove-user');
      const vipRemoveCancelBtn = document.getElementById('vip-remove-cancel');
      const vipRemoveConfirmBtn = document.getElementById('vip-remove-confirm');
      let pendingVipRemoveUser = null;
      let pendingVipRemoveType = 'vip'; // 'vip', 'z0' o 'donador'

      // Variables globales para los sets de usuarios
      window.vipSet = new Set();
      window.z0VipSet = new Set();
      window.donadorSet = new Set();
      let vipSet = window.vipSet;
      let z0VipSet = window.z0VipSet;
      let donadorSet = window.donadorSet;
      let unsubscribeSolicitudes = null;
      let currentDayItems = [];
      // Orden manual (compartido): suscripciÃ³n y estado actual
      let unsubscribeManualOrder = null;
      let currentManualOrder = [];

      const SORT_MODE_KEY = 'lista_sort_mode';
      const allowedSortModes = new Set(['recent', 'oldest', 'manual_recent', 'manual_fifo']);

      function getSortMode() {
        try {
          const vSel = String(sortSelect?.value || '').trim();
          const vStore = String(localStorage.getItem(SORT_MODE_KEY) || '').trim();
          const mode = vSel || vStore || 'recent';
          if (allowedSortModes.has(mode)) return mode;
        } catch (_) {}
        return 'recent';
      }

      function isManualSortMode(mode) {
        const m = String(mode || getSortMode() || '').trim();
        return m === 'manual_recent' || m === 'manual_fifo';
      }

      function compareItemsByTime(a, b, dir) {
        const ta = getItemTimeMs(a);
        const tb = getItemTimeMs(b);
        if (ta !== tb) return dir === 'desc' ? (tb - ta) : (ta - tb);

        const ha = String(a?.hora || '').trim();
        const hb = String(b?.hora || '').trim();
        if (ha && hb && ha !== hb) return dir === 'desc' ? hb.localeCompare(ha) : ha.localeCompare(hb);

        const ida = String(a?.id || a?.docId || a?.requestId || '').trim();
        const idb = String(b?.id || b?.docId || b?.requestId || '').trim();
        if (ida && idb && ida !== idb) return dir === 'desc' ? idb.localeCompare(ida) : ida.localeCompare(idb);
        return 0;
      }

      function sortItemsStable(items, dir) {
        const arr = Array.isArray(items) ? items.slice() : [];
        arr.sort((a, b) => compareItemsByTime(a, b, dir));
        return arr;
      }

      function applyDisplayOrder(items) {
        const mode = getSortMode();
        if (mode === 'oldest') return sortItemsStable(items, 'asc');
        if (mode === 'recent') return sortItemsStable(items, 'desc');
        if (mode === 'manual_fifo') return applyOrder(sortItemsStable(items, 'asc'), currentManualOrder);
        if (mode === 'manual_recent') return applyOrder(sortItemsStable(items, 'desc'), currentManualOrder);
        return sortItemsStable(items, 'desc');
      }

      function showCopyNotification(anchor) {
        try {
          const existing = document.getElementById('copy-toast');
          if (existing) existing.remove();
          const n = document.createElement('div');
          n.id = 'copy-toast';
          n.textContent = 'Contenido copiado';
          let top = 0;
          let left = 0;
          if (anchor && anchor.getBoundingClientRect) {
            const rect = anchor.getBoundingClientRect();
            top = rect.top + window.scrollY - 28;
            left = rect.left + window.scrollX + rect.width / 2;
            n.style.position = 'absolute';
            n.style.transform = 'translate(-50%, 6px)';
          } else {
            n.style.position = 'fixed';
            n.style.bottom = '16px';
            n.style.right = '16px';
          }
          if (top || top === 0) {
            n.style.top = top + 'px';
          }
          if (left || left === 0) {
            n.style.left = left + 'px';
          }
          n.style.padding = '8px 12px';
          n.style.borderRadius = '999px';
          n.style.fontSize = '12px';
          n.style.background = 'rgba(17, 24, 39, 0.9)';
          n.style.color = '#f9fafb';
          n.style.boxShadow = '0 8px 20px rgba(0,0,0,0.35)';
          n.style.zIndex = '2147483647';
          n.style.opacity = '0';
          if (!n.style.transform) n.style.transform = 'translateY(6px)';
          n.style.transition = 'opacity 0.18s ease-out, transform 0.18s ease-out';
          document.body.appendChild(n);
          requestAnimationFrame(function () {
            n.style.opacity = '1';
            n.style.transform = 'translate(-50%, 0)';
          });
          setTimeout(function () {
            n.style.opacity = '0';
            n.style.transform = 'translate(-50%, 6px)';
            setTimeout(function () {
              if (n.parentNode) n.parentNode.removeChild(n);
            }, 180);
          }, 1200);
        } catch (_) {}
      }

      function copyTextToClipboard(text, anchor) {
        if (!text) return;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text)
            .then(function () {
              showCopyNotification(anchor);
            })
            .catch(function (e) {
              console.error('Error copiando al portapapeles', e);
            });
        } else {
          const temp = document.createElement('textarea');
          temp.value = text;
          temp.style.position = 'fixed';
          temp.style.opacity = '0';
          document.body.appendChild(temp);
          temp.focus();
          temp.select();
          try {
            document.execCommand('copy');
            showCopyNotification(anchor);
          } catch (e) {}
          document.body.removeChild(temp);
        }
      }

      const editActionsBar = document.getElementById('edit-actions-bar');
      const undoDeleteBtn = document.getElementById('undo-delete-btn');
      const redoDeleteBtn = document.getElementById('redo-delete-btn');
      const openDeletedBtn = document.getElementById('open-deleted-btn');
      const clearDeletedBtn = document.getElementById('clear-deleted-btn');
      const deletedCountBadge = document.getElementById('deleted-count-badge');
      const deletedModal = document.getElementById('deleted-modal');
      const deletedCloseBtn = document.getElementById('deleted-close');
      const deletedCloseXBtn = document.getElementById('deleted-close-x');
      const deletedDaySelect = document.getElementById('deleted-day-select');
      const deletedListEl = document.getElementById('deleted-list');
      const restoreAllDeletedBtn = document.getElementById('restore-all-deleted');
      let editUndoStack = [];
      let editRedoStack = [];
      let deletedRestoreInFlight = false;

      function isEditModeActive() {
        try {
          return !!(solicitudesList && solicitudesList.classList.contains('editing'));
        } catch (_) {
          return false;
        }
      }

      function refreshEditActionsBar() {
        if (!editActionsBar) return;
        const active = isEditModeActive();
        editActionsBar.hidden = !active;
        editActionsBar.classList.toggle('active', active);
        if (!active) return;
        if (undoDeleteBtn) undoDeleteBtn.disabled = editUndoStack.length === 0;
        if (redoDeleteBtn) redoDeleteBtn.disabled = editRedoStack.length === 0;
        try { refreshDeletedCountBadge(); } catch (_) {}
      }

      function getDeletedBinMap() {
        try { return JSON.parse(localStorage.getItem('deleted_solicitudes_by_day') || '{}'); } catch (_) { return {}; }
      }

      function setDeletedBinMap(map) {
        try { localStorage.setItem('deleted_solicitudes_by_day', JSON.stringify(map || {})); } catch (_) {}
      }

      function getDeletedKey(entry) {
        const docId = String(entry?.docId || '').trim();
        if (docId) return `doc:${docId}`;
        const songId = String(entry?.songId || '').trim();
        if (songId) return `song:${songId}`;
        const id = String(entry?.requestData?.id || '').trim();
        if (id) return `id:${id}`;
        return '';
      }

      function listDeletedForDay(day) {
        const key = String(day || '').trim();
        const map = getDeletedBinMap();
        const arr = Array.isArray(map[key]) ? map[key] : [];
        return arr.slice().sort((a, b) => Number(b?.deletedAt || 0) - Number(a?.deletedAt || 0));
      }

      function upsertDeletedEntry(day, entry) {
        const d = String(day || '').trim();
        if (!d) return;
        const map = getDeletedBinMap();
        const arr = Array.isArray(map[d]) ? map[d] : [];
        const k = getDeletedKey(entry);
        const nextEntry = {
          ...entry,
          day: d,
          deletedAt: Number(entry?.deletedAt || Date.now()),
          requestData: sanitizeRequestDataForStorage(entry?.requestData, d),
          localEntry: sanitizeLocalEntryForStorage(entry?.localEntry)
        };
        const idx = k ? arr.findIndex((x) => getDeletedKey(x) === k) : -1;
        if (idx >= 0) arr[idx] = nextEntry;
        else arr.push(nextEntry);
        map[d] = arr.slice(-500);
        setDeletedBinMap(map);
      }

      function removeDeletedEntry(day, entry) {
        const d = String(day || '').trim();
        if (!d) return;
        const map = getDeletedBinMap();
        const arr = Array.isArray(map[d]) ? map[d] : [];
        const k = getDeletedKey(entry);
        const next = k ? arr.filter((x) => getDeletedKey(x) !== k) : arr;
        map[d] = next;
        setDeletedBinMap(map);
      }

      function clearDeletedForDay(day) {
        const d = String(day || '').trim();
        if (!d) return;
        const map = getDeletedBinMap();
        map[d] = [];
        setDeletedBinMap(map);
      }

      function refreshDeletedCountBadge() {
        if (!deletedCountBadge) return;
        const day = String(document.getElementById('day-select')?.value || '').trim();
        const count = day ? listDeletedForDay(day).length : 0;
        deletedCountBadge.hidden = count <= 0;
        deletedCountBadge.textContent = String(count);
      }

      function openDeletedModal() {
        if (!deletedModal) return;
        deletedModal.hidden = false;
        try {
          if (deletedDaySelect) {
            deletedDaySelect.innerHTML = '';
            const daySel = document.getElementById('day-select');
            if (daySel) {
              Array.from(daySel.options || []).forEach((opt) => {
                const o = document.createElement('option');
                o.value = opt.value;
                o.textContent = opt.textContent;
                deletedDaySelect.appendChild(o);
              });
              deletedDaySelect.value = daySel.value;
            }
          }
        } catch (_) {}
        renderDeletedList();
      }

      function closeDeletedModal() {
        if (!deletedModal) return;
        deletedModal.hidden = true;
      }

      function formatDeletedRowTitle(entry) {
        const d = entry?.requestData || entry || {};
        const song = String(d.cancion || '').trim() || 'Desconocida';
        const artist = String(d.artista || '').trim() || 'Desconocido';
        return `${song} â€” ${artist}`;
      }

      function formatDeletedRowSub(entry) {
        const d = entry?.requestData || entry || {};
        const u = String(d.displayName || d.usuario || '').trim() || 'AnÃ³nimo';
        const h = String(d.hora || '').trim() || '';
        return h ? `Pedido por ${u} â€¢ ${h}` : `Pedido por ${u}`;
      }

      function normalizeTsMs(v) {
        try {
          if (!v) return 0;
          if (typeof v.toMillis === 'function') return v.toMillis();
          if (typeof v.toDate === 'function') return v.toDate().getTime();
          if (v instanceof Date) return v.getTime();
          const t = new Date(v).getTime();
          return Number.isFinite(t) ? t : 0;
        } catch (_) {
          return 0;
        }
      }

      function sanitizeRequestDataForStorage(d, fallbackDay) {
        try {
          const src = d || {};
          const day = String(src.day || fallbackDay || '').trim();
          const tsMs = normalizeTsMs(src.ts) || Number(src.tsMs || 0) || Date.now();
          return {
            id: src.id,
            usuario: src.usuario,
            displayName: src.displayName,
            cancion: src.cancion,
            artista: src.artista,
            genero: src.genero,
            cover: src.cover,
            status: src.status,
            hora: src.hora,
            day,
            tsMs
          };
        } catch (_) {
          return d || {};
        }
      }

      function sanitizeLocalEntryForStorage(e) {
        try {
          if (!e) return null;
          const out = { ...e };
          if (out.time) {
            const ms = normalizeTsMs(out.time);
            if (ms) out.time = ms;
          }
          return out;
        } catch (_) {
          return e || null;
        }
      }

      async function applyRestoreAction(action, options) {
        const day = String(action?.day || '').trim();
        if (!day) return;
        const songId = action.songId;
        const shouldUpdateUI = !!(options && options.updateUI);

        if (action.docId && window.db) {
          const data = { ...(action.requestData || {}) };
          const tsMs = Number(data.tsMs || 0) || normalizeTsMs(data.ts) || Date.now();
          if (firebase?.firestore?.Timestamp?.fromMillis) data.ts = firebase.firestore.Timestamp.fromMillis(tsMs);
          else data.ts = new Date(tsMs);
          data.day = String(data.day || day).trim() || day;
          await window.db.collection('solicitudes').doc(action.docId).set(data, { merge: false });
        } else {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          const arr = Array.isArray(byDay[day]) ? byDay[day] : [];
          if (action.localEntry) {
            const insertAt = Number.isFinite(action.localIndex) ? Math.max(0, Math.min(action.localIndex, arr.length)) : arr.length;
            arr.splice(insertAt, 0, action.localEntry);
            byDay[day] = arr;
            localStorage.setItem('solicitudes_by_day', JSON.stringify(byDay));
          } else if (action.requestData) {
            arr.push(action.requestData);
            byDay[day] = arr;
            localStorage.setItem('solicitudes_by_day', JSON.stringify(byDay));
          }
        }

        if (action.wasPlayed && songId) {
          const localPlayed = getLocalPlayedMap();
          const arr = Array.isArray(localPlayed[day]) ? localPlayed[day] : [];
          if (!arr.includes(songId)) {
            arr.push(songId);
            localPlayed[day] = arr;
            setLocalPlayedMap(localPlayed);
          }
          try { if (window.playedSongsCache) window.playedSongsCache[day] = arr; } catch (_) {}
          if (action.wasSkipped) {
            const localSkipped = getLocalSkippedMap();
            const sArr = Array.isArray(localSkipped[day]) ? localSkipped[day] : [];
            if (!sArr.includes(songId)) {
              sArr.push(songId);
              localSkipped[day] = sArr;
              setLocalSkippedMap(localSkipped);
            }
          }
          await cloudAddPlayed(day, songId, action.itemForLog, { skipped: !!action.wasSkipped });
        }

        if (action.docId) {
          const existing = Array.isArray(currentManualOrder) ? currentManualOrder.slice() : [];
          if (!existing.includes(action.docId)) {
            const insertAt = Number.isFinite(action.orderIndex) ? Math.max(0, Math.min(action.orderIndex, existing.length)) : existing.length;
            existing.splice(insertAt, 0, action.docId);
            currentManualOrder = existing;
            localStorage.setItem(`manualOrder:${day}`, JSON.stringify(existing));
            try {
              if (window.db) {
                await window.db.collection('manualOrders').doc(day).set({
                  order: existing,
                  day,
                  updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
              }
            } catch (_) {}
          }
        }

        removeDeletedEntry(day, action);
        try { refreshDeletedCountBadge(); } catch (_) {}
        if (shouldUpdateUI) {
          const selectedDay = String(document.getElementById('day-select')?.value || '').trim();
          if (selectedDay === day) {
            const restored = {
              ...(action.requestData || {}),
              id: action.docId || (action.requestData?.id || null),
              requestId: action.requestData?.id,
              day,
              hora: action.requestData?.hora || action.itemForLog?.hora || toHour(action.requestData?.ts)
            };
            const idKey = String(action.docId || '');
            const next = Array.isArray(currentDayItems) ? currentDayItems.slice() : [];
            const existingIdx = idKey ? next.findIndex(x => String(x?.id || '') === idKey) : -1;
            if (existingIdx >= 0) next[existingIdx] = restored;
            else next.push(restored);
            currentDayItems = applyOrder(next, currentManualOrder);
            window.__dayItems = currentDayItems;
            renderSolicitudes(currentDayItems);
          }
        }
      }

      async function applyDeleteAction(action, options) {
        const day = String(action?.day || '').trim();
        if (!day) return;
        const songId = action.songId;
        const shouldUpdateUI = !!(options && options.updateUI);

        if (action.docId && window.db) {
          await window.db.collection('solicitudes').doc(action.docId).delete();
        } else {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          const arr = Array.isArray(byDay[day]) ? byDay[day] : [];
          if (action.localEntry) {
            const idx = arr.findIndex(x =>
              x.usuario === action.localEntry.usuario &&
              x.cancion === action.localEntry.cancion &&
              x.artista === action.localEntry.artista &&
              String(x.time) === String(action.localEntry.time)
            );
            if (idx >= 0) arr.splice(idx, 1);
            byDay[day] = arr;
            localStorage.setItem('solicitudes_by_day', JSON.stringify(byDay));
          }
        }

        upsertDeletedEntry(day, action);
        try { refreshDeletedCountBadge(); } catch (_) {}

        if (action.wasPlayed && songId) {
          const localPlayed = getLocalPlayedMap();
          const arr = Array.isArray(localPlayed[day]) ? localPlayed[day] : [];
          localPlayed[day] = arr.filter(id => id !== songId);
          setLocalPlayedMap(localPlayed);
          try { if (window.playedSongsCache) window.playedSongsCache[day] = localPlayed[day]; } catch (_) {}
          const localSkipped = getLocalSkippedMap();
          const sArr = Array.isArray(localSkipped[day]) ? localSkipped[day] : [];
          localSkipped[day] = sArr.filter(id => id !== songId);
          setLocalSkippedMap(localSkipped);
          await cloudRemovePlayed(day, songId, action.itemForLog, { skipped: !!action.wasSkipped });
        }

        if (action.docId) {
          const existing = Array.isArray(currentManualOrder) ? currentManualOrder.slice() : [];
          const next = existing.filter(id => id !== action.docId);
          currentManualOrder = next;
          localStorage.setItem(`manualOrder:${day}`, JSON.stringify(next));
          try {
            if (window.db) {
              await window.db.collection('manualOrders').doc(day).set({
                order: next,
                day,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
              }, { merge: true });
            }
          } catch (_) {}
        }

        if (shouldUpdateUI) {
          const selectedDay = String(document.getElementById('day-select')?.value || '').trim();
          if (selectedDay === day) {
            const idKey = String(action.docId || '');
            const nextItems = Array.isArray(currentDayItems) ? currentDayItems.slice() : [];
            const filtered = nextItems.filter((x) => {
              if (idKey && String(x?.id || '') === idKey) return false;
              const sid = `${x?.usuario}-${x?.cancion}-${x?.artista}-${x?.hora}`.replace(/[^a-zA-Z0-9-]/g, '');
              if (songId && sid === songId) return false;
              return true;
            });
            currentDayItems = applyOrder(filtered, currentManualOrder);
            window.__dayItems = currentDayItems;
            renderSolicitudes(currentDayItems);
          }
        }
      }

      function getLocalPlayedMap() {
        try {
          return JSON.parse(localStorage.getItem('playedSongs') || '{}');
        } catch (_) {
          return {};
        }
      }

      function setLocalPlayedMap(map) {
        try {
          localStorage.setItem('playedSongs', JSON.stringify(map || {}));
        } catch (_) {}
      }

      function getLocalSkippedMap() {
        try {
          return JSON.parse(localStorage.getItem('skippedSongs') || '{}');
        } catch (_) {
          return {};
        }
      }

      function setLocalSkippedMap(map) {
        try {
          localStorage.setItem('skippedSongs', JSON.stringify(map || {}));
        } catch (_) {}
      }

      async function cloudAddPlayed(day, songId, it, options) {
        if (!window.db || !firebase?.firestore?.FieldValue) return;
        const playedRef = window.db.collection('playedSongs').doc(day);
        const skipped = !!(options && options.skipped === true);
        const payload = {
          songs: firebase.firestore.FieldValue.arrayUnion(songId),
          lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
        };
        if (skipped) payload.skipped = firebase.firestore.FieldValue.arrayUnion(songId);
        await playedRef.set(payload, { merge: true });
        try {
          const uName = (it?.usuario || '').trim();
          if (!skipped) {
            if (uName) await updateUserPlayedCounter(uName, day, 1);
            await registerToggleEvent({
              action: 'mark',
              usuario: uName,
              cancion: it?.cancion,
              artista: it?.artista,
              day,
              hora: it?.hora,
              songId
            });
          }
        } catch (_) {}
      }

      async function cloudRemovePlayed(day, songId, it, options) {
        if (!window.db || !firebase?.firestore?.FieldValue) return;
        const playedRef = window.db.collection('playedSongs').doc(day);
        const skipped = !!(options && options.skipped === true);
        const payload = {
          songs: firebase.firestore.FieldValue.arrayRemove(songId),
          skipped: firebase.firestore.FieldValue.arrayRemove(songId),
          lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
        };
        await playedRef.set(payload, { merge: true });
        try {
          const uName = (it?.usuario || '').trim();
          if (!skipped) {
            if (uName) await updateUserPlayedCounter(uName, day, -1);
            await registerToggleEvent({
              action: 'unmark',
              usuario: uName,
              cancion: it?.cancion,
              artista: it?.artista,
              day,
              hora: it?.hora,
              songId
            });
          }
        } catch (_) {}
      }

      async function undoLastEditAction() {
        if (editUndoStack.length === 0) return;
        const action = editUndoStack.pop();
        editRedoStack.push(action);
        refreshEditActionsBar();
        if (action?.type === 'delete') {
          try { await applyRestoreAction(action, { updateUI: true }); } catch (err) { console.error('Error al deshacer:', err); }
          return;
        }
        if (action?.type === 'restore') {
          try { await applyDeleteAction(action, { updateUI: true }); } catch (err) { console.error('Error al deshacer:', err); }
          return;
        }
      }

      async function redoLastEditAction() {
        if (editRedoStack.length === 0) return;
        const action = editRedoStack.pop();
        editUndoStack.push(action);
        refreshEditActionsBar();
        if (action?.type === 'delete') {
          try { await applyDeleteAction(action, { updateUI: true }); } catch (err) { console.error('Error al rehacer:', err); }
          return;
        }
        if (action?.type === 'restore') {
          try { await applyRestoreAction(action, { updateUI: true }); } catch (err) { console.error('Error al rehacer:', err); }
          return;
        }
      }

      function renderDeletedList() {
        if (!deletedListEl || !deletedDaySelect) return;
        const day = String(deletedDaySelect.value || '').trim();
        const arr = day ? listDeletedForDay(day) : [];
        deletedListEl.innerHTML = '';

        if (!arr.length) {
          const empty = document.createElement('div');
          empty.className = 'deleted-row';
          empty.innerHTML = `<div class="meta"><div class="title">No hay canciones eliminadas</div><div class="sub">Cuando elimines canciones en modo ediciÃ³n, aparecerÃ¡n aquÃ­.</div></div><button type="button" class="restore-btn" disabled>Restaurar</button>`;
          deletedListEl.appendChild(empty);
          try { if (restoreAllDeletedBtn) restoreAllDeletedBtn.disabled = true; } catch (_) {}
          return;
        }

        try { if (restoreAllDeletedBtn) restoreAllDeletedBtn.disabled = false; } catch (_) {}

        arr.forEach((entry) => {
          const row = document.createElement('div');
          row.className = 'deleted-row';
          const meta = document.createElement('div');
          meta.className = 'meta';
          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = formatDeletedRowTitle(entry);
          const sub = document.createElement('div');
          sub.className = 'sub';
          sub.textContent = formatDeletedRowSub(entry);
          const fine = document.createElement('div');
          fine.className = 'fine';
          fine.textContent = (entry?.docId ? `ID: ${entry.docId}` : (entry?.songId ? `SongID: ${entry.songId}` : ''));
          meta.appendChild(title);
          meta.appendChild(sub);
          meta.appendChild(fine);

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'restore-btn';
          btn.textContent = 'Restaurar';
          btn.disabled = deletedRestoreInFlight;
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (deletedRestoreInFlight) return;
            deletedRestoreInFlight = true;
            try {
              btn.disabled = true;
              const restoreAction = { ...entry, type: 'restore', day: day };
              await applyRestoreAction(restoreAction, { updateUI: true });
              try {
                editUndoStack.push({ ...restoreAction, type: 'restore' });
                editRedoStack = [];
                refreshEditActionsBar();
              } catch (_) {}
              renderDeletedList();
            } catch (err) {
              console.error('Error restaurando:', err);
              alert('No se pudo restaurar la canciÃ³n. Revisa permisos o intÃ©ntalo de nuevo.');
            } finally {
              deletedRestoreInFlight = false;
              try { btn.disabled = false; } catch (_) {}
            }
          });

          row.appendChild(meta);
          row.appendChild(btn);
          deletedListEl.appendChild(row);
        });
      }

      openDeletedBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!isEditModeActive()) return;
        openDeletedModal();
      });

      clearDeletedBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!isEditModeActive()) return;
        const day = String(document.getElementById('day-select')?.value || '').trim();
        if (!day) return;
        if (!confirm('Â¿Vaciar la lista de eliminadas del dÃ­a seleccionado?')) return;
        clearDeletedForDay(day);
        try { refreshDeletedCountBadge(); } catch (_) {}
        try { if (deletedDaySelect) deletedDaySelect.value = day; } catch (_) {}
        renderDeletedList();
      });

      deletedCloseBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeDeletedModal();
      });

      deletedCloseXBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeDeletedModal();
      });

      deletedModal?.addEventListener('click', (e) => {
        if (e.target === deletedModal) closeDeletedModal();
      });

      deletedDaySelect?.addEventListener('change', () => {
        renderDeletedList();
      });

      restoreAllDeletedBtn?.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!deletedDaySelect) return;
        const day = String(deletedDaySelect.value || '').trim();
        if (!day) return;
        const entries = listDeletedForDay(day);
        if (!entries.length) return;
        if (!confirm(`Â¿Restaurar ${entries.length} canciones eliminadas del dÃ­a ${day}?`)) return;
        if (deletedRestoreInFlight) return;
        deletedRestoreInFlight = true;
        try {
          for (const entry of entries) {
            const restoreAction = { ...entry, type: 'restore', day: day };
            await applyRestoreAction(restoreAction, { updateUI: true });
            try {
              editUndoStack.push({ ...restoreAction, type: 'restore' });
            } catch (_) {}
          }
          editRedoStack = [];
          refreshEditActionsBar();
          renderDeletedList();
        } catch (err) {
          console.error('Error restaurando todo:', err);
          alert('No se pudieron restaurar todas las canciones. Revisa permisos e intÃ©ntalo de nuevo.');
        } finally {
          deletedRestoreInFlight = false;
        }
      });

      undoDeleteBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!isEditModeActive()) return;
        undoLastEditAction();
      });
      redoDeleteBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!isEditModeActive()) return;
        redoLastEditAction();
      });
      
      function renderSolicitudes(items) {
        if (!solicitudesList) {
          console.error('âŒ solicitudesList no encontrado');
          return;
        }
        solicitudesList.innerHTML = '';
        if (!items.length) {
          emptyEl.hidden = false;
          return;
        }
        emptyEl.hidden = true;
        const isEditing = solicitudesList.classList.contains('editing');

        items.forEach((it, index) => {
          const unameLc = String(it.usuario||'').trim().toLowerCase();
          const displayUser = String(it.displayName || it.usuario || '').trim();
          const isVip = vipSet.has(unameLc);
          const isZ0Vip = z0VipSet.has(unameLc);
          const isDonador = donadorSet.has(unameLc);
          const hasPendingReward = window.pendingRewardUsers && window.pendingRewardUsers.has(unameLc);
          const li = document.createElement('li');

          // Crear ID Ãºnico para la canciÃ³n
          const songId = `${it.usuario}-${it.cancion}-${it.artista}-${it.hora}`.replace(/[^a-zA-Z0-9-]/g, '');
          li.dataset.songId = songId;
          li.dataset.username = (it.usuario || '').trim().toLowerCase();
          li.dataset.day = String(it.day || (it.fecha||'').split('T')[0] || '').trim();
          if (it.id) li.dataset.docId = it.id;
          li.dataset.isTest = isTestRequestForStats(it) ? '1' : '0';

          if (isZ0Vip) {
            li.className = 'item z0-vip';
          } else if (isVip) {
            li.className = 'item vip';
          } else if (window.z0PlatinumSet && window.z0PlatinumSet.has(it.usuario)) {
            li.className = 'item z0-platino';
          } else if (window.z0FanSet && window.z0FanSet.has(it.usuario)) {
            li.className = 'item z0-fan';
          } else if (isDonador) {
            li.className = 'item donador';
          } else {
            li.className = 'item';
          }
          
          if (hasPendingReward) {
             li.classList.add('has-pending-reward');
          }

          const selectedBadge = typeof window.getSelectedBadgeFor === 'function' ? window.getSelectedBadgeFor(it.usuario) : '';
          if (selectedBadge) {
            li.classList.remove('vip','z0-vip','donador','z0-fan','z0-platino');
            li.classList.add(selectedBadge);
          }

          // Verificar si la canciÃ³n estÃ¡ marcada como reproducida
          const currentDay = document.getElementById('day-select')?.value || '';
          const localPlayedMap = getLocalPlayedMap();
          const localSkippedMap = getLocalSkippedMap();
          const dayPlayedSongs = window.playedSongsCache[currentDay] || localPlayedMap[currentDay] || [];
          const daySkippedSongs = localSkippedMap[currentDay] || [];
          const skippedSet = new Set((Array.isArray(daySkippedSongs) ? daySkippedSongs : []).map(x => String(x || '')));
          
          if (dayPlayedSongs.includes(songId)) {
            li.classList.add('played');
            if (skippedSet.has(String(songId || ''))) li.classList.add('skipped');
          }

          // Modo ediciÃ³n: draggable
          li.draggable = !!isEditing;

          li.innerHTML = `
            <span class="col col-time">${it.hora || ''}</span>
            <span class="col col-usuario usuario">
               <span class="uname-text">${displayUser}</span>
               ${hasPendingReward ? '<span class="reward-pending-icon" title="Solicitud de recompensa pendiente">ğŸ</span>' : ''}
            </span>
            <span class="col col-cancion">
              <span class="text">${it.cancion}</span>
              <button class="copy-chip copy-chip-inline" type="button" title="Copiar canciÃ³n" data-copy="${it.cancion}">â§‰</button>
            </span>
            <span class="col col-artista">
              <span class="text">${it.artista}</span>
              <button class="copy-chip copy-chip-inline" type="button" title="Copiar artista" data-copy="${it.artista}">â§‰</button>
            </span>
            <span class="col col-cancion-artista">
              <div class="line-with-copy mobile-user-row">
                 <div class="usuario-line usuario">
                   ${displayUser}
                   ${hasPendingReward ? '<span class="reward-pending-icon" title="Solicitud de recompensa pendiente">ğŸ</span>' : ''}
                 </div>
              </div>
              <div class="line-with-copy">
                <div class="cancion-line">${it.cancion}</div>
                <button class="copy-chip" type="button" title="Copiar canciÃ³n" data-copy="${it.cancion}">â§‰</button>
              </div>
              <div class="line-with-copy">
                <div class="artista-line">${it.artista}</div>
                <button class="copy-chip" type="button" title="Copiar artista" data-copy="${it.artista}">â§‰</button>
              </div>
            </span>
            <button class="play-toggle-btn" title="Marcar como reproducida (Shift=skip / sin puntos)">
              <span class="play-icon">â–¶ï¸</span>
            </button>
            <button class="delete-btn" title="Eliminar canciÃ³n" aria-label="Eliminar">ğŸ—‘ï¸</button>
          `;

          const copyButtons = li.querySelectorAll('.copy-chip');
          if (copyButtons && copyButtons.length) {
            copyButtons.forEach(function (btn) {
              btn.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                const textToCopy = btn.getAttribute('data-copy') || '';
                if (textToCopy) {
                  copyTextToClipboard(textToCopy, e.currentTarget || btn);
                }
              });
            });
          }

          // Texto seleccionable / cursor segÃºn modo
          li.style.userSelect = 'text';
          li.style.cursor = isEditing ? 'grab' : 'text';

          // Toggle reproducida
          const toggleBtn = li.querySelector('.play-toggle-btn');
          if (toggleBtn) {
            // SIEMPRE habilitar el botÃ³n visualmente y agregar el listener.
            // La restricciÃ³n de funcionalidad estÃ¡ dentro de toggleSongPlayed.
            toggleBtn.disabled = false;
            toggleBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              toggleSongPlayed(li, songId, currentDay, { skip: e.shiftKey === true });
            });
          }

          try {
            const iconEl = li.querySelector('.play-icon');
            if (iconEl) iconEl.textContent = li.classList.contains('played') ? (li.classList.contains('skipped') ? 'â­ï¸' : 'â–¶ï¸') : 'â–¶ï¸';
          } catch (_) {}

          // Eliminar canciÃ³n (solo en modo ediciÃ³n)
          const deleteBtn = li.querySelector('.delete-btn');
          deleteBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!solicitudesList.classList.contains('editing')) return;

            const docId = li.dataset.docId;
            const day = currentDay;
            const localPlayedMapBefore = getLocalPlayedMap();
            const localSkippedMapBefore = getLocalSkippedMap();
            const dayPlayedBefore = window.playedSongsCache[day] || localPlayedMapBefore[day] || [];
            const daySkippedBefore = localSkippedMapBefore[day] || [];
            const wasPlayed = Array.isArray(dayPlayedBefore) && dayPlayedBefore.includes(songId);
            const wasSkipped = Array.isArray(daySkippedBefore) && daySkippedBefore.includes(songId);
            const orderIndex = (docId && Array.isArray(currentManualOrder)) ? currentManualOrder.indexOf(docId) : -1;
            const requestData = {
              id: it.requestId || songId,
              usuario: it.usuario,
              displayName: it.displayName,
              cancion: it.cancion,
              artista: it.artista,
              genero: it.genero,
              cover: it.cover,
              ts: it.ts || new Date(),
              hora: it.hora,
              status: it.status || 'pending',
              day
            };
            let localEntry = null;
            let localIndex = null;
            try {
              if (!(docId && window.db)) {
                try {
                  const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
                  const arr = Array.isArray(byDay[day]) ? byDay[day] : [];
                  const idx = arr.findIndex(x =>
                    x.usuario === it.usuario &&
                    x.cancion === it.cancion &&
                    x.artista === it.artista &&
                    toHour(x.time) === it.hora
                  );
                  if (idx >= 0) {
                    localEntry = arr[idx];
                    localIndex = idx;
                  }
                } catch (_) {}
              }

              const action = {
                type: 'delete',
                day,
                docId: docId || null,
                songId,
                requestData,
                localEntry,
                localIndex,
                wasPlayed,
                wasSkipped,
                orderIndex: orderIndex >= 0 ? orderIndex : null,
                itemForLog: { usuario: it.usuario, cancion: it.cancion, artista: it.artista, hora: it.hora }
              };

              await applyDeleteAction(action, { updateUI: true });
              editUndoStack.push(action);
              editRedoStack = [];
              refreshEditActionsBar();
            } catch (err) {
              console.error('Error eliminando canciÃ³n:', err);
              alert('No se pudo eliminar la canciÃ³n. Revisa permisos o intÃ©ntalo de nuevo.');
            }
          });

          // Drag & drop para reordenar (solo en modo ediciÃ³n)
          li.addEventListener('dragstart', (e) => {
            if (!solicitudesList.classList.contains('editing')) return;
            li.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            // Usar el mismo ID que usa idOf para consistencia
            e.dataTransfer.setData('text/plain', it.id || it.docId || songId);
          });
          li.addEventListener('dragend', () => {
            li.classList.remove('dragging');
          });
          li.addEventListener('dragover', (e) => {
            if (!solicitudesList.classList.contains('editing')) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          });
          li.addEventListener('drop', (e) => {
            if (!solicitudesList.classList.contains('editing')) return;
            e.preventDefault();
            const fromId = e.dataTransfer.getData('text/plain');
            const toId = it.id || it.docId || songId;
            if (!fromId || !toId || fromId === toId) return;

            const idOf = (item) => item.id || item.docId || `${item.usuario}-${item.cancion}-${item.artista}-${item.hora}`.replace(/[^a-zA-Z0-9-]/g, '');
            const fromIdx = currentDayItems.findIndex(item => idOf(item) === fromId);
            const toIdx = currentDayItems.findIndex(item => idOf(item) === toId);
            
            if (fromIdx < 0 || toIdx < 0) {
                 console.warn('Drag&Drop mismatch:', { fromId, toId, fromIdx, toIdx });
                 return;
            }

            const [moved] = currentDayItems.splice(fromIdx, 1);
            currentDayItems.splice(toIdx, 0, moved);

            // Actualizar currentManualOrder localmente para reflejar el cambio inmediato
            currentManualOrder = currentDayItems.map(item => idOf(item));
            window.__dayItems = currentDayItems;

            // Persistir orden manual por dÃ­a (Firestore + localStorage)
            const selectedDay =
              (document.getElementById('day-select')?.value || '').trim() ||
              String(it.day || '').trim() ||
              String((currentDayItems && currentDayItems[0] && currentDayItems[0].day) || '').trim();
            persistManualOrder(currentDayItems, selectedDay);

            // Render con orden actualizado
            renderSolicitudes(currentDayItems);
          });

          solicitudesList.appendChild(li);
        });

        // Verificar que los eventos de clic se hayan agregado correctamente
        const clickableItems = solicitudesList.querySelectorAll('.item');
        console.log(`âœ… Renderizadas ${clickableItems.length} canciones clickeables`);

        try { applySelectedBadgeToAll(); } catch (_) {}

        // Forzar estilos en canciones reproducidas despuÃ©s del renderizado
        setTimeout(() => {
          forcePlayedSongStyles();
        }, 100);

        // Actualizar selector de usuarios cuando hay nuevos datos
        setTimeout(() => {
          if (typeof populateUserSelector === 'function') {
            populateUserSelector().catch(error => {
              console.error('Error en populateUserSelector, usando fallback:', error);
              if (typeof window.populateUserSelectorFromLocalStorage === 'function') {
                window.populateUserSelectorFromLocalStorage();
              }
            });
          } else {
            if (typeof window.populateUserSelectorFromLocalStorage === 'function') {
              window.populateUserSelectorFromLocalStorage();
            }
          }
        }, 100);

        // Analizar automÃ¡ticamente nuevos usuarios
        if (typeof window.analyzeNewUsersAutomatically === 'function') {
          window.analyzeNewUsersAutomatically().catch(console.error);
        }
      }

      // Orden manual: aplicar y persistir
      function applyOrder(items, order) {
        try {
          if (!Array.isArray(order) || !order.length) return items;

          const idOf = (item) => item.id || item.docId || `${item.usuario}-${item.cancion}-${item.artista}-${item.hora}`.replace(/[^a-zA-Z0-9-]/g, '');

          const inOrderSet = new Set(order);

          // Elementos presentes en 'order' respetando ese orden
          const ordered = [];
          order.forEach((sid) => {
            const found = items.find((it) => idOf(it) === sid);
            if (found) ordered.push(found);
          });

          // Nuevos (no presentes en 'order') abajo (para mantener FIFO)
          const notInOrder = items.filter((it) => !inOrderSet.has(idOf(it)));

          return [...ordered, ...notInOrder];
        } catch {
          return items;
        }
      }

      function persistManualOrder(items, day) {
        const key = `manualOrder:${day}`;
        const order = items.map(item => item.id || item.docId || `${item.usuario}-${item.cancion}-${item.artista}-${item.hora}`.replace(/[^a-zA-Z0-9-]/g, ''));
        // Guardar inmediatamente en localStorage para disponibilidad local
        localStorage.setItem(key, JSON.stringify(order));
        // Persistir tambiÃ©n en Firestore para sincronizar entre dispositivos
        try {
          if (window.db) {
            window.db.collection('manualOrders').doc(day).set({
              order,
              day,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });
          }
        } catch (err) {
          console.warn('No se pudo persistir orden manual en Firestore, usando solo localStorage:', err);
        }
      }

      // Control del lÃ¡piz y modo ediciÃ³n
      (function () {
        const editToggleBtn = document.getElementById('edit-toggle-btn');
        const adminPanelEl = document.getElementById('admin-panel');
        const adminModalEl = document.getElementById('admin-modal');
        const adminPassInputEl = document.getElementById('admin-pass-input');
        const adminPassErrorEl = document.getElementById('admin-auth-error');
        const adminExitBtnEl = document.getElementById('admin-exit');

        function updateEditToggleVisibility() {
          if (!editToggleBtn) return;
          const isAdminOpen = !!adminPanelEl && !adminPanelEl.hidden;
          const djMode = (typeof isDJDevice === 'function') ? isDJDevice() : false;
          editToggleBtn.hidden = !djMode;
          editToggleBtn.style.opacity = '1';
          editToggleBtn.title = 'Editar lista (eliminar / mover)';

          try {
            const tools = document.querySelector('.title-tools');
            const searchBox = tools?.querySelector('.search-box');
            const themeBtn = document.getElementById('theme-btn');
            const menuBtn = document.getElementById('menu-btn');
            if (tools && editToggleBtn) {
              if (djMode && searchBox && themeBtn) {
                if (editToggleBtn.parentNode !== tools) tools.appendChild(editToggleBtn);
                if (editToggleBtn.previousElementSibling !== searchBox) tools.insertBefore(editToggleBtn, themeBtn);
              } else if (!djMode && themeBtn && menuBtn) {
                if (editToggleBtn.parentNode !== tools) tools.appendChild(editToggleBtn);
                if (editToggleBtn.nextElementSibling !== menuBtn) tools.insertBefore(editToggleBtn, menuBtn);
              }
            }
          } catch (_) {}

          if (!djMode && !isAdminOpen) {
            editToggleBtn.setAttribute('aria-pressed', 'false');
            solicitudesList?.classList.remove('editing');
            editUndoStack = [];
            editRedoStack = [];
            refreshEditActionsBar();
            if (currentDayItems?.length) renderSolicitudes(applyOrder(currentDayItems, currentManualOrder));
          }
        }

        function toggleEditMode() {
          if (!editToggleBtn) return;
          const isAdminOpen = !!adminPanelEl && !adminPanelEl.hidden;
          const djMode = (typeof isDJDevice === 'function') ? isDJDevice() : false;
          if (!isAdminOpen && !djMode) {
            if (adminModalEl) {
              adminModalEl.hidden = false;
              if (adminPassInputEl) adminPassInputEl.value = '';
              if (adminPassErrorEl) adminPassErrorEl.hidden = true;
              adminPassInputEl?.focus();
            }
            return;
          }
          const isEditing = editToggleBtn.getAttribute('aria-pressed') === 'true';
          const next = !isEditing;
          editToggleBtn.setAttribute('aria-pressed', String(next));
          solicitudesList?.classList.toggle('editing', next);
          if (currentDayItems?.length) renderSolicitudes(applyOrder(currentDayItems, currentManualOrder));
          refreshEditActionsBar();
        }

        editToggleBtn?.addEventListener('click', (e) => {
          e.preventDefault();
          toggleEditMode();
        });

        // Observar cambios en el panel admin para actualizar visibilidad del lÃ¡piz
        if (adminPanelEl) {
          const mo = new MutationObserver(() => updateEditToggleVisibility());
          mo.observe(adminPanelEl, { attributes: true, attributeFilter: ['hidden'] });
        }

        // IntegraciÃ³n opcional con tryOpenAdmin si estÃ¡ expuesto
        const originalTryOpenAdmin = typeof window.tryOpenAdmin === 'function' ? window.tryOpenAdmin : null;
        if (originalTryOpenAdmin) {
          window.tryOpenAdmin = function () {
            originalTryOpenAdmin();
            updateEditToggleVisibility();
          };
        }

        adminExitBtnEl?.addEventListener('click', () => {
          updateEditToggleVisibility();
        });

        // Inicial
        updateEditToggleVisibility();
      })();

      // FunciÃ³n para alternar el estado de canciÃ³n reproducida (con sincronizaciÃ³n Firebase)
      // FunciÃ³n para sincronizar configuraciÃ³n con Firebase (SOLO LECTURA / VALIDACIÃ“N)
      async function syncDJStatus() {
        try {
          // Generar fingerprint actual
          const currentFingerprint = generateDeviceFingerprint();
          
          // 1. Validar contra localStorage primero (rÃ¡pido)
          const storedMaster = localStorage.getItem('masterDJFingerprint');
          const isStoredAsMaster = localStorage.getItem('isMasterDJDevice') === 'true';

          // Si dice ser master, validamos que tenga el fingerprint correcto
          if (isStoredAsMaster && storedMaster !== currentFingerprint) {
             console.warn('Detectado cambio de fingerprint en dispositivo DJ. Revocando permisos.');
             localStorage.setItem('isMasterDJDevice', 'false');
          }

          if (!window.db) return;
          
          const djConfigRef = window.db.collection('systemConfig').doc('djConfig');
          const djConfigDoc = await djConfigRef.get();
          
          if (djConfigDoc.exists) {
            // Si existe config en la nube, la verdad absoluta estÃ¡ ahÃ­
            const remoteMasterFingerprint = djConfigDoc.data().masterFingerprint;
            
            // Si el fingerprint remoto coincide con el nuestro, somos el DJ
            const isMaster = remoteMasterFingerprint === currentFingerprint;
            
            // Actualizar estado local
            localStorage.setItem('masterDJFingerprint', remoteMasterFingerprint);
            localStorage.setItem('isMasterDJDevice', isMaster ? 'true' : 'false');
            
            // Actualizar UI
            updateDJControls();
            try { updateEditToggleVisibility(); } catch (_) {}
          } else {
             // Si no existe config en la nube, NADIE es DJ automÃ¡ticamente.
             // Se requiere acciÃ³n manual en el botÃ³n "Establecer como DJ".
             // Por seguridad, si creÃ­amos ser DJ pero no hay config, dejamos de serlo 
             // (o podrÃ­amos mantenerlo si asumimos modo offline, pero mejor ser seguros)
             // Para modo offline, confiamos en localStorage si ya estaba seteado.
          }
          
        } catch (error) {
          console.warn('Error sincronizando estado DJ (modo offline o error de red):', error);
          // En error, NO otorgamos permisos nuevos. 
          // Mantenemos el estado actual de localStorage (asumiendo que fue validado antes).
        }
      }

      // Ejecutar validaciÃ³n al inicio
      document.addEventListener('DOMContentLoaded', () => {
        syncDJStatus();
      });

      // FunciÃ³n para verificar si este dispositivo puede modificar canciones
      // DeterminaciÃ³n estricta de dispositivo maestro (DJ)
      function isDJDevice() {
        try {
          // 1. Si se estableciÃ³ manualmente, respetar
          if (localStorage.getItem('isMasterDJDevice') === 'true') return true;
          if (localStorage.getItem('isMasterDJDevice') === 'false') return false;

          // 2. Por defecto false si no hay configuraciÃ³n explÃ­cita
          return false;
        } catch (e) {
          return false;
        }
      }

      // Inicializar estado de controles
      function updateDJControls() {
        const isMaster = isDJDevice();
        document.querySelectorAll('.play-toggle-btn').forEach(btn => {
          // Mostrar el botÃ³n activo VISUALMENTE para todos (peticiÃ³n de usuario),
          // pero funcionalmente restringido por toggleSongPlayed (si no es Master no hace nada al click)
          btn.removeAttribute('disabled');
          btn.title = isMaster ? "Marcar como sonada/pendiente" : "Solo el DJ puede controlar esto";
          btn.style.opacity = "1";
          btn.style.pointerEvents = "auto";
          btn.style.filter = "none";
        });
      }

      document.addEventListener('DOMContentLoaded', () => {
        // Ejecutar validaciÃ³n inicial
        updateDJControls();
        
        // Resize inicial
        try {
          if (typeof resize === 'function') resize();
          else if (typeof window.updateParticleSystem === 'function') window.updateParticleSystem();
        } catch (_) {}
      });

      // FunciÃ³n para generar fingerprint del dispositivo
      function generateDeviceFingerprint() {
        // Intentar recuperar fingerprint cacheado para estabilidad (especialmente al redimensionar o usar devtools)
        const cached = localStorage.getItem('device_fingerprint_cached');
        if (cached) return cached;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillText('Device fingerprint', 2, 2);
        
        const fingerprint = [
          navigator.userAgent,
          navigator.language,
          screen.width + 'x' + screen.height,
          new Date().getTimezoneOffset(),
          canvas.toDataURL()
        ].join('|');
        
        // Crear hash simple del fingerprint
        let hash = 0;
        for (let i = 0; i < fingerprint.length; i++) {
          const char = fingerprint.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        
        const deviceId = 'device_' + Math.abs(hash).toString(36);
        localStorage.setItem('device_fingerprint_cached', deviceId);
        return deviceId;
      }
      window.generateDeviceFingerprint = generateDeviceFingerprint;

      async function toggleSongPlayed(element, songId, passedDay, options) {
        try {
          if (!isDJDevice()) { 
             // Feedback visual para no-DJs (PeticiÃ³n: que se pueda presionar pero sin cambiar estado)
             const btn = element.querySelector('.play-toggle-btn');
             if (btn) {
               btn.classList.add('clicked-anim');
               setTimeout(() => btn.classList.remove('clicked-anim'), 200);
             }
             // Sin mensaje, solo feedback visual
             return; 
          }
          
          // Obtener el dÃ­a actual del selector, parÃ¡metro o dataset del elemento
          const dayFromItem = String(element?.dataset?.day || '').trim();
          const currentDay = passedDay || document.getElementById('day-select')?.value || dayFromItem || '';
          
          if (!currentDay) {
            console.warn('No se pudo obtener el dÃ­a actual');
            return;
          }

          const isTestItem = String(element?.dataset?.isTest || '') === '1';
          const wantsSkip = !!(options && options.skip === true);
          
          // Obtener datos locales como respaldo
          const localPlayedSongs = getLocalPlayedMap();
          if (!localPlayedSongs[currentDay]) localPlayedSongs[currentDay] = [];

          const localSkippedSongs = getLocalSkippedMap();
          if (!localSkippedSongs[currentDay]) localSkippedSongs[currentDay] = [];

          const wasPlayed = localPlayedSongs[currentDay].includes(songId);
          const wasSkipped = localSkippedSongs[currentDay].includes(songId);
          const iconEl = element.querySelector('.play-icon');
          
          // Actualizar estado local inmediatamente para UX responsiva
          let nextPlayed = wasPlayed;
          let nextSkipped = wasSkipped;

          if (!wasPlayed) {
            nextPlayed = true;
            nextSkipped = wantsSkip === true;
            localPlayedSongs[currentDay].push(songId);
            if (nextSkipped) localSkippedSongs[currentDay].push(songId);
            element.classList.add('played');
            element.classList.toggle('skipped', nextSkipped);
          } else {
            if (wantsSkip) {
              nextPlayed = true;
              nextSkipped = !wasSkipped;
              if (nextSkipped) localSkippedSongs[currentDay].push(songId);
              else localSkippedSongs[currentDay] = localSkippedSongs[currentDay].filter(id => id !== songId);
              element.classList.add('played');
              element.classList.toggle('skipped', nextSkipped);
            } else {
              nextPlayed = false;
              nextSkipped = false;
              localPlayedSongs[currentDay] = localPlayedSongs[currentDay].filter(id => id !== songId);
              localSkippedSongs[currentDay] = localSkippedSongs[currentDay].filter(id => id !== songId);
              element.classList.remove('played');
              element.classList.remove('skipped');

              const indicator = element.querySelector('.played-indicator');
              if (indicator) indicator.remove();
              element.style.backgroundColor = '';
              element.style.color = '';
              element.style.opacity = '';
            }
          }

          if (iconEl) iconEl.textContent = nextPlayed ? (nextSkipped ? 'â­ï¸' : 'â–¶ï¸') : 'â–¶ï¸';
          
          // Guardar en localStorage como respaldo
          setLocalPlayedMap(localPlayedSongs);
          setLocalSkippedMap(localSkippedSongs);
          
           if (typeof window.playedSongsCache === 'object') {
              window.playedSongsCache[currentDay] = localPlayedSongs[currentDay];
           }
          
          // Sincronizar con Firebase para que todos los usuarios vean el cambio
          try {
            if (window.db) {
              const playedSongsRef = window.db.collection('playedSongs').doc(currentDay);
              
              // Asegurar existencia del documento
              await playedSongsRef.set({ day: currentDay }, { merge: true });
              
              // Aplicar operaciÃ³n de agregado/eliminado con merge para evitar fallos si no existe
              const updatePayload = {
                songs: wasPlayed ? firebase.firestore.FieldValue.arrayRemove(songId)
                                : firebase.firestore.FieldValue.arrayUnion(songId),
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
              };
              if (!wasPlayed && nextSkipped) updatePayload.skipped = firebase.firestore.FieldValue.arrayUnion(songId);
              else if (wasPlayed && !nextPlayed) updatePayload.skipped = firebase.firestore.FieldValue.arrayRemove(songId);
              else if (wasPlayed && wasSkipped !== nextSkipped) updatePayload.skipped = nextSkipped ? firebase.firestore.FieldValue.arrayUnion(songId) : firebase.firestore.FieldValue.arrayRemove(songId);
              await playedSongsRef.set(updatePayload, { merge: true });

              if (!isTestItem) {
                const userForCounter = (element.dataset.username || '').trim();
                const delta =
                  (!wasPlayed && nextPlayed && !nextSkipped) ? 1 :
                  (wasPlayed && !nextPlayed && !wasSkipped) ? -1 :
                  (wasPlayed && nextPlayed && wasSkipped && !nextSkipped) ? 1 :
                  (wasPlayed && nextPlayed && !wasSkipped && nextSkipped) ? -1 :
                  0;
                if (delta) await updateUserPlayedCounter(userForCounter, currentDay, delta);

                const usuarioText = (element.querySelector('.col.col-usuario, .usuario')?.textContent || userForCounter || '').trim();
                const cancionText = (element.querySelector('.col.col-cancion')?.textContent || '').trim();
                const artistaText = (element.querySelector('.col.col-artista')?.textContent || '').trim();
                const horaText = (element.querySelector('.col.col-time')?.textContent || '').trim();
                await registerToggleEvent({
                  action: (!wasPlayed && nextPlayed && !nextSkipped) ? 'mark'
                         : (wasPlayed && !nextPlayed && !wasSkipped) ? 'unmark'
                         : (wasPlayed && nextPlayed && wasSkipped && !nextSkipped) ? 'mark'
                         : (wasPlayed && nextPlayed && !wasSkipped && nextSkipped) ? 'unmark'
                         : (wasPlayed && nextPlayed && wasSkipped && nextSkipped) ? 'skip'
                         : (!wasPlayed && nextPlayed && nextSkipped) ? 'skip'
                         : 'noop',
                  usuario: usuarioText,
                  cancion: cancionText,
                  artista: artistaText,
                  day: currentDay,
                  hora: horaText,
                  songId: songId
                });

                try {
                  window.__recountTimers = window.__recountTimers || {};
                  const key = String(userForCounter||'').toLowerCase();
                  clearTimeout(window.__recountTimers[key]);
                  window.__recountTimers[key] = setTimeout(async () => {
                    try { await recountToggleTotalsForUser(userForCounter); } catch (_){ }
                  }, 400);
                } catch(_){ }

                try {
                  const normUser = String(userForCounter||'').trim().replace(/^@/,'').toLowerCase();
                  const sid = String(songId||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
                  window.__userToggleSet = window.__userToggleSet || {};
                  const set = window.__userToggleSet[normUser] || (window.__userToggleSet[normUser] = new Set());
                  const shouldCountNow = nextPlayed && !nextSkipped;
                  if (shouldCountNow) set.add(sid);
                  else set.delete(sid);
                  window.__toggleReady = window.__toggleReady || {}; window.__toggleReady[normUser] = true;
                  setPlayedStat(set.size);
                } catch(_){ }
              }
              
            }
          } catch (firebaseError) {
            console.warn('Error sincronizando con Firebase, usando solo localStorage:', firebaseError);
          }
          
          // Forzar estilos para asegurar que se vean correctamente
          setTimeout(() => {
            forcePlayedSongStyles();
          }, 50);

          if (isTestItem) return;

          // Actualizar contadores en tiempo real para el usuario del perfil visible
          try {
            const username = String((element.dataset.username || '').trim().toLowerCase());
            const currentProfile = String((typeof getCurrentProfileUser === 'function' ? getCurrentProfileUser() : getCurrentUser()) || '').trim().toLowerCase();
            if (username && currentProfile === username) {
              const key = String(username||'').toLowerCase();
              const set = window.__userToggleSet && window.__userToggleSet[key];
              const playedCnt = (set && set.size) ? set.size : 0;
              const basePts = playedCnt * 25;
              setPlayedStat(playedCnt);
              const baseEl = document.getElementById('breakdown-played-base');
              if (baseEl) baseEl.textContent = String(basePts);
              const modal = document.getElementById('gamification-modal');
              if (modal && !modal.hidden) {
                try {
                  const localData = getLocalGamificationData(username) || {};
                  await renderPersonalStatsForUser(localData, username);
                } catch(_){ }
                try {
                  const bdPanel = document.getElementById('gamification-breakdown');
                  if (bdPanel && bdPanel.classList.contains('active')) {
                    await renderPointsBreakdownForUser(username, true);
                  }
                } catch(_){ }
              }
            }
          } catch(_){}
          
          // Actualizar estadÃ­sticas en tiempo real si el panel estÃ¡ visible y corresponde al usuario de la canciÃ³n
          try {
            const statsPanel = document.getElementById('gamification-stats');
            const username = String((element.dataset.username || '').trim().toLowerCase());
            const currentProfile = String((typeof getCurrentProfileUser === 'function' ? getCurrentProfileUser() : getCurrentUser()) || '').trim().toLowerCase();
            if (statsPanel && statsPanel.classList.contains('active') && username && currentProfile === username) {
              const key = String(username||'').toLowerCase();
              const set = window.__userToggleSet && window.__userToggleSet[key];
              const cnt = (set && set.size) ? set.size : 0;
              setPlayedStat(cnt);
            }
          } catch (_){}
          
          // Recalcular puntos y estadÃ­sticas del usuario afectado para que refleje solo reproducidas
          try {
            const username = (element.dataset.username || '').trim();
            if (username) {
              await analyzeAndGrantPointsForUser(username);
              try { await updateUserHeaderUI(username); } catch(_) {}
              // Si estamos en la pestaÃ±a de Transparencia viendo a este usuario, actualizar
              const panel = document.getElementById('gamification-breakdown');
              const curProfile = getCurrentProfileUser();
              if (panel && panel.classList.contains('active') && String(curProfile||'').toLowerCase() === String(username||'').toLowerCase()) {
                 await renderPointsBreakdownForUser(username, true);
              }
            }
          } catch (e) {
            console.warn('No se pudo recalcular puntos tras marcar reproducida:', e);
          }
          
        } catch (error) {
          console.error('Error en toggleSongPlayed:', error);
        }
      }

      async function registerToggleEvent(payload) {
        try {
          const base = typeof generateDeviceFingerprint === 'function' ? generateDeviceFingerprint() : '';
          const norm = String((payload.usuario||'').trim().replace(/^@/,'')).toLowerCase();
          const idNorm = String((payload.songId||'')).toLowerCase().replace(/[^a-z0-9-]/g,'');
          const data = {
            type: 'togglePlayed',
            action: String(payload.action||'').toLowerCase(),
            usuario: norm,
            usuarioRaw: String(payload.usuario||''),
            cancion: String(payload.cancion||''),
            artista: String(payload.artista||''),
            day: String(payload.day||''),
            hora: String(payload.hora||''),
            songId: idNorm,
            deviceId: base,
            ts: firebase.firestore.FieldValue.serverTimestamp()
          };
          const docId = `toggle-${norm}-${idNorm}-${String(payload.day||'')}`.toLowerCase().replace(/[^a-z0-9-]/g,'');
          await db.collection('systemEvents').doc(docId).set(data, { merge: true });
        } catch (_){ }
      }

      

      async function backfillToggleEventsForUser(usuario) {
        try {
          const key = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
          const flag = `backfill_toggle_${key}`;
          if (localStorage.getItem(flag) === 'done') return;
          const snap = await db.collection('playedSongs').get();
          snap.forEach(async (doc) => {
            const dayId = String(doc.id||'');
            const d = doc.data()||{};
            const arr = Array.isArray(d.songs) ? d.songs : (Array.isArray(d.list) ? d.list : (Array.isArray(d.songIds) ? d.songIds : []));
            const skippedArr = Array.isArray(d.skipped) ? d.skipped : [];
            const skippedSet = new Set((skippedArr || []).map(x => String(x || '').toLowerCase().replace(/[^a-z0-9-]/g,'')));
            for (let i=0;i<arr.length;i++){
              const id = String(arr[i]||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
              if (skippedSet.has(id)) continue;
              if (id.startsWith(`${key}-`)) {
                await registerToggleEvent({
                  action: 'mark',
                  usuario: key,
                  cancion: '',
                  artista: '',
                  day: dayId,
                  hora: '',
                  songId: id
                });
                try {
                  window.__userToggleSet = window.__userToggleSet || {};
                  const set = window.__userToggleSet[key] || (window.__userToggleSet[key] = new Set());
                  set.add(id);
                } catch(_){}
              }
            }
          });
          // Segunda pasada: backfill desde localStorage (solo por usuario)
          try {
            const localMap = JSON.parse(localStorage.getItem('playedSongs') || '{}');
            const localSkippedMap = JSON.parse(localStorage.getItem('skippedSongs') || '{}');
            const days = Object.keys(localMap||{});
            for (let di=0; di<days.length; di++) {
              const dayId = String(days[di]||'').trim();
              if (!dayId) continue;
              const arr = Array.isArray(localMap[dayId]) ? localMap[dayId] : [];
              const skippedArr = Array.isArray(localSkippedMap[dayId]) ? localSkippedMap[dayId] : [];
              const skippedSet = new Set((skippedArr || []).map(x => String(x || '').toLowerCase().replace(/[^a-z0-9-]/g,'')));
              for (let i=0;i<arr.length;i++) {
                const id = String(arr[i]||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
                if (skippedSet.has(id)) continue;
                if (!id.startsWith(`${key}-`)) continue;
                await registerToggleEvent({
                  action: 'mark',
                  usuario: key,
                  cancion: '',
                  artista: '',
                  day: dayId,
                  hora: '',
                  songId: id
                });
                try {
                  window.__userToggleSet = window.__userToggleSet || {};
                  const set = window.__userToggleSet[key] || (window.__userToggleSet[key] = new Set());
                  set.add(id);
                } catch(_){}
              }
            }
          } catch(_){}
          localStorage.setItem(flag, 'done');
          try { await cleanToggleEventsForUser(key); } catch(_){ }
          window.__toggleReady = window.__toggleReady || {};
          window.__toggleReady[key] = true;
        } catch(_){ }
      }

      async function cleanToggleEventsForUser(usuario) {
        try {
          const key = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
          const qs = await db.collection('systemEvents').where('type','==','togglePlayed').where('usuario','==',key).get();
          const latest = {};
          const docs = [];
          qs.forEach(doc => {
            const d = doc.data()||{};
            const day = String(d.day||'');
            const sid = String(d.songId||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
            const canonical = `toggle-${key}-${sid}-${day}`.toLowerCase().replace(/[^a-z0-9-]/g,'');
            const ts = d.ts && d.ts.toMillis ? d.ts.toMillis() : 0;
            const k = `${sid}|${day}`;
            docs.push({ id: doc.id, canonical, ts, action: String(d.action||'').toLowerCase(), sid, day });
            const cur = latest[k];
            if (doc.id === canonical) {
              latest[k] = { id: doc.id, canonical, ts, action: String(d.action||'').toLowerCase(), sid, day };
            } else if (!cur || ts >= cur.ts) {
              latest[k] = { id: doc.id, canonical, ts, action: String(d.action||'').toLowerCase(), sid, day };
            }
          });
          for (let i=0;i<docs.length;i++){
            const item = docs[i];
            const k = `${item.sid}|${item.day}`;
            const keep = latest[k];
            if (!keep) continue;
            if (item.id !== keep.id) await db.collection('systemEvents').doc(item.id).delete();
          }
          const keys = Object.keys(latest);
          for (let i=0;i<keys.length;i++){
            const it = latest[keys[i]];
            if (it.id !== it.canonical) {
              const data = { type:'togglePlayed', usuario:key, songId:it.sid, day:it.day, action:it.action, ts: firebase.firestore.FieldValue.serverTimestamp() };
              await db.collection('systemEvents').doc(it.canonical).set(data, { merge:true });
              await db.collection('systemEvents').doc(it.id).delete();
              it.id = it.canonical;
            }
          }
          window.__userToggleSet = window.__userToggleSet || {};
          const newSet = new Set();
          keys.forEach(k => { const it = latest[k]; if (it.action === 'mark' && it.sid) newSet.add(it.sid); });
          window.__userToggleSet[key] = newSet;
          try { setPlayedStat(newSet.size); } catch(_){}
          window.__toggleReady = window.__toggleReady || {};
          window.__toggleReady[key] = true;
        } catch(_){ }
      }

      // FunciÃ³n para mostrar el estado del dispositivo (silenciosa)
      function showDJStatus() {
        // FunciÃ³n silenciosa - no muestra mensajes al usuario
        const isDJ = isDJDevice();
        const statusElement = document.getElementById('dj-status');
        
        if (statusElement) {
          // Ocultar el elemento de estado para que no moleste
          statusElement.style.display = 'none';
        }
        
        // No mostrar ningÃºn indicador visual al usuario
        return;
      }

      // FunciÃ³n de diagnÃ³stico para verificar el estado del dispositivo DJ
      window.diagnosticoDJ = function() {
        console.log('ğŸ” DIAGNÃ“STICO DEL DISPOSITIVO DJ');
        console.log('================================');
        
        const fingerprint = generateDeviceFingerprint();
        const storedFingerprint = localStorage.getItem('deviceFingerprint');
        const isMasterDevice = localStorage.getItem('isMasterDJDevice');
        const isDJ = isDJDevice();
        
        console.log('ğŸ“± InformaciÃ³n del dispositivo:');
        console.log('  - User Agent:', navigator.userAgent.substring(0, 100) + '...');
        console.log('  - Pantalla:', screen.width + 'x' + screen.height);
        console.log('  - Idioma:', navigator.language);
        console.log('  - Zona horaria:', new Date().getTimezoneOffset());
        
        console.log('ğŸ”‘ Fingerprints:');
        console.log('  - Actual:', fingerprint);
        console.log('  - Almacenado:', storedFingerprint);
        
        console.log('ğŸ§ Estado DJ:');
        console.log('  - Es dispositivo DJ:', isDJ);
        console.log('  - ConfiguraciÃ³n almacenada:', isMasterDevice);
        
        const isDesktop = !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
        const hasLargeScreen = screen.width >= 1024;
        
        console.log('ğŸ“Š Criterios de detecciÃ³n:');
        console.log('  - Es escritorio:', isDesktop);
        console.log('  - Pantalla grande (>=1024px):', hasLargeScreen);
        console.log('  - Cumple criterios DJ:', isDesktop && hasLargeScreen);
        
        if (!isDJ) {
          console.log('âš ï¸ PROBLEMA: Este dispositivo no estÃ¡ autorizado como DJ');
          console.log('ğŸ’¡ SOLUCIÃ“N: Ejecuta resetearDispositivoDJ() para reconfigurar');
        } else {
          console.log('âœ… Dispositivo DJ configurado correctamente');
        }
        
        return { fingerprint, isDJ, isDesktop, hasLargeScreen };
      };
      
      // FunciÃ³n para resetear la configuraciÃ³n del dispositivo DJ
      window.resetearDispositivoDJ = function() {
        console.log('ğŸ”„ Reseteando configuraciÃ³n del dispositivo DJ...');
        localStorage.removeItem('deviceFingerprint');
        localStorage.removeItem('isMasterDJDevice');
        localStorage.removeItem('masterDJFingerprint');
        
        // Forzar redetecciÃ³n
        const isDJ = isDJDevice();
        console.log(isDJ ? 'âœ… Dispositivo reconfigurado como DJ' : 'âŒ Dispositivo sigue sin ser DJ');
        
        // Actualizar estado visual
        showDJStatus();
        
        return isDJ;
      };
      
      // FunciÃ³n para forzar este dispositivo como DJ principal
      window.configurarComoDJ = function() {
        console.log('ğŸ§ Configurando este dispositivo como DJ principal...');
        const fingerprint = generateDeviceFingerprint();
        localStorage.setItem('masterDJFingerprint', fingerprint);
        localStorage.setItem('isMasterDJDevice', 'true');
        
        // Actualizar estado visual
        showDJStatus();
        
        console.log('âœ… Dispositivo configurado como DJ principal');
        console.log('ğŸ’¡ Ahora puedes marcar canciones como reproducidas');
        
        return true;
      };

      // FunciÃ³n para verificar que la funcionalidad estÃ© funcionando
      window.initializePlayedSongs = async function() {
        console.log('Inicializando funcionalidad de canciones reproducidas...');
        
        // La detecciÃ³n de dispositivo DJ es automÃ¡tica
        
        // Verificar estado de autenticaciÃ³n silenciosamente
        const isDJ = isDJDevice();
        
        // Verificar localStorage
        const playedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
        console.log('Canciones reproducidas en localStorage:', playedSongs);
        
        // Verificar que los estilos CSS estÃ©n cargados
        const testElement = document.createElement('div');
        testElement.className = 'item played';
        document.body.appendChild(testElement);
        const styles = window.getComputedStyle(testElement);
        console.log('Estilos CSS para .item.played:', {
          backgroundColor: styles.backgroundColor,
          color: styles.color,
          opacity: styles.opacity,
          cursor: styles.cursor
        });
        document.body.removeChild(testElement);
        
        console.log('Funcionalidad de canciones reproducidas inicializada correctamente');
      }

      // FunciÃ³n para forzar estilos en canciones reproducidas (fallback)
      window.forcePlayedSongStyles = function() {
        const playedItems = document.querySelectorAll('.item.played');
        console.log(`Forzando estilos en ${playedItems.length} canciones reproducidas`);
        
        playedItems.forEach(item => {
          // Obtener tema actual
          const isDark = document.body.classList.contains('dark-theme');
          const themeClass = Array.from(document.body.classList).find(cls => cls.startsWith('theme-'));
          
          // Aplicar estilos base
          item.style.opacity = '0.7';
          item.style.cursor = 'pointer';
          item.style.transition = 'all 0.2s ease';
          item.style.position = 'relative';
          
          // Aplicar colores segÃºn tema
          if (themeClass === 'theme-blue') {
            item.style.backgroundColor = isDark ? '#1e3a8a' : '#dbeafe';
            item.style.color = isDark ? '#93c5fd' : '#1e40af';
          } else if (themeClass === 'theme-green') {
            item.style.backgroundColor = isDark ? '#14532d' : '#dcfce7';
            item.style.color = isDark ? '#86efac' : '#166534';
          } else if (themeClass === 'theme-purple') {
            item.style.backgroundColor = isDark ? '#581c87' : '#f3e8ff';
            item.style.color = isDark ? '#c4b5fd' : '#7c3aed';
          } else if (themeClass === 'theme-red') {
            item.style.backgroundColor = isDark ? '#991b1b' : '#fee2e2';
            item.style.color = isDark ? '#fca5a5' : '#dc2626';
          } else if (themeClass === 'theme-pink') {
            item.style.backgroundColor = isDark ? '#9d174d' : '#fce7f3';
            item.style.color = isDark ? '#f9a8d4' : '#be185d';
          } else {
            // Tema por defecto
            item.style.backgroundColor = isDark ? '#374151' : '#f3f4f6';
            item.style.color = isDark ? '#9ca3af' : '#6b7280';
          }
          
          // Agregar indicador âœ“ si no existe
          const isSkipped = item.classList.contains('skipped');
          if (!item.querySelector('.played-indicator')) {
            const indicator = document.createElement('span');
            indicator.className = 'played-indicator';
            indicator.textContent = isSkipped ? 'â­' : 'âœ“';
            indicator.style.cssText = `
              position: absolute;
              left: 4px;
              top: 50%;
              transform: translateY(-50%);
              font-size: 12px;
              font-weight: bold;
              color: ${isSkipped ? (isDark ? '#fbbf24' : '#d97706') : (isDark ? '#34d399' : '#10b981')};
              z-index: 1;
            `;
            item.insertBefore(indicator, item.firstChild);
          } else {
            const indicator = item.querySelector('.played-indicator');
            if (indicator) {
              indicator.textContent = isSkipped ? 'â­' : 'âœ“';
              indicator.style.color = isSkipped ? (isDark ? '#fbbf24' : '#d97706') : (isDark ? '#34d399' : '#10b981');
            }
          }
        });
      }

      function toHour(ts) {
        if (!ts) return '';
        const d = ts.toDate ? ts.toDate() : new Date(ts);
        // Forzar formato 24h consistente (HH:MM) independientemente del locale del usuario
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return `${hh}:${mm}`;
      }
      function toHourKey(ts) {
        try {
          if (!ts) return '00:00';
          const d = ts?.toDate ? ts.toDate() : new Date(ts);
          const pad = (n) => String(n).padStart(2, '0');
          const hh = pad(d.getHours());
          const mm = pad(d.getMinutes());
          return `${hh}:${mm}`;
        } catch (_) {
          return '00:00';
        }
      }
      window.toHourKey = toHourKey;
      function resolveHourKey(ts) {
        try {
          if (typeof window.toHourKey === 'function') return window.toHourKey(ts);
          if (ts && ts?.toDate) {
            const d = ts.toDate();
            const hh = String(d.getHours()).padStart(2,'0');
            const mm = String(d.getMinutes()).padStart(2,'0');
            return `${hh}:${mm}`;
          }
          const d = ts ? new Date(ts) : null;
          if (d && !isNaN(d.getTime())) {
            const hh = String(d.getHours()).padStart(2,'0');
            const mm = String(d.getMinutes()).padStart(2,'0');
            return `${hh}:${mm}`;
          }
          return '00:00';
        } catch (_) { return '00:00'; }
      }
      window.resolveHourKey = resolveHourKey;
      function makeSongId(usuario, cancion, artista, ts) {
        const hora = toHour(ts);
        const raw = `${usuario}-${cancion}-${artista}-${hora}`;
        return raw.replace(/[^a-zA-Z0-9-]/g, '');
      }
      async function recalculateAllUsers() {
        const vipNow = window.vipSet || new Set();
        const z0vipNow = window.z0VipSet || new Set();
        const playedSnap = await db.collection('playedSongs').get();
        const playedMap = new Map();
        playedSnap.forEach(doc => {
          const day = doc.id;
          const arr = (doc.data() && doc.data().songs) || [];
          playedMap.set(day, new Set(arr));
        });
        const daySnap = await db.collection('solicitudes').orderBy('day', 'desc').get();
        const daysSet = new Set();
        daySnap.forEach(doc => {
          const d = doc.data().day;
          if (d) daysSet.add(d);
        });
        const days = Array.from(daysSet).sort();
        const perUser = new Map();
        const originalNames = {};
        for (let di = 0; di < days.length; di++) {
          const day = days[di];
          const playedSet = playedMap.get(day) || new Set();
          const q = await db.collection('solicitudes').where('day', '==', day).orderBy('ts', 'asc').get();
          const distinctUsersDay = new Set();
          const countedUsersDay = new Set();
          q.forEach(doc => {
            const data = doc.data() || {};
            const rawUser = String(data.usuario || '').trim();
            const usuario = rawUser.toLowerCase();
            const cancion = String(data.cancion || '').trim();
            const artista = String(data.artista || '').trim();
            const ts = data.ts || null;
            const horaStr = String(data.hora || '').trim();
            if (!usuario) return;
            if (!originalNames[usuario] || (rawUser && rawUser !== usuario)) {
              originalNames[usuario] = rawUser;
            }
            distinctUsersDay.add(usuario);
            const sid = makeSongId(rawUser, cancion, artista, ts, horaStr);
            if (playedSet.has(sid)) {
              const prev = perUser.get(usuario) || { played: 0, activeDays: 0 };
              prev.played += 1;
              perUser.set(usuario, prev);
              countedUsersDay.add(usuario);
            }
          });
          if (distinctUsersDay.size >= 2) {
            countedUsersDay.forEach(u => {
              const prev = perUser.get(u) || { played: 0, activeDays: 0 };
              prev.activeDays += 1;
              perUser.set(u, prev);
            });
          }
        }
        const batchUpdates = [];
        perUser.forEach((val, user) => {
          // Check VIP status (case-insensitive check against sets assumed to be lowercase or we check both)
          // Actually vipNow/z0vipNow are sets of strings. How are they populated?
          // Usually we should check lowercase.
          // Assuming user is already lowercase here.
          let isVip = false;
          // Iterate sets to find case-insensitive match or assume sets are normalized?
          // Let's assume sets might contain original names.
          // Best effort check.
          for (let v of vipNow) { if (v.toLowerCase() === user) { isVip = true; break; } }
          if (!isVip) { for (let v of z0vipNow) { if (v.toLowerCase() === user) { isVip = true; break; } } }
          
          const base = val.played * 25;
          const vipBonus = isVip ? val.played * 40 : 0;
          const dailyBonus = val.activeDays * 5;
          const total = base + vipBonus + dailyBonus;
          batchUpdates.push({ user, totalPoints: total, displayName: originalNames[user] || user });
        });
        for (let i = 0; i < batchUpdates.length; i++) {
          const u = batchUpdates[i].user;
          await db.collection('userStats').doc(u).set({
            totalPoints: batchUpdates[i].totalPoints,
            displayName: batchUpdates[i].displayName,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
        }
        return batchUpdates;
      }

      // Utilidad para obtener el dÃ­a (YYYY-MM-DD) desde una entrada con distintos tipos de timestamp
      function getSongDay(entry) {
        const t = entry?.timestamp || entry?.ts || entry?.time;
        try {
          const d = t && t.toDate ? t.toDate() : (t ? new Date(t) : new Date());
          return d.toISOString().split('T')[0];
        } catch (_) {
          return new Date().toISOString().split('T')[0];
        }
      }

      async function loadDays() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const today = `${year}-${month}-${day}`;

        const isValidDay = (v) => /^\d{4}-\d{2}-\d{2}$/.test(String(v || '').trim());
        const days = new Set();

        if (db) {
          const snap = await db.collection('solicitudes').orderBy('ts', 'desc').get();
          snap.forEach(doc => {
            const d = doc.data();
            if (isValidDay(d.day)) {
              days.add(String(d.day).trim());
            } else if (d.ts) {
              try {
                const date = d.ts.toDate ? d.ts.toDate() : new Date(d.ts);
                const yyyy = date.getFullYear();
                const mm = String(date.getMonth() + 1).padStart(2, '0');
                const dd = String(date.getDate()).padStart(2, '0');
                days.add(`${yyyy}-${mm}-${dd}`);
              } catch (_) {}
            }
          });
        }
        
        if (!days.size) {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          Object.keys(byDay || {}).forEach(k => {
            if (isValidDay(k)) days.add(k);
          });
        }

        const sorted = Array.from(days).sort().reverse();

        daySelect.innerHTML = '';
        sorted.forEach(d => {
          const opt = document.createElement('option');
          opt.value = d;
          opt.textContent = d;
          daySelect.appendChild(opt);
        });
        if (sorted.length) {
          daySelect.value = sorted.includes(today) ? today : sorted[0];
          try { daySelect.dispatchEvent(new Event('change')); } catch (_){}
        }

        if (!daySelect.value) {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          const localDays = Object.keys(byDay).sort().reverse();
          // TambiÃ©n filtrar locales por si acaso
          const validLocalDays = localDays.filter(d => d <= today);
          
          if (validLocalDays.length) {
            daySelect.innerHTML = '';
            validLocalDays.forEach(d => {
              const opt = document.createElement('option');
              opt.value = d;
              opt.textContent = d;
              daySelect.appendChild(opt);
            });
            daySelect.value = validLocalDays[0];
            try { daySelect.dispatchEvent(new Event('change')); } catch (_){}
          }
        }
      }

      function subscribeSolicitudesForDay(dayValue) {
        if (unsubscribeSolicitudes) {
          unsubscribeSolicitudes();
          unsubscribeSolicitudes = null;
        }
        
        // Iniciar suscripciÃ³n a canciones reproducidas para este dÃ­a
        if (typeof subscribePlayedSongs === 'function') {
           subscribePlayedSongs(dayValue);
        }

        if (!db) {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          const arr = Array.isArray(byDay[dayValue]) ? byDay[dayValue] : [];
          let items = arr
            .filter(it => !(window.isDummyRequestForList ? window.isDummyRequestForList(it) : (String(it?.usuario || '').trim().toLowerCase() === 'prueba')))
            .filter(it => !vipOnly.checked || vipSet.has(it.usuario) || z0VipSet.has(it.usuario))
            .map(it => ({
              requestId: it.id,
              usuario: it.usuario,
              cancion: it.cancion,
              artista: it.artista,
              genero: it.genero,
              cover: it.cover,
              status: it.status,
              hora: it.hora || toHour(it.time),
              time: it.time,
              day: dayValue
            }));
          const visibleItems = applyDisplayOrder(items);
          currentDayItems = visibleItems;
          window.__dayItems = visibleItems;
          renderSolicitudes(visibleItems);
          try { if (window.refreshStatsTicker) window.refreshStatsTicker(); } catch (_) {}
          return;
        }
        
        const start = new Date(`${dayValue}T00:00:00`);
        const end = new Date(start);
        end.setDate(end.getDate() + 1);

        const applyItems = (items) => {
          const visibleItems = applyDisplayOrder(items);
          currentDayItems = visibleItems;
          window.__dayItems = visibleItems;
          renderSolicitudes(visibleItems);
          try { if (window.refreshStatsTicker) window.refreshStatsTicker(); } catch (_) {}
          try {
            if (window.__usersSelectTimer) clearTimeout(window.__usersSelectTimer);
            window.__usersSelectTimer = setTimeout(() => {
              try { if (typeof window.renderAllUsersSelect === 'function') window.renderAllUsersSelect(); } catch (_) {}
              try { if (typeof window.populateUserSelectorFromLocalStorage === 'function') window.populateUserSelectorFromLocalStorage(); } catch (_) {}
            }, 150);
          } catch (_) {}
        };

        const itemsFromSnap = (snap) => {
          let items = [];
          snap.forEach((doc) => {
            const data = doc.data();
            if (window.isDummyRequestForList ? window.isDummyRequestForList(data) : (String(data?.usuario || '').trim().toLowerCase() === 'prueba')) return;
            const isVip = vipSet.has(data.usuario) || z0VipSet.has(data.usuario);
            if (vipOnly.checked && !isVip) return;
            items.push({
              id: doc.id,
              requestId: data.id,
              usuario: data.usuario,
              displayName: data.displayName,
              cancion: data.cancion,
              artista: data.artista,
              genero: data.genero,
              cover: data.cover,
              status: data.status,
              ts: data.ts,
              hora: toHour(data.ts),
              day: dayValue
            });
          });
          if (items.length === 0) {
            const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
            const arr = Array.isArray(byDay[dayValue]) ? byDay[dayValue] : [];
            items = arr
              .filter(it => !(window.isDummyRequestForList ? window.isDummyRequestForList(it) : (String(it?.usuario || '').trim().toLowerCase() === 'prueba')))
              .filter(it => !vipOnly.checked || vipSet.has(it.usuario) || z0VipSet.has(it.usuario))
              .map(it => ({
                requestId: it.id,
                usuario: it.usuario,
                cancion: it.cancion,
                artista: it.artista,
                genero: it.genero,
                cover: it.cover,
                status: it.status,
                hora: it.hora || toHour(it.time),
                time: it.time,
                day: dayValue
              }));
          }
          return items;
        };

        let didFallbackToTs = false;
        // Remove orderBy to avoid index errors and rely on memory sort
        const qDay = db.collection('solicitudes').where('day', '==', dayValue);

        unsubscribeSolicitudes = qDay.onSnapshot((snap) => {
          console.log(`ğŸ“¥ Recibidos ${snap.size} documentos para el dÃ­a ${dayValue}`);
          const items = itemsFromSnap(snap);
          if (!items.length && !didFallbackToTs) {
            didFallbackToTs = true;
            db.collection('solicitudes')
              .where('ts', '>=', start)
              .where('ts', '<', end)
              .orderBy('ts', 'asc')
              .limit(1)
              .get()
              .then((testSnap) => {
                if (testSnap && !testSnap.empty) {
                  try { if (unsubscribeSolicitudes) unsubscribeSolicitudes(); } catch (_) {}
                  const qTs = db.collection('solicitudes')
                    .where('ts', '>=', start)
                    .where('ts', '<', end)
                    .orderBy('ts', 'asc');
                  unsubscribeSolicitudes = qTs.onSnapshot((s2) => {
                    console.log(`ğŸ“¥ (ts) Recibidos ${s2.size} documentos para el dÃ­a ${dayValue}`);
                    applyItems(itemsFromSnap(s2));
                  }, (err) => {
                    console.error('Error suscripciÃ³n solicitudes (ts):', err);
                  });
                } else {
                  applyItems(items);
                }
              })
              .catch(() => {
                applyItems(items);
              });
            return;
          }
          applyItems(items);
        }, (err) => {
          console.error('Error suscripciÃ³n solicitudes:', err);
        });
      }

      // Hacer accesible desde el IIFE de UI
      window.subscribeSolicitudesForDay = subscribeSolicitudesForDay;

      // Variables para paginaciÃ³n de bÃºsqueda
      let lastSearchDoc = null;
      let currentSearchQuery = '';
      
      const searchModal = document.getElementById('search-modal');
      const searchInput = document.getElementById('search-input');
      const searchResults = document.getElementById('search-results');
      const searchClose = document.getElementById('search-close');
      const searchLoadMore = document.getElementById('search-load-more');
      
      function openSearchModal() {
         searchModal.hidden = false;
         searchInput.value = '';
         searchResults.innerHTML = '';
         searchLoadMore.hidden = true;
         lastSearchDoc = null;
         currentSearchQuery = '';
         searchInput.focus();
      }
      
      // FunciÃ³n de bÃºsqueda de datos (simulada o real)
      async function querySolicitudes(query, lastDoc = null) {
        if (!query) return { results: [], lastDoc: null };
        const qStr = String(query).toLowerCase();
        
        // Estrategia de bÃºsqueda mejorada:
        // 1. Intentar buscar por 'cancion' (prefijo)
        // 2. Intentar buscar por 'artista' (prefijo)
        // 3. Intentar buscar por 'usuario' (prefijo)
        // 4. Combinar resultados y eliminar duplicados
        // Nota: Como no podemos hacer OR eficiente en cliente con SDK v8/v9 compat sin Ã­ndices complejos,
        // haremos consultas paralelas limitadas y combinaremos en memoria.
        
        const capitalized = query.charAt(0).toUpperCase() + query.slice(1);
        const upper = query.toUpperCase();
        const lower = query.toLowerCase(); // Por si acaso hay datos en minÃºsculas
        
        // Si hay paginaciÃ³n (lastDoc), la cosa se complica para bÃºsquedas paralelas combinadas.
        // SimplificaciÃ³n: Si es "cargar mÃ¡s", solo seguiremos la estrategia que dio resultados antes o
        // reseteamos la lÃ³gica.
        // Para simplificar la UX actual: haremos una bÃºsqueda nueva combinada de los primeros N resultados de cada criterio.
        // La paginaciÃ³n real en bÃºsquedas combinadas cliente es compleja. 
        // Asumiremos que el usuario quiere ver "lo mejor" de cada categorÃ­a.
        
        try {
          const limitPerCategory = 10;
          
          // Consultas paralelas
          const promises = [];
          
          // 1. Por CanciÃ³n (Capitalized)
          promises.push(db.collection('solicitudes')
            .where('cancion', '>=', capitalized)
            .where('cancion', '<=', capitalized + '\uf8ff')
            .limit(limitPerCategory)
            .get());
            
          // 2. Por Artista (Capitalized)
          promises.push(db.collection('solicitudes')
            .where('artista', '>=', capitalized)
            .where('artista', '<=', capitalized + '\uf8ff')
            .limit(limitPerCategory)
            .get());
            
          // 3. Por Usuario (minusculas o exacto, usualmente usuario se guarda tal cual viene)
          // Probamos con lo que escribiÃ³ el usuario tal cual y en minusculas
          promises.push(db.collection('solicitudes')
            .where('usuario', '>=', qStr)
            .where('usuario', '<=', qStr + '\uf8ff')
            .limit(limitPerCategory)
            .get());

          // Ejecutar todas
          const snapshots = await Promise.all(promises);
          
          const resultsMap = new Map();
          
          snapshots.forEach(snap => {
            snap.forEach(doc => {
              // Evitar duplicados
              if (!resultsMap.has(doc.id)) {
                 const d = doc.data();
                 // Filtro de invisibilidad para pruebas
                 if (window.isDummyRequestForList ? window.isDummyRequestForList(d) : (String(d.usuario || '').trim().toLowerCase() === 'prueba')) return;
                 
                 resultsMap.set(doc.id, {
                   id: doc.id,
                   ...d,
                   day: d.day || getSongDay(d),
                   ts: d.ts || d.timestamp || d.time
                 });
              }
            });
          });
          
          // Convertir a array
          let results = Array.from(resultsMap.values());
          
          // Ordenar resultados en memoria (mejor match primero?)
          // Prioridad: coincidencia exacta > empieza con > contiene
          results.sort((a, b) => {
             // LÃ³gica simple: fecha mÃ¡s reciente primero
             const ta = a.ts && a.ts.toMillis ? a.ts.toMillis() : 0;
             const tb = b.ts && b.ts.toMillis ? b.ts.toMillis() : 0;
             return tb - ta;
          });
          
          // Simular paginaciÃ³n o simplemente devolver todo lo encontrado (hasta 30 items)
          // Para esta versiÃ³n simple, devolvemos todo y lastDoc null (desactivamos "cargar mÃ¡s" real por ahora para bÃºsquedas complejas)
          // O devolvemos el Ãºltimo de la lista para cumplir la firma, aunque no funcione perfecto el next cursor.
          
          return { results, lastDoc: null };
        } catch (e) {
          console.error("Error buscando solicitudes:", e);
          return { results: [], lastDoc: null };
        }
      }

      async function performSearch(isLoadMore = false) {
         const query = searchInput.value.trim();
         if (!query) return;
         
         if (!isLoadMore) {
            // Si no es "Cargar mÃ¡s", dejamos que el listener de input maneje la UI inicial (predicciones)
            // O si queremos que el botÃ³n de bÃºsqueda fuerce resultados:
            searchResults.innerHTML = '<div class="search-loading">Buscando...</div>';
            searchResults.hidden = false;
            lastSearchDoc = null;
            currentSearchQuery = query;
         } else {
            searchLoadMore.textContent = 'Cargando...';
            searchLoadMore.disabled = true;
         }
         
         const { results, lastDoc } = await querySolicitudes(query, lastSearchDoc);
         
         lastSearchDoc = lastDoc;
         
         if (results.length === 0 && !isLoadMore) {
            searchResults.innerHTML = '<div class="search-error">No se encontraron resultados.</div>';
            searchLoadMore.hidden = true;
            return;
         }
         
         // Si es carga inicial, usamos renderSearchResults para mantener consistencia
         if (!isLoadMore) {
           renderSearchResults(results);
         } else {
           // Si es cargar mÃ¡s, aÃ±adimos (esto requiere que renderSearchResults soporte append o hacerlo manual)
           // Por simplicidad, renderSearchResults reemplaza. 
           // AquÃ­ haremos append manual compatible con el estilo de renderSearchResults
           const html = results.map(it => createSearchResultItemHTML(it)).join('');
           const tempDiv = document.createElement('div');
           tempDiv.innerHTML = html;
           Array.from(tempDiv.children).forEach(child => searchResults.appendChild(child));
         }
         
         // Gestionar botÃ³n "Cargar mÃ¡s"
         if (lastDoc) {
            searchLoadMore.hidden = false;
            searchLoadMore.textContent = 'Cargar mÃ¡s resultados...';
            searchLoadMore.disabled = false;
         } else {
            searchLoadMore.hidden = true;
         }
      }
      
      // Helper para generar HTML de item (extraÃ­do de renderSearchResults)
      function createSearchResultItemHTML(it) {
          const formatDate = (dateStr) => {
            if (!dateStr) return '';
            try {
              const date = new Date(dateStr);
              if (isNaN(date.getTime())) return dateStr;
              return date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: '2-digit' });
            } catch(e) { return dateStr; }
          };
          
          return `
            <div class="search-result" data-day="${it.day || ''}" tabindex="0" title="Click para ir a la fecha">
              <span class="sr-song">${it.cancion || ''}</span>
              <span class="sr-artist">${it.artista || ''}</span>
              <span class="sr-user">${it.usuario || ''}</span>
              <span class="sr-date">${formatDate(it.day)}</span>
              <span class="sr-arrow">â†’</span>
            </div>
          `;
      }
      
      // Event Listeners para bÃºsqueda
      document.getElementById('menu-search-open')?.addEventListener('click', openSearchModal);
      searchClose?.addEventListener('click', () => { searchModal.hidden = true; });
      
      // Eliminamos el listener duplicado de input que llamaba a performSearch directamente
      // searchInput?.addEventListener('input', ...); -> ELIMINADO/COMENTADO para evitar conflicto con el listener de la lÃ­nea 5080
      
      searchLoadMore?.addEventListener('click', () => performSearch(true));
      
      window.searchSolicitudes = async (query) => {
        const { results } = await querySolicitudes(query);
        return results;
      };

      function subscribeVipUsers() {
        console.log('ğŸ”„ Iniciando suscripciÃ³n VIP...');
        db.collection('vipUsers').onSnapshot((snap) => {
          console.log(`ğŸ“Š VIP snapshot recibido: ${snap.size} documentos`);
          window.vipSet = new Set();
          window.vipMap = new Map();
          vipSet = window.vipSet;
          vipListEl.innerHTML = '';
          snap.forEach((doc) => {
            const data = doc.data();
            const { name, activatedAt } = data;

            // AUTO-CORRECCIÃ“N: Si no tiene fecha de activaciÃ³n, asignar fecha actual
            if (name && !activatedAt) {
               console.log(`ğŸ”§ Auto-corrigiendo fecha VIP para: ${name}`);
               doc.ref.set({
                 activatedAt: firebase.firestore.FieldValue.serverTimestamp()
               }, { merge: true }).catch(e => console.error('Error auto-fix VIP:', e));
            }

            if (name) {
              const normalizedName = String(name).trim().toLowerCase();
              vipSet.add(normalizedName);
              
              let activationDate = null;
              if (activatedAt) {
                 try {
                   const d = activatedAt.toDate ? activatedAt.toDate() : new Date(activatedAt);
                   activationDate = d.toISOString().split('T')[0];
                 } catch(e) { console.warn('Fecha VIP invÃ¡lida:', e); }
              }
              window.vipMap.set(normalizedName, { activatedAt: activationDate });

              const li = document.createElement('li');
              li.innerHTML = `
                <span>${name}</span>
                <button type="button" class="remove-btn" data-user="${name}" aria-label="Quitar VIP">Ã—</button>
              `;
              vipListEl.appendChild(li);
            }
          });
          
          // Procesar logros VIP despuÃ©s de cargar los datos
          console.log(`ğŸ”„ VIP set actualizado, procesando logros para ${vipSet.size} usuarios VIP`);
          setTimeout(() => {
            vipSet.forEach(username => {
              window.grantBadgeAchievement(username);
            });
          }, 1000);
          
          if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
          applySelectedBadgeToAll();
          refreshBadgeSelectUI();
        }, (err) => {
          console.error('âŒ Error suscripciÃ³n VIP:', err);
        });
      }

      function subscribeZ0VipUsers() {
        console.log('ğŸ”„ Iniciando suscripciÃ³n Z0-VIP...');
        const z0VipListEl = document.getElementById('z0-vip-list');
        db.collection('z0VipUsers').onSnapshot((snap) => {
          console.log(`ğŸ“Š Z0-VIP snapshot recibido: ${snap.size} documentos`);
          window.z0VipSet = new Set();
          z0VipSet = window.z0VipSet;
          if (z0VipListEl) {
            z0VipListEl.innerHTML = '';
          }
          snap.forEach((doc) => {
            const { name } = doc.data();
            if (name) {
              z0VipSet.add(String(name).trim().toLowerCase());
              if (z0VipListEl) {
                const li = document.createElement('li');
                li.innerHTML = `
                  <span>${name}</span>
                  <button type="button" class="remove-btn" data-user="${name}" data-type="z0" aria-label="Quitar Z0-VIP">Ã—</button>
                `;
                z0VipListEl.appendChild(li);
              }
            }
          });
          
          // Procesar logros Z0-VIP despuÃ©s de cargar los datos
          console.log(`ğŸ”„ Z0-VIP set actualizado, procesando logros para ${z0VipSet.size} usuarios Z0-VIP`);
          setTimeout(() => {
            z0VipSet.forEach(username => {
              window.grantBadgeAchievement(username);
            });
          }, 1000);
          
          if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
          applySelectedBadgeToAll();
          refreshBadgeSelectUI();
        }, (err) => {
          console.error('âŒ Error suscripciÃ³n Z0-VIP:', err);
        });
      }

      function subscribeDonadorUsers() {
        console.log('ğŸ”„ Iniciando suscripciÃ³n Donador...');
        db.collection('donadorUsers').onSnapshot((snap) => {
          console.log(`ğŸ“Š Donador snapshot recibido: ${snap.size} documentos`);
          window.donadorSet = new Set();
          donadorSet = window.donadorSet;
          if (donadorListEl) {
            donadorListEl.innerHTML = '';
          }
          
          const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
          
          snap.forEach((doc) => {
            const data = doc.data();
            const { name, expiresAt } = data;
            
            if (name && expiresAt) {
              const expireDate = expiresAt.split('T')[0]; // YYYY-MM-DD
              
              // Si ya expirÃ³, eliminar automÃ¡ticamente
              if (expireDate < today) {
                db.collection('donadorUsers').doc(doc.id).delete().catch(console.error);
                return;
              }
              
              donadorSet.add(String(name).trim().toLowerCase());
              if (donadorListEl) {
                const li = document.createElement('li');
                li.innerHTML = `
                  <span>${name} (hasta ${expireDate})</span>
                  <button type="button" class="remove-btn" data-user="${name}" data-type="donador" aria-label="Quitar Donador">Ã—</button>
                `;
                donadorListEl.appendChild(li);
              }
            }
          });
          
          // Procesar logros Donador despuÃ©s de cargar los datos
          console.log(`ğŸ”„ Donador set actualizado, procesando logros para ${donadorSet.size} usuarios Donador`);
          setTimeout(() => {
            donadorSet.forEach(username => {
              window.grantBadgeAchievement(username);
            });
          }, 1000);
          
          if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
          applySelectedBadgeToAll();
          refreshBadgeSelectUI();
        }, (err) => {
          console.error('âŒ Error suscripciÃ³n Donadores:', err);
        });
      }

      function subscribeZ0FanUsers() {
        const listEl = document.getElementById('z0-fan-list');
        db.collection('z0FanUsers').onSnapshot((snap) => {
          window.z0FanSet = new Set();
          if (listEl) listEl.innerHTML = '';
          snap.forEach((doc) => {
            const { name } = doc.data();
            if (name) {
              window.z0FanSet.add(String(name).trim().toLowerCase());
              if (listEl) {
                const li = document.createElement('li');
                li.innerHTML = `<span>${name}</span><button type="button" class="remove-btn" data-user="${name}" data-type="z0-fan" aria-label="Quitar z0-Fan">Ã—</button>`;
                listEl.appendChild(li);
              }
            }
          });
          
          // Procesar logros z0-Fan despuÃ©s de cargar los datos
          console.log(`ğŸ”„ z0-Fan set actualizado, procesando logros para ${window.z0FanSet.size} usuarios z0-Fan`);
          setTimeout(() => {
            window.z0FanSet.forEach(username => {
              if (typeof window.grantBadgeAchievement === 'function') {
                window.grantBadgeAchievement(username);
              }
            });
          }, 1000);

          if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
          applySelectedBadgeToAll();
          refreshBadgeSelectUI();
        }, (err) => { console.error('âŒ Error suscripciÃ³n z0-Fan:', err); });
      }

      function subscribeZ0PlatinoUsers() {
        const listEl = document.getElementById('z0-platino-list');
        db.collection('z0PlatinumUsers').onSnapshot((snap) => {
          window.z0PlatinumSet = new Set();
          if (listEl) listEl.innerHTML = '';
          snap.forEach((doc) => {
            const { name } = doc.data();
            if (name) {
              window.z0PlatinumSet.add(String(name).trim().toLowerCase());
              if (listEl) {
                const li = document.createElement('li');
                li.innerHTML = `<span>${name}</span><button type="button" class="remove-btn" data-user="${name}" data-type="z0-platino" aria-label="Quitar z0-Platino">Ã—</button>`;
                listEl.appendChild(li);
              }
            }
          });
          
          // Procesar logros z0-Platino despuÃ©s de cargar los datos
          console.log(`ğŸ”„ z0-Platino set actualizado, procesando logros para ${window.z0PlatinumSet.size} usuarios z0-Platino`);
          setTimeout(() => {
            window.z0PlatinumSet.forEach(username => {
              if (typeof window.grantBadgeAchievement === 'function') {
                window.grantBadgeAchievement(username);
              }
            });
          }, 1000);

          if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
          applySelectedBadgeToAll();
          refreshBadgeSelectUI();
        }, (err) => { console.error('âŒ Error suscripciÃ³n z0-Platino:', err); });
      }

      // SuscripciÃ³n en tiempo real para canciones reproducidas (sincronizaciÃ³n global)
      function subscribePlayedSongs(day) {
        if (!day || !window.db) return;
        
        console.log('ğŸµ SuscribiÃ©ndose a canciones reproducidas para el dÃ­a:', day);
        
        // Cancelar suscripciÃ³n anterior si existe
        if (window.playedSongsUnsubscribe) {
          window.playedSongsUnsubscribe();
        }
        
        // Suscribirse a cambios en tiempo real
        window.playedSongsUnsubscribe = window.db.collection('playedSongs').doc(day)
          .onSnapshot((doc) => {
            try {
              const data = doc.data();
              const firebaseSongs = data?.songs || [];
              const firebaseSkipped = Array.isArray(data?.skipped) ? data.skipped : [];
              
              console.log('ğŸ”„ ActualizaciÃ³n de Firebase para canciones reproducidas:', {
                day,
                songs: firebaseSongs,
                count: firebaseSongs.length
              });
              
              // Actualizar localStorage con datos de Firebase
              const localPlayedSongs = getLocalPlayedMap();
              localPlayedSongs[day] = firebaseSongs;
              setLocalPlayedMap(localPlayedSongs);

              const localSkippedSongs = getLocalSkippedMap();
              localSkippedSongs[day] = firebaseSkipped;
              setLocalSkippedMap(localSkippedSongs);
              
               window.playedSongsCache[day] = firebaseSongs;
              
              // Actualizar interfaz visual
          updatePlayedSongsUI(day, firebaseSongs, firebaseSkipped);

          } catch (error) {
            console.error('Error procesando actualizaciÃ³n de canciones reproducidas:', error);
          }
        }, (error) => {
          console.error('Error en suscripciÃ³n de canciones reproducidas:', error);
        });
      }

      function normalizeUserForStats(u) {
        return String(u || '').trim().toLowerCase();
      }

      function isDummyRequestForList(it) {
        const u = normalizeUserForStats(it?.usuario);
        const s = String(it?.cancion || '').trim().toLowerCase();
        const a = String(it?.artista || '').trim().toLowerCase();
        if (u === 'prueba' || u.startsWith('prueba')) return true;
        if (s === 'prueba' || s.startsWith('prueba')) return true;
        if (a === 'prueba' || a.startsWith('prueba')) return true;
        return false;
      }

      function isTestRequestForStats(it) {
        const u = normalizeUserForStats(it?.usuario);
        if (!u) return true;
        if (u === 'prueba' || u.startsWith('prueba')) return true;
        const s = String(it?.cancion || '').trim().toLowerCase();
        const a = String(it?.artista || '').trim().toLowerCase();
        if (s === 'prueba' || s.startsWith('prueba')) return true;
        if (a === 'prueba' || a.startsWith('prueba')) return true;
        if (it && it.isSimulation === true) return true;
        if (it && it.isTest === true) return true;
        if (it && String(it.source || '').toLowerCase() === 'tiktoktest') return true;
        return false;
      }

      function getItemTimeMs(it) {
        try {
          if (!it) return 0;
          if (it.ts && typeof it.ts.toMillis === 'function') return it.ts.toMillis();
          if (it.ts instanceof Date) return it.ts.getTime();
          if (it.ts) {
            const t = new Date(it.ts).getTime();
            if (!Number.isNaN(t)) return t;
          }
          if (it.time) {
            if (typeof it.time === 'number') return it.time;
            const t = new Date(it.time).getTime();
            if (!Number.isNaN(t)) return t;
          }
          const h = String(it.hora || '').trim();
          const day = String(it.day || document.getElementById('day-select')?.value || '').trim();
          if (day && /^\d{4}-\d{2}-\d{2}$/.test(day) && /^\d{2}:\d{2}$/.test(h)) {
            const t = new Date(`${day}T${h}:00`).getTime();
            if (!Number.isNaN(t)) return t;
          }
        } catch (_) {}
        return 0;
      }

      function getLatestNonTestItem(items) {
        if (!Array.isArray(items) || !items.length) return null;
        let best = null;
        let bestTime = -Infinity;
        for (let i = 0; i < items.length; i++) {
          const it = items[i];
          if (isTestRequestForStats(it)) continue;
          const t = getItemTimeMs(it);
          if (t > bestTime) {
            bestTime = t;
            best = it;
          }
        }
        return best;
        return null;
      }

      try {
        window.normalizeUserForStats = normalizeUserForStats;
        window.isDummyRequestForList = isDummyRequestForList;
        window.isTestRequestForStats = isTestRequestForStats;
        window.getItemTimeMs = getItemTimeMs;
        window.getLatestNonTestItem = getLatestNonTestItem;
      } catch (_) {}

      // FunciÃ³n para calcular estadÃ­sticas del dÃ­a
      function computeDayStatsFromItems(items) {
        const songCount = {}; const artistCount = {}; const userCount = {}; const genreCount = {}; const artistOriginal = {}; const userOriginal = {};
        let totalCount = 0;
        for (let i = 0; i < items.length; i++) {
          const it = items[i] || {};
          if (isTestRequestForStats(it)) continue;
          const uNorm = normalizeUserForStats(it.usuario);
          totalCount++;
          const song = String(it.cancion || '').trim().toLowerCase();
          const artist = String(it.artista || '').trim().toLowerCase();
          const user = uNorm;
          const genre = String(it.genero || '').trim().toLowerCase();
          if (song) songCount[song] = (songCount[song] || 0) + 1;
          if (artist) { artistCount[artist] = (artistCount[artist] || 0) + 1; if (!artistOriginal[artist]) artistOriginal[artist] = String(it.artista || '').trim(); }
          if (user) { userCount[user] = (userCount[user] || 0) + 1; if (!userOriginal[user]) userOriginal[user] = String(it.usuario || '').trim(); }
          if (genre) genreCount[genre] = (genreCount[genre] || 0) + 1;
        }
        function top(map) { let k = ''; let v = 0; for (const key in map) { const val = map[key]; if (val > v) { v = val; k = key; } else if (val === v && (!k || key.localeCompare(k) < 0)) { k = key; } } return k; }
        const day = document.getElementById('day-select')?.value || '';
        const played = getLocalPlayedMap();
        const skipped = getLocalSkippedMap();
        const playedArr = Array.isArray(played[day]) ? played[day] : [];
        const skippedArr = Array.isArray(skipped[day]) ? skipped[day] : [];
        const skippedSet = new Set(skippedArr.map(x => String(x || '')));
        const playedCount = playedArr.filter(x => !skippedSet.has(String(x || ''))).length;
        let vipRequests = 0; let z0VipRequests = 0;
        for (let i = 0; i < items.length; i++) {
          const it = items[i] || {};
          if (isTestRequestForStats(it)) continue;
          const u = it.usuario;
          const unameLc = normalizeUserForStats(u);
          if (window.vipSet && window.vipSet.has(unameLc)) vipRequests++;
          if (window.z0VipSet && window.z0VipSet.has(unameLc)) z0VipRequests++;
        }
        const ts = top(songCount);
        const ta = top(artistCount);
        const artistTop3 = Object.keys(artistCount)
          .map(k => ({ k, c: artistCount[k], o: artistOriginal[k] || k }))
          .sort((a, b) => { var d = b.c - a.c; if (d !== 0) return d; return a.k.localeCompare(b.k); })
          .slice(0, 3)
          .map(it => `${it.o} (${it.c})`);
        const usersTop3 = Object.keys(userCount)
          .map(k => ({ k, c: userCount[k], o: userOriginal[k] || k }))
          .sort((a, b) => { var d = b.c - a.c; if (d !== 0) return d; return a.k.localeCompare(b.k); })
          .slice(0, 3)
          .map(it => `${it.o} (${it.c})`);
        return {
          topSong: ts,
          topSongCount: ts ? (songCount[ts] || 0) : 0,
          topArtist: ta,
          topArtistCount: ta ? (artistCount[ta] || 0) : 0,
          topArtists3: artistTop3,
          topUser: top(userCount),
          topUsers3: usersTop3,
          topGenre: top(genreCount),
          total: totalCount,
          played: playedCount,
          vip: vipRequests,
          z0vip: z0VipRequests
        };
      }

    function updateStatsTickerFromItems(items) {
      const el = document.querySelector('#stats-ticker .ticker-content');
      if (!el) return;
      if (el.getAttribute('data-react-root') === 'true') return;
      const s = computeDayStatsFromItems(items);
      function fmt(x) { return x && x.length ? x : 'N/D'; }
      const top3Txt = Array.isArray(s.topArtists3) && s.topArtists3.length ? s.topArtists3.join(', ') : 'N/D';
      const usersTop3Txt = Array.isArray(s.topUsers3) && s.topUsers3.length ? s.topUsers3.join(', ') : 'N/D';
      const latest = getLatestNonTestItem(items);
      const latestTxt = latest ? (String(latest.cancion || '').trim() + (latest.artista ? ' â€” ' + String(latest.artista).trim() : '')) : 'N/D';
      const dayText = 'ğŸ“… <strong>HOY</strong> â€¢ <strong>ğŸµ Ãšltima canciÃ³n solicitada:</strong> ' + fmt(latestTxt) + ' â€¢ <strong>ğŸ‘¥ Top 3 usuarios:</strong> ' + usersTop3Txt + ' â€¢ <strong>ğŸ¤ Top 3 artistas:</strong> ' + top3Txt + ' â€¢ <strong>ğŸ“ Solicitudes:</strong> ' + (s.total || 0);
      const g = window.__globalStats || computeGlobalStats();
      function fmtG(x) { return x && x.length ? x : 'N/D'; }
      const top3TxtGlobal = Array.isArray(g.topArtists3) && g.topArtists3.length ? g.topArtists3.join(', ') : 'N/D';
      const usersTop3TxtGlobal = Array.isArray(g.topUsers3) && g.topUsers3.length ? g.topUsers3.join(', ') : 'N/D';
      let avgTxtGlobal = 'N/D';
      if (typeof window.__globalTotalSolicitudes === 'number' && typeof window.__globalDistinctUsers === 'number' && window.__globalDistinctUsers > 0) {
        avgTxtGlobal = (window.__globalTotalSolicitudes / window.__globalDistinctUsers).toFixed(1);
      } else {
        const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
        const filtered = (solicitudes || []).filter(x => !isTestRequestForStats(x));
        const usersSet = new Set(filtered.map(x => String(x.usuario||'').trim()).filter(Boolean));
        avgTxtGlobal = usersSet.size ? (filtered.length / usersSet.size).toFixed(1) : '0.0';
      }
      const globalText = '<strong>HISTORIA:</strong> â€¢ <strong>ğŸµ CanciÃ³n mÃ¡s pedida:</strong> ' + fmtG(g.topSong) + (typeof g.topSongCount === 'number' ? ' (' + g.topSongCount + ')' : '') + '  â€¢  <strong>ğŸ‘¥ Top 3 usuarios:</strong> ' + usersTop3TxtGlobal + '  â€¢  <strong>ğŸ¤ Top 3 artistas:</strong> ' + top3TxtGlobal + '  â€¢  <strong>ğŸ“Š Total solicitudes:</strong> ' + (g.total || 0) + '  â€¢  <strong>ğŸ“ˆ Promedio por usuario:</strong> ' + avgTxtGlobal;
      const sep = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
      el.innerHTML = dayText + sep + globalText;
    }

      function updateModernWidgetPure() {
        const container = document.getElementById('react-modern-widget');
        if (!container) return;
        if (container.getAttribute('data-react-root') === 'true') return;
        function fmt(x){ return x && x.length ? x : 'N/D'; }
        const items = window.__dayItems || [];
        if (Array.isArray(items) && items.length) {
          const s = computeDayStatsFromItems(items);
          const chips = [
            { label: 'ğŸµ CanciÃ³n top', value: fmt(s.topSong)+' ('+(s.topSongCount||0)+')' },
            { label: 'ğŸ‘¤ Usuario top', value: fmt(s.topUser) },
            { label: 'ğŸ¤ Top 3 artistas', value: (Array.isArray(s.topArtists3)&&s.topArtists3.length ? s.topArtists3.join(', ') : 'N/D') },
            { label: 'ğŸ“… Hoy', value: String(s.total||0) }
          ];
          container.innerHTML = chips.map(c => `<div class="modern-chip"><span class="label">${c.label}</span><span class="value">${c.value}</span></div>`).join('');
          return;
        }
        const g = window.__globalStats || { total: 0, topArtists3: [], topSong: '', topUser: '' };
        const chips = [
          { label: 'ğŸµ CanciÃ³n top', value: fmt(g.topSong) },
          { label: 'ğŸ‘¤ Usuario top', value: fmt(g.topUser) },
          { label: 'ğŸ¤ Top 3 artistas', value: (Array.isArray(g.topArtists3)&&g.topArtists3.length ? g.topArtists3.join(', ') : 'N/D') },
          { label: 'ğŸ§® Total', value: String(g.total||0) }
        ];
        container.innerHTML = chips.map(c => `<div class="modern-chip"><span class="label">${c.label}</span><span class="value">${c.value}</span></div>`).join('');
      }

      // FunciÃ³n para actualizar la interfaz visual de canciones reproducidas
      function updatePlayedSongsUI(day, playedSongIds, skippedSongIds) {
        try {
          const currentDay = document.getElementById('day-select')?.value;
          
          // Solo actualizar si estamos viendo el dÃ­a correcto
          if (currentDay !== day) {
            console.log('DÃ­a diferente, no actualizando UI:', { currentDay, day });
            return;
          }
          
          console.log('ğŸ¨ Actualizando UI para canciones reproducidas:', {
            day,
            songs: playedSongIds,
            count: playedSongIds.length
          });
          
          // Obtener todos los elementos de canciones
          const songItems = document.querySelectorAll('.item[data-song-id]');
          const skippedSet = new Set((Array.isArray(skippedSongIds) ? skippedSongIds : []).map(x => String(x || '')));
          
          songItems.forEach(item => {
            const songId = item.getAttribute('data-song-id');
            const isPlayed = playedSongIds.includes(songId);
            const isSkipped = skippedSet.has(String(songId || ''));
            const iconEl = item.querySelector('.play-icon');
            
            if (isPlayed) {
              // Marcar como reproducida
              item.classList.add('played');
              item.classList.toggle('skipped', isSkipped);
              if (iconEl) iconEl.textContent = isSkipped ? 'â­ï¸' : 'â–¶ï¸';
            } else {
              // Desmarcar como reproducida
              item.classList.remove('played');
              item.classList.remove('skipped');
              if (iconEl) iconEl.textContent = 'â–¶ï¸';
              
              // Remover indicador visual si existe
              const indicator = item.querySelector('.played-indicator');
              if (indicator) {
                indicator.remove();
              }
              
              // Restaurar estilos originales
              item.style.backgroundColor = '';
              item.style.color = '';
              item.style.opacity = '';
            }
          });
          
          // Forzar aplicaciÃ³n de estilos
          setTimeout(() => {
            forcePlayedSongStyles();
          }, 100);
          
        } catch (error) {
          console.error('Error actualizando UI de canciones reproducidas:', error);
        }
      }

      // SuscripciÃ³n a orden manual compartido por dÃ­a (Firestore/localStorage)
      function subscribeManualOrderForDay(day) {
        try {
          if (unsubscribeManualOrder) {
            unsubscribeManualOrder();
            unsubscribeManualOrder = null;
          }

          // Fallback inmediato a localStorage
          try {
            const localOrder = JSON.parse(localStorage.getItem(`manualOrder:${day}`) || '[]');
            if (Array.isArray(localOrder)) {
              currentManualOrder = localOrder;
            }
          } catch (_) {}

          try { reorderCurrentDayItemsWithManualOrder(day); } catch (_) {}

          if (!window.db) {
            return;
          }

          unsubscribeManualOrder = window.db.collection('manualOrders').doc(day)
            .onSnapshot((doc) => {
              const data = doc.data();
              const remoteOrder = Array.isArray(data?.order) ? data.order : [];
              currentManualOrder = remoteOrder;
              try { localStorage.setItem(`manualOrder:${day}`, JSON.stringify(currentManualOrder)); } catch (_) {}
              reorderCurrentDayItemsWithManualOrder(day);
            }, (err) => {
              console.error('Error suscripciÃ³n orden manual:', err);
            });
        } catch (e) {
          console.error('Error al suscribir orden manual:', e);
        }
      }

      // Reordenar elementos actuales usando el orden manual compartido
      function reorderCurrentDayItemsWithManualOrder(day) {
        try {
          const currentDay = document.getElementById('day-select')?.value;
          if (currentDay !== day) return;
          if (!isManualSortMode()) return;
          const ordered = applyDisplayOrder(currentDayItems);
          currentDayItems = ordered;
          window.__dayItems = ordered;
          renderSolicitudes(ordered);
        } catch (e) {
          console.error('Error reordenando items con orden manual:', e);
          if (!isManualSortMode()) return;
          const ordered = applyDisplayOrder(currentDayItems);
          currentDayItems = ordered;
          window.__dayItems = ordered;
          renderSolicitudes(ordered);
        }
      }

      async function renderAllUsersSelect() {
        const allUsersSelect = document.getElementById('all-users-select');
        const allUsersSelectDonador = document.getElementById('all-users-select-donador');
        // Si no existen los elementos en el DOM, no hacer nada
        if (!allUsersSelect) return;

        const userMap = new Map();
        const addUser = (rawName) => {
           const u = String(rawName || '').trim();
           if (!u) return;
           const key = u.toLowerCase();
           // Estrategia: si no existe, lo agregamos.
           // Si existe, podrÃ­amos reemplazar si el nuevo tiene mejor capitalizaciÃ³n, 
           // pero por simplicidad y estabilidad, nos quedamos con el primero (o el Ãºltimo).
           if (!userMap.has(key)) {
             userMap.set(key, u);
           }
        };
        
        try {
          const items = Array.isArray(window.__dayItems) ? window.__dayItems : [];
          items.forEach(it => addUser(it?.usuario));
        } catch (_) {}

        try {
          const all = await getAllCombinedSolicitudes();
          (all || []).forEach(s => addUser(s?.usuario));
        } catch (_) {}

        try {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          Object.values(byDay).forEach(arr => (arr || []).forEach(it => addUser(it.usuario)));
        } catch (error) { }

        try {
          const cached = JSON.parse(localStorage.getItem('knownUsers') || '[]') || [];
          cached.forEach(name => addUser(name));
        } catch (_) {}

        try {
          const dbRef = window.db || db;
          if (dbRef) {
            const statsSnap = await dbRef.collection('userStats').get();
            statsSnap.forEach(doc => { if (doc.id) addUser(doc.id); });
          }
        } catch (_) {}

        try {
          const dbRef = window.db || db;
          if (dbRef) {
            const usersSnap = await dbRef.collection('users').get();
            usersSnap.forEach(doc => {
              const d = doc.data() || {};
              if (d.name) addUser(d.name);
            });
          }
        } catch (_) {}

        const list = Array.from(userMap.values()).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        try { localStorage.setItem('knownUsers', JSON.stringify(list)); } catch (_) {}
        
        // FunciÃ³n helper para llenar selects
        const fillSelect = (el) => {
           if (!el) return;
           const currentVal = el.value; // Preservar valor si ya tenÃ­a algo
           el.innerHTML = '<option value="">Selecciona un usuario</option>';
           list.forEach(name => {
             const opt = document.createElement('option');
             opt.value = name;
             opt.textContent = name;
             el.appendChild(opt);
           });
           if (currentVal && list.includes(currentVal)) {
             el.value = currentVal;
           }
        };

        fillSelect(allUsersSelect);
        fillSelect(document.getElementById('all-users-select-z0'));
        fillSelect(document.getElementById('all-users-select-donador'));
        fillSelect(document.getElementById('all-users-select-z0-fan'));
        fillSelect(document.getElementById('all-users-select-z0-platino'));
      }
      window.renderAllUsersSelect = renderAllUsersSelect;

      vipAddBtn?.addEventListener('click', async () => {
        const name = allUsersSelect.value.trim();
        if (!name) {
          alert('Selecciona un usuario del listado.');
          return;
        }
        try {
          await db.collection('vipUsers').doc(name).set({ 
            name,
            activatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
        } catch (err) {
          console.error('Error al agregar VIP:', err);
          alert('No se pudo agregar el usuario a VIP. Revisa reglas/permisos.');
        }
      });

      const z0VipAddBtn = document.getElementById('z0-vip-add');
      const z0FanAddBtn = document.getElementById('z0-fan-add');
      const z0PlatinoAddBtn = document.getElementById('z0-platino-add');
      z0VipAddBtn?.addEventListener('click', async () => {
        const allUsersSelectZ0 = document.getElementById('all-users-select-z0');
        const name = allUsersSelectZ0?.value.trim();
        if (!name) {
          alert('Selecciona un usuario del listado.');
          return;
        }
        try {
          await db.collection('z0VipUsers').doc(name).set({ name }, { merge: true });
        } catch (err) {
          console.error('Error al agregar Z0-VIP:', err);
          alert('No se pudo agregar el usuario a Z0-VIP. Revisa reglas/permisos.');
        }
      });

      donadorAddBtn?.addEventListener('click', async () => {
        const name = allUsersSelectDonador?.value.trim();
        if (!name) {
          alert('Selecciona un usuario del listado.');
          return;
        }
        
        // Calcular fecha de expiraciÃ³n (maÃ±ana a las 23:59:59)
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(23, 59, 59, 999);
        const expiresAt = tomorrow.toISOString();
        
        try {
          await db.collection('donadorUsers').doc(name).set({ 
            name, 
            expiresAt,
            createdAt: new Date().toISOString()
          }, { merge: true });
          
          // Limpiar selecciÃ³n
          allUsersSelectDonador.value = '';
          
        } catch (err) {
          console.error('Error al agregar Donador:', err);
          alert('No se pudo agregar el usuario como Donador. Revisa reglas/permisos.');
        }
      });

      z0FanAddBtn?.addEventListener('click', async () => {
        const sel = document.getElementById('all-users-select-z0-fan');
        const name = sel?.value.trim();
        if (!name) { alert('Selecciona un usuario del listado.'); return; }
        try { await db.collection('z0FanUsers').doc(name).set({ name }, { merge: true }); sel.value=''; } catch (err) { console.error('Error z0-Fan:', err); alert('No se pudo agregar z0-Fan.'); }
      });

      z0PlatinoAddBtn?.addEventListener('click', async () => {
        const sel = document.getElementById('all-users-select-z0-platino');
        const name = sel?.value.trim();
        if (!name) { alert('Selecciona un usuario del listado.'); return; }
        try { await db.collection('z0PlatinumUsers').doc(name).set({ name }, { merge: true }); sel.value=''; } catch (err) { console.error('Error z0-Platino:', err); alert('No se pudo agregar z0-Platino.'); }
      });

      vipListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('.remove-btn');
        if (!btn) return;
        const user = btn.getAttribute('data-user');
        if (!user) return;

        pendingVipRemoveUser = user;
        pendingVipRemoveType = 'vip';
        vipRemoveUserSpan.textContent = user;
        vipRemoveModal.hidden = false;
      });

      const z0VipListEl = document.getElementById('z0-vip-list');
      const z0FanListEl = document.getElementById('z0-fan-list');
      const z0PlatinoListEl = document.getElementById('z0-platino-list');
      z0VipListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('.remove-btn');
        if (!btn) return;
        const user = btn.getAttribute('data-user');
        const type = btn.getAttribute('data-type');
        if (!user) return;

        pendingVipRemoveUser = user;
        pendingVipRemoveType = type || 'z0';
        vipRemoveUserSpan.textContent = user;
        vipRemoveModal.hidden = false;
      });

      donadorListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('.remove-btn');
        if (!btn) return;
        const user = btn.getAttribute('data-user');
        const type = btn.getAttribute('data-type');
        if (!user) return;

        pendingVipRemoveUser = user;
        pendingVipRemoveType = type || 'donador';
        vipRemoveUserSpan.textContent = user;
        vipRemoveModal.hidden = false;
      });

      z0FanListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('.remove-btn');
        if (!btn) return;
        const user = btn.getAttribute('data-user');
        const type = btn.getAttribute('data-type');
        if (!user) return;
        pendingVipRemoveUser = user;
        pendingVipRemoveType = type || 'z0-fan';
        vipRemoveUserSpan.textContent = user;
        vipRemoveModal.hidden = false;
      });

      z0PlatinoListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('.remove-btn');
        if (!btn) return;
        const user = btn.getAttribute('data-user');
        const type = btn.getAttribute('data-type');
        if (!user) return;
        pendingVipRemoveUser = user;
        pendingVipRemoveType = type || 'z0-platino';
        vipRemoveUserSpan.textContent = user;
        vipRemoveModal.hidden = false;
      });

      vipRemoveCancelBtn?.addEventListener('click', () => {
        pendingVipRemoveUser = null;
        pendingVipRemoveType = 'vip';
        vipRemoveModal.hidden = true;
      });

      vipRemoveConfirmBtn?.addEventListener('click', async () => {
        if (!pendingVipRemoveUser) return;
        try {
          let collection = 'vipUsers';
          if (pendingVipRemoveType === 'z0') {
            collection = 'z0VipUsers';
          } else if (pendingVipRemoveType === 'donador') {
            collection = 'donadorUsers';
          } else if (pendingVipRemoveType === 'z0-fan') {
            collection = 'z0FanUsers';
          } else if (pendingVipRemoveType === 'z0-platino') {
            collection = 'z0PlatinumUsers';
          }
          await db.collection(collection).doc(pendingVipRemoveUser).delete();
        } catch (err) {
          console.error('Error al quitar insignia:', err);
          alert('No se pudo quitar la insignia. Revisa reglas/permisos.');
        } finally {
          pendingVipRemoveUser = null;
          pendingVipRemoveType = 'vip';
          vipRemoveModal.hidden = true;
        }
      });

      const wipeAllModal = document.getElementById('wipe-all-modal');
      const wipeAllDaySpan = document.getElementById('wipe-all-day');
      const wipeAllCancelBtn = document.getElementById('wipe-all-cancel');
      const wipeAllConfirmBtn = document.getElementById('wipe-all-confirm');
      const recalculateUsersBtn = document.getElementById('recalculate-users');
      const diagnoseDataBtn = document.getElementById('diagnose-data-btn');

      wipeAllBtn?.addEventListener('click', () => {
        if (!daySelect.value) return;
        wipeAllDaySpan.textContent = daySelect.value;
        wipeAllModal.hidden = false;
      });

      wipeAllCancelBtn?.addEventListener('click', () => {
        wipeAllModal.hidden = true;
      });

      wipeAllConfirmBtn?.addEventListener('click', async () => {
        const day = daySelect.value;
        if (!day) {
          wipeAllModal.hidden = true;
          return;
        }

        wipeAllBtn.disabled = true;

        try {
          const snap = await db.collection('solicitudes').where('day', '==', day).get();
          const docs = snap.docs;

          const chunkSize = 500;
          for (let i = 0; i < docs.length; i += chunkSize) {
            const batch = db.batch();
            const chunk = docs.slice(i, i + chunkSize);
            chunk.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
          }

          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          if (byDay && byDay[day]) {
            delete byDay[day];
            localStorage.setItem('solicitudes_by_day', JSON.stringify(byDay));
          }

          if (daySelect.value === day) {
            subscribeSolicitudesForDay(day);
          }
        } catch (err) {
          console.error('Error al borrar solicitudes:', err);
          alert('OcurriÃ³ un error al borrar las solicitudes. Verifica reglas y vuelve a intentar.');
        } finally {
          wipeAllBtn.disabled = false;
          wipeAllModal.hidden = true;
        }
      });

      // Event listener para recÃ¡lculo de usuarios
      recalculateUsersBtn?.addEventListener('click', async () => {
        const confirmed = await showConfirmation({
          icon: 'ğŸ”„',
          title: 'Recalcular Usuarios',
          message: 'Â¿Confirmas que quieres recalcular todos los usuarios? Esto corregirÃ¡ puntos e insignias inconsistentes.',
          confirmText: 'SÃ­, Recalcular',
          cancelText: 'Cancelar'
        });
        
        if (confirmed) {
          recalculateUsersBtn.disabled = true;
          recalculateUsersBtn.textContent = 'ğŸ”„ Recalculando...';
          
          try {
            await recalculateAllUsers();
          } finally {
            recalculateUsersBtn.disabled = false;
            recalculateUsersBtn.textContent = 'ğŸ”„ Recalcular todos los usuarios';
          }
        }
      });
      
      /* 
         BLOQUE ELIMINADO: Listeners de herramientas de diagnÃ³stico y prueba eliminados por limpieza.
         - diagnoseDataBtn listener removed
         - test-user-switch-btn listener removed
         - debug-current-user-btn listener removed
      */

      daySelect?.addEventListener('change', () => {
        if (daySelect.value) {
          try { subscribeManualOrderForDay(daySelect.value); } catch (e) { console.warn('FallÃ³ subscribeManualOrderForDay:', e); }
          try { subscribeSolicitudesForDay(daySelect.value); } catch (e) { console.warn('FallÃ³ subscribeSolicitudesForDay:', e); }
          try { subscribePlayedSongs(daySelect.value); } catch (e) { console.warn('FallÃ³ subscribePlayedSongs:', e); }
        }
      });
      vipOnly?.addEventListener('change', () => {
        if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
      });
      sortSelect?.addEventListener('change', () => {
        try { localStorage.setItem(SORT_MODE_KEY, String(sortSelect.value || '').trim()); } catch (_) {}
        if (daySelect.value) subscribeSolicitudesForDay(daySelect.value);
      });

      (async function init() {
        console.log('ğŸš€ Iniciando aplicaciÃ³n...');
        try {
          const saved = String(localStorage.getItem(SORT_MODE_KEY) || '').trim();
          const initial = allowedSortModes.has(saved) ? saved : 'recent';
          if (sortSelect) sortSelect.value = initial;
          localStorage.setItem(SORT_MODE_KEY, initial);
        } catch (_) {}
        await loadDays();
        // Mostrar estado inicial aunque no haya datos todavÃ­a
        try { renderSolicitudes([]); } catch (_) {}
        console.log('ğŸ“… DÃ­as cargados, iniciando suscripciones...');
        subscribeVipUsers();
        subscribeZ0VipUsers();
        subscribeDonadorUsers();
        subscribeZ0FanUsers();
        subscribeZ0PlatinoUsers();
        try {
          const rawSel = localStorage.getItem('selectedBadges');
          if (rawSel) {
            const m = JSON.parse(rawSel);
            if (m && typeof m === 'object') {
              window.selectedBadgeMap = m;
              try { if (typeof applySelectedBadgeToAll === 'function') applySelectedBadgeToAll(); } catch (_) {}
            }
          }
        } catch (_) {}
        try {
          const localPlayedMapDays = Object.keys(JSON.parse(localStorage.getItem('playedSongs') || '{}') || {});
          localPlayedMapDays.forEach(d => { if (d) daysSet.add(d); });
        } catch (_) {}
        try { if (typeof subscribeSelectedBadges === 'function') subscribeSelectedBadges(); } catch (_) {}
        try { if (shouldShowStatsTicker()) { ensureStatsTicker(); startStatsTicker(); } } catch (_) {}
        console.log('âœ… Suscripciones iniciadas');
        await renderAllUsersSelect();
        if (daySelect.value) {
          subscribeManualOrderForDay(daySelect.value);
          subscribeSolicitudesForDay(daySelect.value);
          subscribePlayedSongs(daySelect.value);
        }
      })();
    })();
  </script>

  <script>
    function shouldShowStatsTicker() {
      try {
        const params = new URLSearchParams(window.location.search);
        if (params.get('showTicker') === '0') return false;
        if (params.get('showTicker') === '1') return true;
        return true;
      } catch (_) { return false; }
    }
    function ensureStatsTicker() {
      const el = document.getElementById('stats-ticker');
      if (!el) return;
      document.body.classList.add('has-stats-ticker');
      el.hidden = !shouldShowStatsTicker();
    }

    function computeGlobalStats() {
      let solicitudes = [];
      try { solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]') || []; } catch (_) { solicitudes = []; }
      try {
        const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}') || {};
        Object.values(byDay).forEach(arr => {
          (arr || []).forEach(it => { if (it) solicitudes.push(it); });
        });
      } catch (_) {}
      const songCount = {}; const artistCount = {}; const userCount = {}; const genreCount = {}; const artistOriginal = {}; const userOriginal = {};
      for (let i = 0; i < solicitudes.length; i++) {
        const s = solicitudes[i] || {};
        if (window.isTestRequestForStats ? window.isTestRequestForStats(s) : (String(s.usuario || '').trim().toLowerCase() === 'prueba')) continue;
        const uNorm = window.normalizeUserForStats ? window.normalizeUserForStats(s.usuario) : String(s.usuario || '').trim().toLowerCase();
        const song = String(s.cancion || '').trim().toLowerCase();
        const artist = String(s.artista || '').trim().toLowerCase();
        const user = uNorm;
        const genre = String(s.genero || '').trim().toLowerCase();
        if (song) songCount[song] = (songCount[song] || 0) + 1;
        if (artist) { artistCount[artist] = (artistCount[artist] || 0) + 1; if (!artistOriginal[artist]) artistOriginal[artist] = String(s.artista || '').trim(); }
        if (user) { userCount[user] = (userCount[user] || 0) + 1; if (!userOriginal[user]) userOriginal[user] = String(s.usuario || '').trim(); }
        if (genre) genreCount[genre] = (genreCount[genre] || 0) + 1;
      }
      function top(map) { let k = ''; let v = 0; for (const key in map) { const val = map[key]; if (val > v) { v = val; k = key; } else if (val === v && (!k || key.localeCompare(k) < 0)) { k = key; } } return k; }
      const ta = top(artistCount);
      const artistTop3 = Object.keys(artistCount)
        .map(k => ({ k, c: artistCount[k], o: artistOriginal[k] || k }))
        .sort((a, b) => { var d = b.c - a.c; if (d !== 0) return d; return a.k.localeCompare(b.k); })
        .slice(0, 3)
        .map(it => `${it.o} (${it.c})`);
      const usersTop3 = Object.keys(userCount)
        .map(k => ({ k, c: userCount[k], o: userOriginal[k] || k }))
        .sort((a, b) => { var d = b.c - a.c; if (d !== 0) return d; return a.k.localeCompare(b.k); })
        .slice(0, 3)
        .map(it => `${it.o} (${it.c})`);
      const ts = top(songCount);
      return {
        topSong: ts,
        topSongCount: ts ? (songCount[ts] || 0) : 0,
        topArtist: ta,
        topArtists3: artistTop3,
        topUser: top(userCount),
        topUsers3: usersTop3,
        topGenre: top(genreCount),
        total: Object.values(userCount).reduce((a, b) => a + b, 0)
      };
    }

    function updateStatsTicker() {
      const el = document.querySelector('#stats-ticker .ticker-content');
      if (!el) return;
      if (el.getAttribute('data-react-root') === 'true') return;
      function fmt(x) { return x && x.length ? x : 'N/D'; }
      const items = window.__dayItems || [];
      let dayText = '';
      try {
        const ds = computeDayStatsFromItems(items);
        const top3TxtDay = Array.isArray(ds.topArtists3) && ds.topArtists3.length ? ds.topArtists3.join(', ') : 'N/D';
        const usersTop3TxtDay = Array.isArray(ds.topUsers3) && ds.topUsers3.length ? ds.topUsers3.join(', ') : 'N/D';
        const latest = window.getLatestNonTestItem ? window.getLatestNonTestItem(items) : (Array.isArray(items) && items.length ? items[items.length - 1] : null);
        const latestTxt = latest ? (String(latest.cancion || '').trim() + (latest.artista ? ' â€” ' + String(latest.artista).trim() : '')) : 'N/D';
        dayText = 'ğŸ“… <strong>HOY</strong> â€¢ <strong>ğŸµ Ãšltima canciÃ³n solicitada:</strong> ' + fmt(latestTxt) + ' â€¢ <strong>ğŸ‘¥ Top 3 usuarios:</strong> ' + usersTop3TxtDay + ' â€¢ <strong>ğŸ¤ Top 3 artistas:</strong> ' + top3TxtDay + ' â€¢ <strong>ğŸ“ Solicitudes:</strong> ' + (ds.total || 0);
      } catch (_) {}
      const g = window.__globalStats || computeGlobalStats();
      const top3Txt = Array.isArray(g.topArtists3) && g.topArtists3.length ? g.topArtists3.join(', ') : 'N/D';
      
      // Usar Top Puntos (GamificaciÃ³n) si estÃ¡ disponible, si no fallback a Top Solicitudes
      const pointsTop3 = window.__globalTopPointsUsers;
      const usersTop3Txt = Array.isArray(pointsTop3) && pointsTop3.length ? pointsTop3.join(', ') : (Array.isArray(g.topUsers3) && g.topUsers3.length ? g.topUsers3.join(', ') : 'N/D');
      const usersLabel = (Array.isArray(pointsTop3) && pointsTop3.length) ? 'ğŸ† Top 3 PuntuaciÃ³n' : 'ğŸ‘¥ Top 3 usuarios';
      
      let avgTxt = 'N/D';
      if (typeof window.__globalTotalSolicitudes === 'number' && typeof window.__globalDistinctUsers === 'number' && window.__globalDistinctUsers > 0) {
        avgTxt = (window.__globalTotalSolicitudes / window.__globalDistinctUsers).toFixed(1);
      } else {
        const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
        const filtered = (solicitudes || []).filter(x => (window.isTestRequestForStats ? !window.isTestRequestForStats(x) : (String(x?.usuario || '').trim().toLowerCase() !== 'prueba')));
        const usersSet = new Set(filtered.map(x => String(x.usuario||'').trim()).filter(Boolean));
        avgTxt = usersSet.size ? (filtered.length / usersSet.size).toFixed(1) : '0.0';
      }
      const globalText = '<strong>HISTORIA:</strong> â€¢ <strong>ğŸµ CanciÃ³n mÃ¡s pedida:</strong> ' + fmt(g.topSong) + (typeof g.topSongCount === 'number' ? ' (' + g.topSongCount + ')' : '') + '  â€¢  <strong>' + usersLabel + ':</strong> ' + usersTop3Txt + '  â€¢  <strong>ğŸ¤ Top 3 artistas:</strong> ' + top3Txt + '  â€¢  <strong>ğŸ“Š Total solicitudes:</strong> ' + (g.total || 0) + '  â€¢  <strong>ğŸ“ˆ Promedio por usuario:</strong> ' + avgTxt;
      const sep2 = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
      el.innerHTML = (dayText ? (dayText + sep2) : '') + globalText;
    }

    function refreshStatsTicker() {
      const items = window.__dayItems;
      if (Array.isArray(items) && items.length) {
        try { updateStatsTickerFromItems(items); } catch (_) {}
        try { updateModernWidgetPure(); } catch (_) {}
        return;
      }
      updateStatsTicker();
      try { updateModernWidgetPure(); } catch (_) {}
    }
    window.refreshStatsTicker = refreshStatsTicker;

    function subscribeStatsTicker() {
      if (!window.db) { updateStatsTicker(); return; }
      if (window.__statsTickerUnsub) { try { window.__statsTickerUnsub(); } catch (_) {} }
      window.__statsTickerUnsub = db.collection('solicitudes').onSnapshot((snap) => {
        const songCount = {}; const artistCount = {}; const userCount = {}; const genreCount = {}; const artistOriginal = {}; const userOriginal = {};
        let total = 0;
        snap.forEach((doc) => {
          const d = doc.data() || {};
          if (window.isTestRequestForStats ? window.isTestRequestForStats(d) : (String(d.usuario || '').trim().toLowerCase() === 'prueba')) return;
          const uNorm = window.normalizeUserForStats ? window.normalizeUserForStats(d.usuario) : String(d.usuario || '').trim().toLowerCase();
          const song = String(d.cancion || '').trim().toLowerCase();
          const artist = String(d.artista || '').trim().toLowerCase();
          const user = uNorm;
          const genre = String(d.genero || '').trim().toLowerCase();
          if (song) songCount[song] = (songCount[song] || 0) + 1;
          if (artist) { artistCount[artist] = (artistCount[artist] || 0) + 1; if (!artistOriginal[artist]) artistOriginal[artist] = String(d.artista || '').trim(); }
          if (user) { userCount[user] = (userCount[user] || 0) + 1; if (!userOriginal[user]) userOriginal[user] = String(d.usuario || '').trim(); }
          if (genre) genreCount[genre] = (genreCount[genre] || 0) + 1;
          total++;
        });
        function top(map) { let k = ''; let v = 0; for (const key in map) { const val = map[key]; if (val > v) { v = val; k = key; } else if (val === v && (!k || key.localeCompare(k) < 0)) { k = key; } } return k; }
        const ta = top(artistCount);
        const artistTop3 = Object.keys(artistCount)
          .map(k => ({ k, c: artistCount[k], o: artistOriginal[k] || k }))
          .sort((a, b) => { var d = b.c - a.c; if (d !== 0) return d; return a.k.localeCompare(b.k); })
          .slice(0, 3)
          .map(it => `${it.o} (${it.c})`);
        const usersTop3 = Object.keys(userCount)
          .map(k => ({ k, c: userCount[k], o: userOriginal[k] || k }))
          .sort((a, b) => { var d = b.c - a.c; if (d !== 0) return d; return a.k.localeCompare(b.k); })
          .slice(0, 3)
          .map(it => `${it.o} (${it.c})`);
        const ts = top(songCount);
        window.__globalStats = {
          topSong: ts,
          topSongCount: ts ? (songCount[ts] || 0) : 0,
          topArtist: ta,
          topArtists3: artistTop3,
          topUser: top(userCount),
          topUsers3: usersTop3,
          topGenre: top(genreCount),
          total
        };
        window.__globalDistinctUsers = Object.keys(userCount).length;
        window.__globalUserCountMap = userCount;
        window.__globalTotalSolicitudes = total;
        refreshStatsTicker();
      }, () => { updateStatsTicker(); });
    }

    function subscribeUserStatsGenres() {
      if (!window.db) return;
      if (window.__userStatsGenresUnsub) { try { window.__userStatsGenresUnsub(); } catch (_) {} }
      window.__userStatsGenresUnsub = db.collection('userStats').onSnapshot((snap) => {
        const count = {};
        const usersPoints = [];
        
        snap.forEach((doc) => {
          const d = doc.data() || {};
          try {
            const keyName = d.displayName || doc.id;
            const n = (window.normalizeUserForStats ? window.normalizeUserForStats(keyName) : String(keyName || '').trim().toLowerCase());
            if (!n || n === 'prueba' || n.startsWith('prueba')) return;
          } catch (_) {}
          
          // LÃ³gica de gÃ©neros existente
          if (d && typeof d.genresCount === 'object') {
            const m = d.genresCount || {};
            Object.keys(m).forEach(g => { const key = String(g || '').trim().toLowerCase(); const val = Number(m[g] || 0); if (key) count[key] = (count[key] || 0) + val; });
          }
          if (Array.isArray(d.genres)) {
            d.genres.forEach(g => { const key = String(g || '').trim().toLowerCase(); if (key) count[key] = (count[key] || 0) + 1; });
          }
          if (Array.isArray(d.topGenres)) {
            d.topGenres.forEach(g => { const key = String(g || '').trim().toLowerCase(); if (key) count[key] = (count[key] || 0) + 1; });
          }
          if (typeof d.favoriteGenre === 'string' && d.favoriteGenre) {
            const key = String(d.favoriteGenre || '').trim().toLowerCase(); if (key) count[key] = (count[key] || 0) + 1;
          }
          if (typeof d.topGenre === 'string' && d.topGenre) {
            const key = String(d.topGenre || '').trim().toLowerCase(); if (key) count[key] = (count[key] || 0) + 1;
          }
          if (d.stats && typeof d.stats.topGenre === 'string') {
            const key = String(d.stats.topGenre || '').trim().toLowerCase(); if (key) count[key] = (count[key] || 0) + 1;
          }
          
          // Nueva lÃ³gica para Top Puntos
          const pts = Number(d.totalPoints || 0);
          if (pts > 0) {
             // Intentar obtener nombre formateado si existe en el doc, si no usar ID
             const name = d.displayName || doc.id;
             usersPoints.push({ user: name, points: pts });
          }
        });
        
        // Calcular Top GÃ©nero
        let gTop = '';
        let gVal = 0;
        Object.keys(count).forEach(k => { const v = count[k]; if (v > gVal) { gVal = v; gTop = k; } });
        window.__globalGenreTop = gTop;
        window.__globalGenreCount = gVal;
        
        // Calcular Top 3 Puntos
        usersPoints.sort((a,b) => { var d = b.points - a.points; if (d !== 0) return d; return a.user.localeCompare(b.user); });
        const top3 = usersPoints.slice(0, 3).map(u => `${u.user} (${u.points})`);
        window.__globalTopPointsUsers = top3;
        
        refreshStatsTicker();
      }, () => {});
    }

    function startStatsTicker() {
      refreshStatsTicker();
      if (window.__statsTickerInterval) clearInterval(window.__statsTickerInterval);
      window.__statsTickerInterval = setInterval(refreshStatsTicker, 60000);
      subscribeStatsTicker();
      try { subscribeUserStatsGenres(); } catch (_) {}
      try {
        const daySel = document.getElementById('day-select')?.value;
        if (!daySel) {
          const d = new Date();
          const todayKey = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
          if (typeof window.subscribeSolicitudesForDay === 'function') {
            window.subscribeSolicitudesForDay(todayKey);
          }
        }
      } catch (_) {}
    }
    try { ensureStatsTicker(); startStatsTicker(); } catch (_) {}
    // Variables globales del menÃº
    let menuBtn = document.getElementById('menu-btn');
    let menuDropdown = document.getElementById('menu-dropdown');
    
    // Funciones globales del menÃº
    function positionMenu() {
      if (!menuDropdown || !menuBtn) return;
      if (window.innerWidth > 768) {
        const btnRect = menuBtn.getBoundingClientRect();
        const padding = 8;
        const menuWidth = 220;
        const leftPosition = btnRect.right - menuWidth;
        let top = btnRect.bottom + padding;
        const finalLeft = Math.max(leftPosition, 10);
        const menuHeight = Math.min(menuDropdown.offsetHeight || 350, window.innerHeight - 16);
        if (top + menuHeight > window.innerHeight) {
          top = Math.max(10, btnRect.top - menuHeight - padding);
        }
        const maxTop = window.innerHeight - menuHeight - 10;
        top = Math.max(10, Math.min(top, maxTop));
        menuDropdown.style.top = top + 'px';
        menuDropdown.style.left = finalLeft + 'px';
        menuDropdown.style.right = 'auto';
      }
    }

      function openMenu() {
        if (!menuDropdown || !menuBtn) return;
        menuDropdown.hidden = false;
        requestAnimationFrame(() => {
          menuDropdown.classList.add('open');
          menuBtn.setAttribute('aria-expanded', 'true');
          if (window.innerWidth > 768) {
            positionMenu();
          }
        });
      }
    
    function closeMenu() {
      if (!menuDropdown) return;
      menuDropdown.classList.remove('open');
      menuBtn?.setAttribute('aria-expanded', 'false');
      const onEnd = (e) => {
        if (e.target !== menuDropdown) return;
        menuDropdown.hidden = true;
        menuDropdown.removeEventListener('transitionend', onEnd);
      };
      menuDropdown.addEventListener('transitionend', onEnd);
    }

    (function () {
      const menuAdminOpen = document.getElementById('menu-admin-open');
      const menuSearchOpen = document.getElementById('menu-search-open');

      // Referencias del changelog (una sola vez)
      const menuChangelogOpen = document.getElementById('menu-changelog-open');
      const changelogModal = document.getElementById('changelog-modal');
      const changelogCloseBtn = document.getElementById('changelog-close');

      const searchInput = document.getElementById('search-input');
      const searchResults = document.getElementById('search-results');
      const searchBox = document.querySelector('.search-box');
      const daySelect = document.getElementById('day-select');

      const ADMIN_PASS = '1415130*';
      const adminModal = document.getElementById('admin-modal');
      const adminPanel = document.getElementById('admin-panel');
      const adminPassInput = document.getElementById('admin-pass-input');
      const adminPassError = document.getElementById('admin-auth-error');
      const adminPassCancelBtn = document.getElementById('admin-pass-cancel');
      const adminPassConfirmBtn = document.getElementById('admin-pass-confirm');
      const allUsersSelect = document.getElementById('all-users-select');
      const vipAddBtn = document.getElementById('vip-add');
      const adminExitBtn = document.getElementById('admin-exit');

      // Variables para el sistema de secciones del panel admin
      const adminSectionSelect = document.getElementById('admin-section-select');
      const badgesSection = document.getElementById('badges-section');
      const rewardsSection = document.getElementById('rewards-section');
      const maintenanceSection = document.getElementById('maintenance-section');
      
      // Variables para el selector de insignias
      const badgeTypeSelect = document.getElementById('badge-type-select');
      const vipManagement = document.getElementById('vip-management');
      const z0VipManagement = document.getElementById('z0-vip-management');
      const donadorManagement = document.getElementById('donador-management');
      const badgeTabs = Array.from(document.querySelectorAll('.badge-tab[data-badge]'));

      const userDeleteBtn = document.getElementById('user-delete');
      const userDeleteModal = document.getElementById('user-delete-modal');
      const userDeleteNameSpan = document.getElementById('user-delete-name');
      const userDeleteCancelBtn = document.getElementById('user-delete-cancel');
      const userDeleteConfirmBtn = document.getElementById('user-delete-confirm');
      let pendingUserDelete = null;

      

      adminModal.hidden = true;
      adminPanel.hidden = true;
      // Event listeners para el modal de Admin
      menuAdminOpen?.addEventListener('click', () => {
        closeMenu();
        adminModal.hidden = false;
        adminPassInput.value = '';
        adminPassError.hidden = true;
        adminPassInput.focus();
      });


      function tryOpenAdmin() {
        const pass = adminPassInput.value;
        if (pass === ADMIN_PASS) {
          adminModal.hidden = true;
          adminPanel.hidden = false;
          window.renderAllUsersSelect?.();
          console.log('âœ… Panel de administraciÃ³n abierto');
        } else {
          adminPassError.hidden = false;
          adminPassInput.focus();
        }
      }

      // Event listeners para el modal de Admin
      adminPassConfirmBtn?.addEventListener('click', tryOpenAdmin);
      adminPassCancelBtn?.addEventListener('click', () => {
        adminModal.hidden = true;
      });
      adminPassInput?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          tryOpenAdmin();
        }
      });

      adminExitBtn?.addEventListener('click', () => {
          adminPanel.hidden = true;
          adminModal.hidden = true;
          adminPassInput.value = '';
          adminPassError.hidden = true;
        });

      const adminSectionTabs = Array.from(document.querySelectorAll('.admin-section-tab'));
      adminSectionTabs.forEach((btn) => {
        btn.addEventListener('click', () => {
          const section = btn.getAttribute('data-section') || '';
          if (section) showAdminSection(section);
        });
      });

      // Event listeners para el sistema de secciones
      adminSectionSelect?.addEventListener('change', (e) => {
        showAdminSection(e.target.value);
      });

      badgeTypeSelect?.addEventListener('change', (e) => {
        showBadgeManagement(e.target.value);
        syncBadgeTabs(e.target.value);
      });

      badgeTabs.forEach((btn) => {
        btn.addEventListener('click', () => {
          const badgeType = btn.getAttribute('data-badge') || 'vip';
          if (badgeTypeSelect) badgeTypeSelect.value = badgeType;
          showBadgeManagement(badgeType);
          syncBadgeTabs(badgeType);
        });
      });

      // FunciÃ³n para mostrar el panel de administraciÃ³n
      function showAdminPanel() {
        adminPanel.hidden = false;
        window.renderAllUsersSelect?.();
        showAdminSection('badges'); // Mostrar secciÃ³n de insignias por defecto
      }

      // FunciÃ³n para mostrar una secciÃ³n especÃ­fica del admin
      function showAdminSection(section) {
        if (adminSectionSelect) adminSectionSelect.value = section;
        if (adminSectionTabs && adminSectionTabs.length) {
          adminSectionTabs.forEach((btn) => {
            const isActive = btn.getAttribute('data-section') === section;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
          });
        }
        // Ocultar todas las secciones
        if (badgesSection) badgesSection.hidden = true;
        if (rewardsSection) rewardsSection.hidden = true;
        if (maintenanceSection) maintenanceSection.hidden = true;

        // Mostrar la secciÃ³n seleccionada
        switch(section) {
          case 'badges':
            if (badgesSection) badgesSection.hidden = false;
            if (badgeTypeSelect) badgeTypeSelect.value = 'vip';
            showBadgeManagement('vip'); // Mostrar VIP por defecto
            syncBadgeTabs('vip');
            break;
          case 'rewards':
            if (rewardsSection) rewardsSection.hidden = false;
            loadRewardRequests(); // Cargar solicitudes de recompensas
            break;
          case 'maintenance':
            if (maintenanceSection) maintenanceSection.hidden = false;
            // Poblar selector de compensaciÃ³n si existe la funciÃ³n
            if (typeof window.populateAdminCompensationSelector === 'function') {
               window.populateAdminCompensationSelector();
            }
            break;
        }
      }

      // FunciÃ³n para mostrar la gestiÃ³n de una insignia especÃ­fica
      function showBadgeManagement(badgeType) {
        if (vipManagement) vipManagement.hidden = true;
        if (z0VipManagement) z0VipManagement.hidden = true;
        if (donadorManagement) donadorManagement.hidden = true;
        const z0FanManagement = document.getElementById('z0-fan-management');
        const z0PlatinoManagement = document.getElementById('z0-platino-management');
        if (z0FanManagement) z0FanManagement.hidden = true;
        if (z0PlatinoManagement) z0PlatinoManagement.hidden = true;

        switch(badgeType) {
          case 'vip':
            if (vipManagement) vipManagement.hidden = false;
            break;
          case 'z0-vip':
            if (z0VipManagement) z0VipManagement.hidden = false;
            break;
          case 'donador':
            if (donadorManagement) donadorManagement.hidden = false;
            break;
          case 'z0-fan':
            if (z0FanManagement) z0FanManagement.hidden = false;
            break;
          case 'z0-platino':
            if (z0PlatinoManagement) z0PlatinoManagement.hidden = false;
            break;
        }
      }

      function syncBadgeTabs(badgeType) {
        if (!badgeTabs || !badgeTabs.length) return;
        badgeTabs.forEach((btn) => {
          const isActive = btn.getAttribute('data-badge') === badgeType;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });
      }

      userDeleteBtn?.addEventListener('click', () => {
        const name = allUsersSelect.value.trim();
        if (!name) {
          alert('Selecciona un usuario del listado.');
          return;
        }
        if (!userDeleteModal) {
          alert('No se encontrÃ³ el modal de borrado de usuario en el HTML.');
          return;
        }
        pendingUserDelete = name;
        userDeleteNameSpan.textContent = name;
        userDeleteModal.hidden = false;
      });

      userDeleteCancelBtn?.addEventListener('click', () => {
        pendingUserDelete = null;
        userDeleteModal.hidden = true;
      });

      userDeleteConfirmBtn?.addEventListener('click', async () => {
        if (!pendingUserDelete) return;
        const name = pendingUserDelete;
        try {
          await window.ensureAuth?.();
          await window.db.collection('users').doc(name.toLowerCase()).delete();
          try { await window.db.collection('vipUsers').doc(name).delete(); } catch (_) {}
          if (typeof window.renderAllUsersSelect === 'function') {
            await window.renderAllUsersSelect();
          } else {
            const opt = Array.from(allUsersSelect.options).find(o => o.value === name);
            if (opt) allUsersSelect.remove(opt.index);
          }
          allUsersSelect.value = '';
        } catch (err) {
          console.error('Error al borrar usuario:', err);
          alert('No se pudo borrar el usuario. Revisa reglas/permisos.');
        } finally {
          pendingUserDelete = null;
          userDeleteModal.hidden = true;
        }
      });

      // Abrir buscador desde el menÃº
      menuSearchOpen?.addEventListener('click', () => {
        closeMenu();
        document.getElementById('search-input')?.focus();
      });

      // === UTILIDAD PARA MOSTRAR MODAL DE MENSAJE ===
      window.showMessageModal = function(options) {
        const modal = document.getElementById('message-modal');
        const titleEl = document.getElementById('message-modal-title');
        const contentEl = document.getElementById('message-modal-content');
        const okBtn = document.getElementById('message-modal-ok');
        
        if (!modal) { alert(options.message); return; }
        
        titleEl.textContent = options.title || 'Mensaje';
        contentEl.textContent = options.message || '';
        
        // Manejar el cierre
        const close = () => {
          modal.hidden = true;
          okBtn.removeEventListener('click', close);
        };
        okBtn.addEventListener('click', close);
        
        modal.hidden = false;
      };

      // === COMPENSACIÃ“N MANUAL DE PUNTOS (Listener) ===
      document.getElementById('grant-comp-points-btn')?.addEventListener('click', async () => {
         const select = document.getElementById('comp-user-select');
         const user = (select ? select.value : '').trim();
         const points = Number(document.getElementById('comp-points-input')?.value || 0);
         const reason = (document.getElementById('comp-reason-input')?.value || '').trim() || 'Manual adjustment';
         
         if (!user) { alert('Por favor selecciona un usuario'); return; }
         // Permitir cualquier valor, incluso 0 si el admin quiere registrar una nota
         // if (points === 0) { alert('Por favor ingresa una cantidad de puntos distinta de 0'); return; }
         
         const confirmed = await showConfirmation({
            icon: 'ğŸ',
            title: 'Otorgar Puntos Manualmente',
            message: `Â¿EstÃ¡s seguro de otorgar ${points} puntos a ${user}?\nMotivo: ${reason}`,
            confirmText: 'SÃ­, Otorgar',
            cancelText: 'Cancelar'
         });
         
         if (confirmed) {
             const btn = document.getElementById('grant-comp-points-btn');
             if(btn) { btn.disabled = true; btn.textContent = 'Procesando...'; }
             try {
                const norm = String(user).toLowerCase().replace(/^@/,'');
                const docRef = db.collection('userStats').doc(norm);
                
                // Usar FieldValue.increment para operaciÃ³n atÃ³mica eficiente
                // Esto evita leer el documento antes de escribir y reduce costos/cuota
                await docRef.set({
                   totalPoints: firebase.firestore.FieldValue.increment(points),
                   lastManualAdjustment: {
                      amount: points,
                      reason: reason,
                      at: firebase.firestore.FieldValue.serverTimestamp(),
                      by: 'Admin'
                   },
                   updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                // Mostrar modal de Ã©xito personalizado
                showMessageModal({
                   title: 'âœ… Puntos Otorgados',
                   message: `Se han otorgado ${points} puntos al usuario "${user}" exitosamente.\n\nEl cambio se reflejarÃ¡ inmediatamente.`
                });
                
                showSuccessNotification(`âœ… Se otorgaron ${points} puntos a ${user}.`);
                
                // Limpiar inputs
                if(select) select.value = '';
                document.getElementById('comp-points-input').value = '';
                document.getElementById('comp-reason-input').value = '';
                
             } catch(e) {
                console.error(e);
                // Mostrar modal de error personalizado
                showMessageModal({
                   title: 'âŒ Error al otorgar puntos',
                   message: `No se pudieron otorgar los puntos.\n\nDetalle: ${e.message}\nCÃ³digo: ${e.code || 'N/A'}`
                });
             } finally {
                if(btn) { btn.disabled = false; btn.textContent = 'ğŸ Otorgar Puntos'; }
             }
         }
      });
      
      daySelect?.addEventListener('change', () => {
        const v = daySelect.value;
        if (v) {
          if (typeof window.subscribeSolicitudesForDay === 'function') {
            window.subscribeSolicitudesForDay(v);
          }
        } else {
          window.__dayItems = [];
          try { refreshStatsTicker(); } catch (_) {}
        }
        hideSearchResults();
      });

      function renderSearchResults(rows) {
        if (!searchResults) return;
        if (!rows || !rows.length) {
          searchResults.hidden = true;
          searchResults.innerHTML = '';
          return;
        }
        
        // Usar el helper createSearchResultItemHTML si estÃ¡ disponible, o definir la lÃ³gica aquÃ­
        const createItem = (typeof createSearchResultItemHTML === 'function') 
          ? createSearchResultItemHTML 
          : (it) => {
            // Fallback por si no se cargÃ³ el helper
             return `
            <div class="search-result" data-day="${it.day || ''}" tabindex="0">
              <span class="sr-song">${it.cancion}</span>
              <span class="sr-artist">${it.artista}</span>
            </div>`;
          };

        // LÃ³gica: Mostrar mÃ¡ximo 6, y botÃ³n "Ver mÃ¡s" si hay excedente
        const MAX_ITEMS = 6;
        const total = rows.length;
        const visibleRows = rows.slice(0, MAX_ITEMS);
        
        let listHtml = visibleRows.map(it => createItem(it)).join('');
        
        if (total > MAX_ITEMS) {
            listHtml += `
              <div class="search-show-more-btn" role="button" tabindex="0">
                <span>Ver mÃ¡s resultados (${total - MAX_ITEMS} mÃ¡s)...</span>
              </div>
            `;
        }
        
        searchResults.innerHTML = listHtml;
        searchResults.hidden = false;
        
        // Manejar click en "Ver mÃ¡s"
        const moreBtn = searchResults.querySelector('.search-show-more-btn');
        if (moreBtn) {
            moreBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                // Renderizar todos los resultados
                const allHtml = rows.map(it => createItem(it)).join('');
                searchResults.innerHTML = allHtml;
            });
            // Accesibilidad: permitir Enter
            moreBtn.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                moreBtn.click();
              }
            });
        }
      }

      function goToDayFromResult(el) {
        const day = el?.dataset?.day;
        if (!day) return;
        daySelect.value = day;
        try { daySelect.dispatchEvent(new Event('change')); } catch (_){}
        window.subscribeSolicitudesForDay?.(day);
        searchResults.hidden = true;
        searchResults.innerHTML = '';
        searchInput.value = '';
      }

      // Click en resultado: saltar al dÃ­a
      searchResults?.addEventListener('click', (e) => {
        const el = e.target.closest('.search-result');
        if (el) goToDayFromResult(el);
      });

      // Tecla Enter en resultado: saltar al dÃ­a
      searchResults?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const el = e.target.closest('.search-result');
          if (el) goToDayFromResult(el);
        }
      });

      let searchTimeout;
      searchInput?.addEventListener('input', async () => {
        const q = searchInput.value;
        
        // Limpiar timeout anterior
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        
        if (!q.trim()) {
          searchResults.hidden = true;
          searchResults.innerHTML = '';
          return;
        }
        
        // Mostrar indicador de carga inmediatamente
        searchResults.innerHTML = '<div class="search-loading">Buscando...</div>';
        searchResults.hidden = false;
        
        // Debounce de 300ms
        searchTimeout = setTimeout(async () => {
          try {
            const results = typeof window.searchSolicitudes === 'function' ? await window.searchSolicitudes(q) : [];
            renderSearchResults(results);
          } catch (error) {
            console.error('Error en bÃºsqueda:', error);
            searchResults.innerHTML = '<div class="search-error">Error en la bÃºsqueda</div>';
          }
        }, 300);
      });

      searchInput?.addEventListener('focus', async () => {
        const q = searchInput.value;
        if (q.trim() && typeof window.searchSolicitudes === 'function') {
          try {
            const results = await window.searchSolicitudes(q);
            renderSearchResults(results);
          } catch (error) {
            console.error('Error en bÃºsqueda:', error);
          }
        }
      });

      document.addEventListener('click', (e) => {
        if (!searchBox) return;
        const inside = searchBox.contains(e.target);
        if (!inside) {
          searchResults.hidden = true;
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          searchResults.hidden = true;
        }
      });

      // Listeners del changelog (un Ãºnico bloque)
      menuChangelogOpen?.addEventListener('click', () => {
        closeMenu();
        hideSearchResults();
        changelogModal.hidden = false;
      });

      changelogCloseBtn?.addEventListener('click', () => {
        changelogModal.hidden = true;
      });

      changelogModal?.addEventListener('click', (e) => {
        if (e.target === changelogModal) {
          changelogModal.hidden = true;
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !changelogModal.hidden) {
          changelogModal.hidden = true;
        }
      });

      // AnimaciÃ³n del placeholder del campo de bÃºsqueda
      let placeholderAnimation = null;
      
      function animatePlaceholder() {
        const searchInput = document.getElementById('search-input');
        if (!searchInput) return;

        const texts = ['Buscar canciÃ³n...', 'Buscar artista...'];
        let currentIndex = 0;
        let isDeleting = false;
        let currentText = '';
        let charIndex = 0;

        function typeEffect() {
          // Verificar si el elemento aÃºn existe y no tiene foco
          if (!searchInput || document.activeElement === searchInput) {
            return;
          }

          const fullText = texts[currentIndex];
          
          if (isDeleting) {
            currentText = fullText.substring(0, charIndex - 1);
            charIndex--;
          } else {
            currentText = fullText.substring(0, charIndex + 1);
            charIndex++;
          }

          // Actualizar el placeholder
          searchInput.placeholder = currentText;

          let typeSpeed = 100;
          if (isDeleting) {
            typeSpeed = 50;
          }

          if (!isDeleting && charIndex === fullText.length) {
            // Pausa al completar el texto
            typeSpeed = 2000;
            isDeleting = true;
          } else if (isDeleting && charIndex === 0) {
            isDeleting = false;
            currentIndex = (currentIndex + 1) % texts.length;
            typeSpeed = 500;
          }

          placeholderAnimation = setTimeout(typeEffect, typeSpeed);
        }

        // Limpiar animaciÃ³n anterior
        if (placeholderAnimation) {
          clearTimeout(placeholderAnimation);
        }

        // Iniciar la animaciÃ³n
        typeEffect();

        // Pausar animaciÃ³n cuando el usuario hace foco en el campo
        const focusHandler = () => {
          if (placeholderAnimation) {
            clearTimeout(placeholderAnimation);
            placeholderAnimation = null;
          }
          searchInput.placeholder = 'Escribe para buscar...';
        };

        // Reanudar animaciÃ³n cuando el usuario sale del campo (si estÃ¡ vacÃ­o)
        const blurHandler = () => {
          if (!searchInput.value.trim()) {
            setTimeout(() => {
              if (document.activeElement !== searchInput) {
                animatePlaceholder();
              }
            }, 1000);
          }
        };

        // Remover listeners anteriores para evitar duplicados
        searchInput.removeEventListener('focus', focusHandler);
        searchInput.removeEventListener('blur', blurHandler);
        
        // Agregar nuevos listeners
        searchInput.addEventListener('focus', focusHandler);
        searchInput.addEventListener('blur', blurHandler);
      }

      // FunciÃ³n para limpiar la animaciÃ³n del placeholder
      function cleanupPlaceholderAnimation() {
        if (placeholderAnimation) {
          clearTimeout(placeholderAnimation);
          placeholderAnimation = null;
        }
      }

      // Iniciar la animaciÃ³n despuÃ©s de un breve delay
      setTimeout(animatePlaceholder, 1000);

      // Limpiar animaciÃ³n al cambiar de pÃ¡gina
      window.addEventListener('beforeunload', cleanupPlaceholderAnimation);

      // ===== FUNCIONALIDAD DE ESTADÃSTICAS =====
      const statsModal = document.getElementById('stats-modal');
      const statsCloseBtn = document.getElementById('stats-close');
      const menuStatsOpen = document.getElementById('menu-stats-open');
      const statsTabs = document.querySelectorAll('.stats-tab');
      const statsPanels = document.querySelectorAll('.stats-panel');

      // FunciÃ³n para ocultar buscador
      function hideSearchResults() {
        const searchResults = document.getElementById('search-results');
        const searchInput = document.getElementById('search-input');
        if (searchResults) searchResults.hidden = true;
        if (searchInput) searchInput.blur();
      }

      // Abrir modal de estadÃ­sticas
      menuStatsOpen?.addEventListener('click', async () => {
        closeMenu();
        hideSearchResults();
        statsModal.hidden = false;
        await calculateStats();
      });

      // Cerrar modal de estadÃ­sticas
      statsCloseBtn?.addEventListener('click', () => {
        statsModal.hidden = true;
      });

      // Cambiar tabs de estadÃ­sticas
      statsTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const targetTab = tab.dataset.tab;
          
          // Actualizar tabs activos
          statsTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Mostrar panel correspondiente
          statsPanels.forEach(panel => {
            panel.classList.remove('active');
            if (panel.id === `stats-${targetTab}`) {
              panel.classList.add('active');
            }
          });
        });
      });

      // Calcular estadÃ­sticas
      async function calculateStats() {
        try {
          // Mostrar indicador de carga
          document.getElementById('total-songs').textContent = '...';
          document.getElementById('total-users').textContent = '...';
          document.getElementById('total-artists').textContent = '...';
          document.getElementById('today-songs').textContent = '...';
          
          // Obtener todas las solicitudes de Firestore
          const firestoreSnapshot = await db.collection('solicitudes').get();
          const firestoreSolicitudes = [];
          
          firestoreSnapshot.forEach(doc => {
            const data = doc.data();
            if (data.usuario && data.cancion && data.artista) {
              firestoreSolicitudes.push({
                usuario: data.usuario,
                cancion: data.cancion,
                artista: data.artista,
                day: data.day,
                ts: data.ts ? data.ts.toMillis() : Date.now(),
                hora: data.hora || '',
                isSimulation: data.isSimulation === true,
                isTest: data.isTest === true,
                source: data.source || ''
              });
            }
          });
          
          // Obtener solicitudes de localStorage como respaldo
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          // Combinar datos de Firestore y localStorage, evitando duplicados
          const allSolicitudesMap = new Map();
          
          // Agregar solicitudes de Firestore
          firestoreSolicitudes.forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.ts}`;
            allSolicitudesMap.set(key, s);
          });
          
          // Agregar solicitudes de localStorage que no estÃ©n en Firestore
          localSolicitudes.forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.time}`;
            if (!allSolicitudesMap.has(key)) {
              allSolicitudesMap.set(key, {
                usuario: s.usuario,
                cancion: s.cancion,
                artista: s.artista,
                ts: s.time,
                hora: s.hora || '',
                isSimulation: s.isSimulation === true,
                isTest: s.isTest === true,
                source: s.source || ''
              });
            }
          });
          
          // Agregar solicitudes de byDay que no estÃ©n incluidas
          Object.values(byDay).flat().forEach(s => {
            const key = `${s.usuario}-${s.cancion}-${s.artista}-${s.time}`;
            if (!allSolicitudesMap.has(key)) {
              allSolicitudesMap.set(key, {
                usuario: s.usuario,
                cancion: s.cancion,
                artista: s.artista,
                ts: s.time,
                hora: s.hora || '',
                isSimulation: s.isSimulation === true,
                isTest: s.isTest === true,
                source: s.source || ''
              });
            }
          });
          
          const allSolicitudesRaw = Array.from(allSolicitudesMap.values());
          const allSolicitudes = allSolicitudesRaw.filter(s => !isTestRequestForStats(s));
          
          // EstadÃ­sticas generales
          const totalSongs = allSolicitudes.length;
          const uniqueUsers = new Set(allSolicitudes.map(s => s.usuario)).size;
          const uniqueArtists = new Set(allSolicitudes.map(s => s.artista)).size;
          
          // Canciones de hoy
          const today = new Date();
          const todayKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
          const todaySongs = allSolicitudes.filter(s => {
            const date = new Date(s.ts);
            const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
            return dateKey === todayKey;
          }).length;
          
          // Actualizar nÃºmeros generales
          document.getElementById('total-songs').textContent = totalSongs;
          document.getElementById('total-users').textContent = uniqueUsers;
          document.getElementById('total-artists').textContent = uniqueArtists;
          document.getElementById('today-songs').textContent = todaySongs;
          
          // Top canciones
          const songCounts = {};
          allSolicitudes.forEach(s => {
            const key = `${s.cancion} - ${s.artista}`;
            songCounts[key] = (songCounts[key] || 0) + 1;
          });
          
          const topSongs = Object.entries(songCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10);
          
          renderStatsList('top-songs-list', topSongs);
          
          // Top artistas
          const artistCounts = {};
          allSolicitudes.forEach(s => {
            artistCounts[s.artista] = (artistCounts[s.artista] || 0) + 1;
          });
          
          const topArtists = Object.entries(artistCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10);
          
          renderStatsList('top-artists-list', topArtists);
          
          // Top usuarios
          const userCounts = {};
          allSolicitudes.forEach(s => {
            userCounts[s.usuario] = (userCounts[s.usuario] || 0) + 1;
          });
          
          const topUsers = Object.entries(userCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10);
          
          renderStatsList('top-users-list', topUsers);
          
        } catch (error) {
          console.error('Error calculando estadÃ­sticas:', error);
          
          // Fallback a datos locales en caso de error
          const allSolicitudesRaw = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          const allSolicitudes = (Array.isArray(allSolicitudesRaw) ? allSolicitudesRaw : []).filter(s => !isTestRequestForStats(s));
          
          const totalSongs = allSolicitudes.length;
          const uniqueUsers = new Set(allSolicitudes.map(s => s.usuario)).size;
          const uniqueArtists = new Set(allSolicitudes.map(s => s.artista)).size;
          
          const today = new Date();
          const todayKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
          const todaySongs = (byDay[todayKey] || []).length;
          
          document.getElementById('total-songs').textContent = totalSongs + ' (local)';
          document.getElementById('total-users').textContent = uniqueUsers + ' (local)';
          document.getElementById('total-artists').textContent = uniqueArtists + ' (local)';
          document.getElementById('today-songs').textContent = todaySongs + ' (local)';
          
          // Mostrar mensaje de error en las listas
          ['top-songs-list', 'top-artists-list', 'top-users-list'].forEach(id => {
            const container = document.getElementById(id);
            if (container) {
              container.innerHTML = '<div class="stats-item">Error cargando datos. Mostrando datos locales.</div>';
            }
          });
        }
      }

      function renderStatsList(containerId, items) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        if (items.length === 0) {
          container.innerHTML = '<div class="stats-item">No hay datos disponibles</div>';
          return;
        }
        
        container.innerHTML = items.map(([name, count], index) => `
          <div class="stats-item">
            <span class="stats-item-name">${index + 1}. ${name}</span>
            <span class="stats-item-count">${count}</span>
          </div>
        `).join('');
      }

      // ===== FUNCIONALIDAD DE TEMAS =====
      const themeModal = document.getElementById('theme-modal');
      const themeBtn = document.getElementById('theme-btn');
      const themeCloseBtn = document.getElementById('theme-close');
      const themeCloseBtnX = themeModal?.querySelector('.modal-close-btn');
      const themeResetBtn = document.getElementById('theme-reset');
      const themeOptions = document.querySelectorAll('.theme-option');
      const themeColors = document.querySelectorAll('.theme-color');
      const themeTransparency = document.getElementById('theme-transparency');
      const themeParticles = document.getElementById('theme-particles');
      const themeShapes = document.querySelectorAll('.theme-shape');

      // Migrar datos de tema de claves antiguas a nuevas (solo una vez)
      (function migrateThemeData() {
        const oldTheme = localStorage.getItem('app-theme');
        const oldColor = localStorage.getItem('app-color');
        
        if (oldTheme && !localStorage.getItem('selectedTheme')) {
          localStorage.setItem('selectedTheme', oldTheme);
          localStorage.removeItem('app-theme');
        }
        
        if (oldColor && !localStorage.getItem('selectedColor')) {
          localStorage.setItem('selectedColor', oldColor);
          localStorage.removeItem('app-color');
        }
      })();

      // FunciÃ³n para aplicar tema (sincronizada)
      function applyTheme() {
        const savedTheme = localStorage.getItem('selectedTheme') || 'light';
        const savedColor = localStorage.getItem('selectedColor') || 'default';
        const savedTransparency = parseInt(localStorage.getItem('themeTransparency') || '0');
        
        // Limpiar clases anteriores
        document.body.classList.remove('dark-theme');
        document.body.classList.remove('theme-blue', 'theme-green', 'theme-purple', 'theme-red', 'theme-pink', 'theme-magenta', 'theme-cyan', 'theme-orange');
        document.documentElement.removeAttribute('data-theme');
        
        // Aplicar tema
        if (savedTheme === 'dark') {
          document.body.classList.add('dark-theme');
          document.documentElement.setAttribute('data-theme', 'dark');
        }
        
        // Aplicar color de acento
        if (savedColor !== 'default') {
          document.body.classList.add(`theme-${savedColor}`);
        }

        // Aplicar transparencia
        // Base alpha: Light 0.96, Dark 0.88
        // Min alpha (max transparency): 0.4
        const isDark = savedTheme === 'dark';
        const baseAlpha = isDark ? 0.88 : 0.96;
        const minAlpha = 0.2; // Permitir mÃ¡s transparencia (antes 0.4)
        
        // 0% slider = baseAlpha, 100% slider = minAlpha
        const currentAlpha = baseAlpha - (savedTransparency / 100) * (baseAlpha - minAlpha);
        document.documentElement.style.setProperty('--card-bg-alpha', currentAlpha);
      }

      // Actualizar estados activos del modal
      function updateActiveStates() {
        const savedTheme = localStorage.getItem('selectedTheme') || 'light';
        const savedColor = localStorage.getItem('selectedColor') || 'default';
        const savedShape = localStorage.getItem('selectedShape') || 'orb';
        const savedTransparency = localStorage.getItem('themeTransparency') || '0';
        const savedParticles = localStorage.getItem('particleCount') || '800';
        
        themeOptions.forEach(option => {
          option.classList.toggle('active', option.dataset.theme === savedTheme);
        });
        themeColors.forEach(color => {
          color.classList.toggle('active', color.dataset.color === savedColor);
        });
        themeShapes.forEach(shape => {
          shape.classList.toggle('active', shape.dataset.shape === savedShape);
        });
        
        if (themeTransparency) {
          themeTransparency.value = savedTransparency;
        }

        if (themeParticles) {
          themeParticles.value = savedParticles;
        }
      }

      // Cargar tema guardado
      function loadSavedTheme() {
        applyTheme();
        updateActiveStates();
      }
      
      // Escuchar cambios en localStorage desde otras pÃ¡ginas
      window.addEventListener('storage', function(e) {
        if (e.key === 'selectedTheme' || e.key === 'selectedColor' || e.key === 'themeTransparency' || e.key === 'selectedShape') {
          applyTheme();
          updateActiveStates();
          
          if (e.key === 'selectedShape') {
            window.dispatchEvent(new CustomEvent('shapeChanged', { detail: { shape: e.newValue } }));
          }
        }
      });

      // Abrir modal de temas
      (function setupThemeBtnDraggable() {
        if (!themeBtn) return;
        const storageKey = `widget_btn_pos:${location.pathname}:theme-btn`;
        let isDragging = false;
        let hasMoved = false;
        let startX = 0;
        let startY = 0;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        try {
          const saved = localStorage.getItem(storageKey);
          if (saved) {
            const pos = JSON.parse(saved);
            if (pos && typeof pos.left === 'number' && typeof pos.top === 'number') {
              themeBtn.style.position = 'fixed';
              themeBtn.style.left = `${pos.left}px`;
              themeBtn.style.top = `${pos.top}px`;
              themeBtn.style.marginLeft = '0';
              themeBtn.style.zIndex = '10000';
              themeBtn.style.cursor = 'grab';
            }
          }
        } catch (_) {}

        themeBtn.addEventListener('mousedown', (e) => {
          isDragging = true;
          hasMoved = false;
          startX = e.clientX;
          startY = e.clientY;
          const rect = themeBtn.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          themeBtn.style.cursor = 'grabbing';
          themeBtn.style.transition = 'none';
        });

        window.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          if (Math.abs(dx) > 3 || Math.abs(dy) > 3) hasMoved = true;

          const left = e.clientX - dragOffsetX;
          const top = e.clientY - dragOffsetY;

          themeBtn.style.position = 'fixed';
          themeBtn.style.left = `${left}px`;
          themeBtn.style.top = `${top}px`;
          themeBtn.style.marginLeft = '0';
          themeBtn.style.zIndex = '10000';
        });

        window.addEventListener('mouseup', () => {
          if (!isDragging) return;
          isDragging = false;
          themeBtn.style.cursor = 'grab';
          themeBtn.style.transition = '';

          if (hasMoved) {
            const rect = themeBtn.getBoundingClientRect();
            const left = Math.max(0, Math.min(rect.left, window.innerWidth - rect.width));
            const top = Math.max(0, Math.min(rect.top, window.innerHeight - rect.height));
            themeBtn.style.left = `${left}px`;
            themeBtn.style.top = `${top}px`;
            try {
              localStorage.setItem(storageKey, JSON.stringify({ left, top }));
            } catch (_) {}
          }
        });

        themeBtn.addEventListener('click', (e) => {
          if (hasMoved) return;
          hideSearchResults();
          themeModal.hidden = false;
          updateActiveStates();
          e.stopPropagation();
        });
      })();

      // LÃ³gica de AcordeÃ³n para el modal de temas
      const accordionHeaders = themeModal?.querySelectorAll('.accordion-header');
      accordionHeaders?.forEach(header => {
        header.addEventListener('click', () => {
          const item = header.parentElement;
          const isActive = item.classList.contains('active');

          // Cerrar otros items
          themeModal.querySelectorAll('.accordion-item').forEach(otherItem => {
            if (otherItem !== item) {
              otherItem.classList.remove('active');
            }
          });

          // Alternar item actual
          if (!isActive) {
            item.classList.add('active');
          } else {
            item.classList.remove('active');
          }
        });
      });

      // Cerrar modal de temas
      function closeThemeModal() {
        themeModal.hidden = true;
      }

      themeCloseBtn?.addEventListener('click', closeThemeModal);
      themeCloseBtnX?.addEventListener('click', closeThemeModal);
      
      // Cerrar modal al hacer clic fuera
      themeModal?.addEventListener('click', function(e) {
        if (e.target === themeModal) closeThemeModal();
      });

      // Cambiar tema (claro/oscuro)
      themeOptions.forEach(option => {
        option.addEventListener('click', () => {
          const theme = option.dataset.theme;
          
          // Guardar preferencia
          localStorage.setItem('selectedTheme', theme);
          
          // Aplicar tema
          applyTheme();
          updateActiveStates();
          
          // Disparar evento personalizado para sincronizaciÃ³n
          window.dispatchEvent(new CustomEvent('themeChanged', { 
            detail: { 
              theme, 
              color: localStorage.getItem('selectedColor') || 'default',
              transparency: localStorage.getItem('themeTransparency') || '0'
            }
          }));
        });
      });

      // Cambiar color de acento
      themeColors.forEach(color => {
        color.addEventListener('click', () => {
          const colorName = color.dataset.color;
          
          // Guardar preferencia
          localStorage.setItem('selectedColor', colorName);
          
          // Aplicar tema
          applyTheme();
          updateActiveStates();
          
          // Disparar evento personalizado para sincronizaciÃ³n
          window.dispatchEvent(new CustomEvent('themeChanged', { 
            detail: { 
              theme: localStorage.getItem('selectedTheme') || 'light', 
              color: colorName,
              transparency: localStorage.getItem('themeTransparency') || '0'
            }
          }));
        });
      });
      
      // Cambiar forma del fondo
      themeShapes.forEach(shape => {
        shape.addEventListener('click', () => {
          const shapeName = shape.dataset.shape;
          
          // Guardar preferencia
          localStorage.setItem('selectedShape', shapeName);
          
          // Actualizar UI
          updateActiveStates();
          
          // Disparar evento para el canvas
          window.dispatchEvent(new CustomEvent('shapeChanged', { 
            detail: { shape: shapeName } 
          }));
        });
      });

      // Cambiar cantidad de partÃ­culas
      themeParticles?.addEventListener('input', function() {
        const count = this.value;
        localStorage.setItem('particleCount', count);
        
        // Redibujar partÃ­culas usando la funciÃ³n expuesta
        if (typeof window.updateParticleSystem === 'function') {
           window.updateParticleSystem();
        }
      });
      
      // Control de transparencia
      themeTransparency?.addEventListener('input', (e) => {
        const val = e.target.value;
        localStorage.setItem('themeTransparency', val);
        applyTheme();
        
        window.dispatchEvent(new CustomEvent('themeChanged', { 
          detail: { 
            theme: localStorage.getItem('selectedTheme') || 'light', 
            color: localStorage.getItem('selectedColor') || 'default',
            transparency: val
          }
        }));
      });

      // InteracciÃ³n visual durante ajuste de transparencia
      const startTransparencyInteraction = () => {
        themeModal.classList.add('interacting-transparency');
      };
      
      const endTransparencyInteraction = () => {
        themeModal.classList.remove('interacting-transparency');
      };

      themeTransparency?.addEventListener('mousedown', startTransparencyInteraction);
      themeTransparency?.addEventListener('touchstart', startTransparencyInteraction);
      
      themeTransparency?.addEventListener('mouseup', endTransparencyInteraction);
      themeTransparency?.addEventListener('touchend', endTransparencyInteraction);
      themeTransparency?.addEventListener('mouseleave', endTransparencyInteraction);

      themeParticles?.addEventListener('mousedown', startTransparencyInteraction);
      themeParticles?.addEventListener('touchstart', startTransparencyInteraction);
      
      themeParticles?.addEventListener('mouseup', endTransparencyInteraction);
      themeParticles?.addEventListener('touchend', endTransparencyInteraction);
      themeParticles?.addEventListener('mouseleave', endTransparencyInteraction);

      // Restablecer tema
      themeResetBtn?.addEventListener('click', () => {
        localStorage.removeItem('selectedTheme');
        localStorage.removeItem('selectedColor');
        localStorage.removeItem('themeTransparency');
        localStorage.removeItem('selectedShape');
        
        applyTheme();
        updateActiveStates();
        
        // Actualizar botones
        themeOptions.forEach(option => {
          option.classList.toggle('active', option.dataset.theme === 'light');
        });
        themeColors.forEach(color => {
          color.classList.toggle('active', color.dataset.color === 'default');
        });
        themeShapes.forEach(shape => {
          shape.classList.toggle('active', shape.dataset.shape === 'orb');
        });
        
        // Resetear forma
        window.dispatchEvent(new CustomEvent('shapeChanged', { 
          detail: { shape: 'orb' } 
        }));
      });

      // Cerrar modales con Escape o click fuera
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (!statsModal.hidden) statsModal.hidden = true;
          if (!themeModal.hidden) themeModal.hidden = true;
        }
      });

      // ===== SISTEMA DE GAMIFICACIÃ“N =====
      const gamificationModal = document.getElementById('gamification-modal');
      const gamificationOpenBtn = document.getElementById('menu-gamification-open');
      const gamificationCloseBtn = document.getElementById('gamification-close');

      // ===== SISTEMA DE CANJE DE PUNTOS =====
      const rewardsModal = document.getElementById('rewards-modal');
      const rewardsOpenBtn = document.getElementById('menu-rewards-open');
      const rewardsCloseBtn = document.getElementById('rewards-close-x');
      const rewardsUserSelect = document.getElementById('rewards-user-select');
      const rewardsUserInfo = document.getElementById('rewards-user-info');
      const rewardsUserPoints = document.getElementById('rewards-user-points');
      async function updateRewardsPoints(u){
        try {
          const bd = await computeUserBreakdown(u);
          if (rewardsUserPoints) rewardsUserPoints.textContent = String(bd.total || 0);
          if (rewardsUserInfo) rewardsUserInfo.textContent = u || 'Selecciona un usuario';
        } catch (_) {
          if (rewardsUserPoints) rewardsUserPoints.textContent = '0';
        }
      }
      rewardsOpenBtn?.addEventListener('click', async () => {
        const u = typeof getCurrentSelectedUser === 'function' ? getCurrentSelectedUser() : getCurrentUser();
        await updateRewardsPoints(u);
        rewardsModal.hidden = false;
        renderPointsBreakdownExplanation();
      });
      rewardsUserSelect?.addEventListener('change', async () => {
        const u = rewardsUserSelect.value || (typeof getCurrentSelectedUser === 'function' ? getCurrentSelectedUser() : getCurrentUser());
        await updateRewardsPoints(u);
      });
      rewardsOpenBtn?.addEventListener('click', async () => {
        try {
          const u = typeof getCurrentSelectedUser === 'function' ? getCurrentSelectedUser() : getCurrentUser();
          const data = getGamificationDataForUser(u) || {};
          await renderPersonalStatsForUser(data, u);
          rewardsModal.hidden = false;
          renderPointsBreakdownExplanation();
        } catch (_){
          rewardsModal.hidden = false;
        }
      });
      document.addEventListener('click', (e) => {
        const btn = e.target && e.target.closest('.points-tab');
        if (!btn) return;
        const tab = btn.getAttribute('data-tab') || 'redeem';
        const panels = document.querySelectorAll('.points-panel');
        panels.forEach(p => p.classList.remove('active'));
        document.getElementById('points-' + tab)?.classList.add('active');
        const tabs = document.querySelectorAll('.points-tab');
        tabs.forEach(t => t.classList.remove('active'));
        btn.classList.add('active');
        if (tab === 'breakdown') {
          renderPointsBreakdownExplanation();
        }
      });
      function renderPointsBreakdownExplanation() {
        const el = document.getElementById('points-breakdown-content');
        if (!el) return;
        const mult = (POINTS_CONFIG && typeof POINTS_CONFIG.STREAK_MULTIPLIER === 'number') ? POINTS_CONFIG.STREAK_MULTIPLIER : 2;
        el.innerHTML = [
          '<h3>ğŸ“‹ CÃ³mo ganas puntos</h3>',
          '<p>Tu total se calcula sumando cada componente. AquÃ­ tienes el detalle:</p>',
          '<div class="points-grid">',
            '<div class="points-card">',
              '<div class="points-title">ğŸµ Canciones reproducidas Ã— 25</div>',
              '<div class="points-desc">+25 por cada canciÃ³n marcada como reproducida. Ejemplo: 100 canciones = 2500 puntos.</div>',
            '</div>',
            '<div class="points-card">',
              '<div class="points-title">ğŸ‘‘ Bono VIP Ã— 40</div>',
              '<div class="points-desc">+40 adicionales por canciÃ³n si eres VIP. Ejemplo: 100 canciones = 4000 puntos extra.</div>',
            '</div>',
            '<div class="points-card">',
              '<div class="points-title">ğŸ“… Bono diario Ã— 5</div>',
              '<div class="points-desc">+5 por cada dÃ­a con actividad vÃ¡lida (al menos 1 canciÃ³n y â‰¥2 usuarios ese dÃ­a).</div>',
            '</div>',
            '<div class="points-card">',
              '<div class="points-title">ğŸ… Logros</div>',
              '<div class="points-desc">Al desbloquear insignias sumas sus puntos. Ejemplo: Insignia â€œMaestroâ€ +400.</div>',
            '</div>',
            '<div class="points-card">',
              '<div class="points-title">ğŸ”¥ Rachas</div>',
              '<div class="points-desc">Por secuencias de dÃ­as consecutivos. FÃ³rmula escalonada con multiplicador Ã—' + mult + ' y mÃ¡ximo 10 pasos.</div>',
            '</div>',
          '</div>',
          '<p class="points-formula">Tu total = (Canciones Ã— 25) + (VIP Ã— 40) + (DÃ­as Ã— 5) + Logros + Rachas.</p>'
        ].join('');
      }

      // ===== SISTEMA DE MODAL DE CONFIRMACIÃ“N =====
      const confirmationModal = document.getElementById('confirmation-modal');
      const confirmationCloseBtn = document.getElementById('confirmation-close-x');
      const confirmationCancelBtn = document.getElementById('confirmation-cancel');
      const confirmationConfirmBtn = document.getElementById('confirmation-confirm');
      const confirmationIcon = document.getElementById('confirmation-icon');
      const confirmationTitle = document.getElementById('confirmation-title');
      const confirmationMessage = document.getElementById('confirmation-message');

      // ===== SISTEMA DE ADMINISTRACIÃ“N DE RECOMPENSAS (INTEGRADO EN PANEL ADMIN) =====
      const adminStatusFilter = document.getElementById('admin-rewards-status-filter');
      const adminUserFilter = document.getElementById('admin-rewards-user-filter');
      const refreshRequestsBtn = document.getElementById('admin-refresh-rewards');
      const adminRequestsList = document.getElementById('admin-rewards-list');
      const totalPendingRequests = document.getElementById('admin-total-pending');
      const totalApprovedRequests = document.getElementById('admin-total-approved');
      const totalRejectedRequests = document.getElementById('admin-total-rejected');
      
      console.log('ğŸ”§ Inicializando sistema de recompensas...');
      console.log('Modal:', rewardsModal ? 'âœ…' : 'âŒ');
      console.log('BotÃ³n abrir:', rewardsOpenBtn ? 'âœ…' : 'âŒ');
      console.log('BotÃ³n cerrar:', rewardsCloseBtn ? 'âœ…' : 'âŒ');

      // ConfiguraciÃ³n del sistema de puntos
      const POINTS_CONFIG = {
        SONG_REQUEST: 25,
        DAILY_BONUS: 5,
        STREAK_MULTIPLIER: 2,
        VIP_BONUS: 40
      };

      // ConfiguraciÃ³n de niveles
      const LEVELS = [
        { level: 1, name: 'Novato', xpRequired: 0 },
        { level: 2, name: 'Aficionado', xpRequired: 100 },
        { level: 3, name: 'MelÃ³mano', xpRequired: 250 },
        { level: 4, name: 'Experto', xpRequired: 500 },
        { level: 5, name: 'Maestro', xpRequired: 1000 },
        { level: 6, name: 'Virtuoso', xpRequired: 2000 },
        { level: 7, name: 'Leyenda', xpRequired: 5000 }
      ];

      // ConfiguraciÃ³n de recompensas
      const REWARDS = [
        {
          id: 'next',
          name: 'NEXT',
          description: 'Tu canciÃ³n serÃ¡ la siguiente en reproducirse',
          cost: 690,
          icon: 'â­ï¸'
        },
        {
          id: 'two_songs',
          name: '2 CANCIONES',
          description: 'Pide dos canciones que se reproducirÃ¡n seguidas',
          cost: 1200,
          icon: 'ğŸµ'
        },
        {
          id: 'next_v2',
          name: 'NEXT V2',
          description: 'Interrumpe la canciÃ³n actual y reproduce la tuya',
          cost: 1000,
          icon: 'âš¡'
        },
        {
          id: 'vip_day',
          name: 'VIP POR 1 DÃA',
          description: 'ObtÃ©n beneficios VIP por 24 horas',
          cost: 1500,
          icon: 'ğŸ‘‘'
        },
        {
          id: 'become_fan',
          name: 'CONVIÃ‰RTETE EN VIP',
          description: 'ObtÃ©n el estado VIP permanente',
          cost: 21000,
          icon: 'ğŸ‘‘'
        },
        {
          id: 'weekly_priority',
          name: 'PRIORIDAD SEMANAL',
          description: 'Tus canciones tendrÃ¡n prioridad por una semana (1 canciÃ³n)',
          cost: 6000,
          icon: 'ğŸŒŸ'
        },
        {
          id: 'custom_badge',
          name: 'INSIGNIA PERSONALIZADA',
          description: 'Crea una insignia personalizada para tu perfil',
          cost: 12000,
          icon: 'ğŸ†'
        }
      ];

      // ConfiguraciÃ³n de logros
      const ACHIEVEMENTS = [
        {
          id: 'first_song',
          title: 'Primera CanciÃ³n',
          description: 'Pide tu primera canciÃ³n',
          icon: 'ğŸµ',
          points: 25,
          condition: (stats) => (stats.totalPlayedSongs || 0) >= 1
        },
        {
          id: 'music_lover',
          title: 'Amante de la MÃºsica',
          description: 'Pide 10 canciones',
          icon: 'ğŸ¶',
          points: 50,
          condition: (stats) => (stats.totalPlayedSongs || 0) >= 10
        },
        {
          id: 'music_addict',
          title: 'Adicto a la MÃºsica',
          description: 'Pide 50 canciones',
          icon: 'ğŸ¸',
          points: 100,
          condition: (stats) => (stats.totalPlayedSongs || 0) >= 50
        },
        {
          id: 'music_master',
          title: 'Maestro Musical',
          description: 'Pide 100 canciones',
          icon: 'ğŸ¹',
          points: 200,
          condition: (stats) => (stats.totalPlayedSongs || 0) >= 100
        },
        // ProgresiÃ³n por canciones nuevas
        {
          id: 'music_pro_200',
          title: 'Pro de la MÃºsica',
          description: 'Pide 200 canciones',
          icon: 'ğŸ§',
          points: 250,
          condition: (stats) => (stats.totalPlayedSongs || 0) >= 200
        },
        {
          id: 'music_elite_500',
          title: 'Ã‰lite Musical',
          description: 'Pide 500 canciones',
          icon: 'ğŸ…',
          points: 800,
          condition: (stats) => (stats.totalPlayedSongs || 0) >= 500
        },
        {
          id: 'music_legend_1000',
          title: 'Leyenda Musical',
          description: 'Pide 1000 canciones',
          icon: 'ğŸ‘‘',
          points: 2000,
          condition: (stats) => (stats.totalPlayedSongs || 0) >= 1000
        },
        // Variedad de artistas existentes y nuevas
        {
          id: 'diverse_taste',
          title: 'Gusto Diverso',
          description: 'Pide canciones de 10 artistas diferentes',
          icon: 'ğŸŒŸ',
          points: 75,
          condition: (stats) => (stats.uniqueArtistsPlayed || 0) >= 10
        },
        {
          id: 'explorer',
          title: 'Explorador Musical',
          description: 'Pide canciones de 25 artistas diferentes',
          icon: 'ğŸ—ºï¸',
          points: 150,
          condition: (stats) => (stats.uniqueArtistsPlayed || 0) >= 25
        },
        {
          id: 'varied_tastes_30',
          title: 'Gustos Variados',
          description: 'Pide canciones de 30 artistas diferentes',
          icon: 'ğŸŒˆ',
          points: 300,
          condition: (stats) => (stats.uniqueArtistsPlayed || 0) >= 30
        },
        {
          id: 'diverse_50',
          title: 'Curador Musical',
          description: 'Pide canciones de 50 artistas diferentes',
          icon: 'ğŸ§©',
          points: 500,
          condition: (stats) => (stats.uniqueArtistsPlayed || 0) >= 50
        },
        {
          id: 'diverse_100',
          title: 'Enciclopedia Musical',
          description: 'Pide canciones de 100 artistas diferentes',
          icon: 'ğŸ“š',
          points: 1500,
          condition: (stats) => (stats.uniqueArtistsPlayed || 0) >= 100
        },
        // Rachas existentes y nuevas
        {
          id: 'streak_starter',
          title: 'Inicio de Racha',
          description: 'MantÃ©n una racha de 3 dÃ­as',
          icon: 'ğŸ”¥',
          points: 50,
          condition: (stats) => stats.bestStreak >= 3
        },
        {
          id: 'streak_master',
          title: 'Maestro de Rachas',
          description: 'MantÃ©n una racha de 7 dÃ­as',
          icon: 'ğŸ†',
          points: 100,
          condition: (stats) => stats.bestStreak >= 7
        },
        {
          id: 'streak_legend',
          title: 'Leyenda de Rachas',
          description: 'MantÃ©n una racha de 30 dÃ­as',
          icon: 'ğŸ‘‘',
          points: 300,
          condition: (stats) => stats.bestStreak >= 30
        },
        {
          id: 'streak_14',
          title: 'Racha 14',
          description: 'MantÃ©n una racha de 14 dÃ­as',
          icon: 'ğŸ”¥',
          points: 300,
          condition: (stats) => (stats.bestStreak || 0) >= 14
        },
        {
          id: 'streak_30',
          title: 'Racha 30',
          description: 'MantÃ©n una racha de 30 dÃ­as',
          icon: 'ğŸ†',
          points: 800,
          condition: (stats) => (stats.bestStreak || 0) >= 30
        },
        {
          id: 'streak_60',
          title: 'Racha 60',
          description: 'MantÃ©n una racha de 60 dÃ­as',
          icon: 'ğŸŒŸ',
          points: 2000,
          condition: (stats) => (stats.bestStreak || 0) >= 60
        },
        // DÃ­as activos existentes y nuevos
        {
          id: 'daily_user',
          title: 'Usuario Diario',
          description: 'Usa la app durante 10 dÃ­as diferentes',
          icon: 'ğŸ“…',
          points: 100,
          condition: (stats) => stats.activeDays >= 10
        },
        {
          id: 'daily_25',
          title: 'Constante',
          description: 'Usa la app 25 dÃ­as distintos',
          icon: 'ğŸ“†',
          points: 250,
          condition: (stats) => (stats.activeDays || 0) >= 25
        },
        {
          id: 'daily_50',
          title: 'Persistente',
          description: 'Usa la app 50 dÃ­as distintos',
          icon: 'ğŸ—“ï¸',
          points: 600,
          condition: (stats) => (stats.activeDays || 0) >= 50
        },
        {
          id: 'daily_100',
          title: 'Inquebrantable',
          description: 'Usa la app 100 dÃ­as distintos',
          icon: 'ğŸ“…',
          points: 1500,
          condition: (stats) => (stats.activeDays || 0) >= 100
        },
        // Insignias existentes
        {
          id: 'vip_member',
          title: 'Miembro VIP',
          description: 'ConviÃ©rtete en usuario VIP',
          icon: 'ğŸ‘‘',
          points: 1200,
          condition: (stats) => stats.isVip
        },
        {
          id: 'z0_vip_member',
          title: 'Z0-VIP Exclusivo',
          description: 'ObtÃ©n el estatus Z0-VIP especial',
          icon: 'ğŸ’œ',
          points: 1500,
          condition: (stats) => stats.isZ0Vip
        },
        {
          id: 'donador_member',
          title: 'Donador Generoso',
          description: 'Apoya la plataforma como donador',
          icon: 'ğŸ’',
          points: 250,
          condition: (stats) => stats.isDonador
        },
        // Mismo artista existentes y nuevos
        {
          id: 'same_artist_5',
          title: 'Fan Fiel',
          description: 'Pide 5 canciones del mismo artista',
          icon: 'ğŸ“€',
          points: 100,
          condition: (stats) => (stats.topArtistCountPlayed || 0) >= 5
        },
        {
          id: 'same_artist_10',
          title: 'Fan Devoto',
          description: 'Pide 10 canciones del mismo artista',
          icon: 'ğŸ’¿',
          points: 250,
          condition: (stats) => (stats.topArtistCountPlayed || 0) >= 10
        },
        {
          id: 'same_artist_20',
          title: 'Fan AcÃ©rrimo',
          description: 'Pide 20 canciones del mismo artista',
          icon: 'ğŸ’¿',
          points: 600,
          condition: (stats) => (stats.topArtistCountPlayed || 0) >= 20
        },
        {
          id: 'same_artist_50',
          title: 'Fan HistÃ³rico',
          description: 'Pide 50 canciones del mismo artista',
          icon: 'ğŸ›ï¸',
          points: 2000,
          condition: (stats) => (stats.topArtistCountPlayed || 0) >= 50
        },
        // Ser el primero en pedir
        {
          id: 'first_request_1',
          title: 'Primero en la fila',
          description: 'SÃ© el primero en pedir 1 vez',
          icon: 'â°',
          points: 50,
          condition: (stats) => (stats.firstRequests || 0) >= 1
        },
        {
          id: 'first_request_3',
          title: 'RÃ¡pido y Furioso',
          description: 'SÃ© el primero en pedir 3 veces',
          icon: 'âš¡',
          points: 150,
          condition: (stats) => (stats.firstRequests || 0) >= 3
        },
        {
          id: 'first_request_6',
          title: 'Sprint',
          description: 'SÃ© el primero en pedir 6 veces',
          icon: 'ğŸƒ',
          points: 300,
          condition: (stats) => (stats.firstRequests || 0) >= 6
        },
        {
          id: 'first_request_9',
          title: 'Velocista',
          description: 'SÃ© el primero en pedir 9 veces',
          icon: 'ğŸš€',
          points: 500,
          condition: (stats) => (stats.firstRequests || 0) >= 9
        },
        {
          id: 'first_request_12',
          title: 'Marcapasos',
          description: 'SÃ© el primero en pedir 12 veces',
          icon: 'ğŸ',
          points: 800,
          condition: (stats) => (stats.firstRequests || 0) >= 12
        },
        {
          id: 'first_request_15',
          title: 'Siempre Primero',
          description: 'SÃ© el primero en pedir 15 veces',
          icon: 'ğŸ¥‡',
          points: 1200,
          condition: (stats) => (stats.firstRequests || 0) >= 15
        },
        {
          id: 'first_request_18',
          title: 'Reflejos de Acero',
          description: 'SÃ© el primero en pedir 18 veces',
          icon: 'ğŸ›¡ï¸',
          points: 1600,
          condition: (stats) => (stats.firstRequests || 0) >= 18
        },
        {
          id: 'first_request_21',
          title: 'Imbatible',
          description: 'SÃ© el primero en pedir 21 veces',
          icon: 'ğŸ†',
          points: 2000,
          condition: (stats) => (stats.firstRequests || 0) >= 21
        },
        {
          id: 'zerofm_listener_1',
          title: 'Zero FM: Primer Pedido',
          description: 'Pide una canciÃ³n de Zero FM.',
          icon: 'ğŸ§',
          points: 100,
          condition: (stats) => (stats.zeroFMSongsPlayed || 0) >= 1
        },
        {
          id: 'zerofm_listener_3',
          title: 'Zero FM: Nivel 3',
          description: 'Pide 3 canciones de Zero FM.',
          icon: 'ğŸ§',
          points: 300,
          condition: (stats) => (stats.zeroFMSongsPlayed || 0) >= 3
        },
        {
          id: 'zerofm_listener_6',
          title: 'Zero FM: Nivel 6',
          description: 'Pide 6 canciones de Zero FM.',
          icon: 'ğŸ§',
          points: 600,
          condition: (stats) => (stats.zeroFMSongsPlayed || 0) >= 6
        },
        {
          id: 'zerofm_listener_9',
          title: 'Zero FM: Nivel 9',
          description: 'Pide 9 canciones de Zero FM.',
          icon: 'ğŸ§',
          points: 1200,
          condition: (stats) => (stats.zeroFMSongsPlayed || 0) >= 9
        },
        {
          id: 'zerofm_listener_12',
          title: 'Zero FM: Nivel 12',
          description: 'Pide 12 canciones de Zero FM.',
          icon: 'ğŸ§',
          points: 3693,
          condition: (stats) => (stats.zeroFMSongsPlayed || 0) >= 12
        }
      ];

      // === MODO INMERSIVO ELIMINADO ===
      const immersiveToggle = document.getElementById('immersive-toggle');
      if (immersiveToggle) {
         // Eliminar listeners o elementos residuales si existen
         immersiveToggle.parentElement?.remove();
      }

      // Funciones del sistema de gamificaciÃ³n
      function getGamificationData() {
        return getGamificationDataForUser(getCurrentUser());
      }

      function saveGamificationData(data) {
        saveGamificationDataForUser(data, getCurrentUser());
      }

      function calculateUserStats() {
        return calculateUserStatsForUser(getCurrentUser());
      }

      window.getCurrentUser = function() {
        // Intentar obtener el usuario actual de diferentes fuentes
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('user') || localStorage.getItem('currentUser') || 'Usuario';
      }

      function addPoints(points, reason = '') {
        const data = getGamificationData();
        data.points += points;
        data.xp += points;
        
        // Verificar subida de nivel
        const newLevel = calculateLevel(data.xp);
        if (newLevel > data.level) {
          data.level = newLevel;
          showLevelUpNotification(newLevel);
        }
        
        saveGamificationData(data);
        return data;
      }

      function calculateLevel(xp) {
        for (let i = LEVELS.length - 1; i >= 0; i--) {
          if (xp >= LEVELS[i].xpRequired) {
            return LEVELS[i].level;
          }
        }
        return 1;
      }

      function getLevelInfo(level) {
        return LEVELS.find(l => l.level === level) || LEVELS[0];
      }

      function getNextLevelInfo(level) {
        return LEVELS.find(l => l.level === level + 1) || LEVELS[LEVELS.length - 1];
      }

      function updateStreak() {
        const data = getGamificationData();
        const currentUser = (typeof getCurrentUser === 'function')
          ? getCurrentUser()
          : (localStorage.getItem('currentUser') || '').trim();

        const today = new Date().toISOString().split('T')[0];
        const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];

        function getRequestsForDay(day) {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          if (Array.isArray(byDay[day]) && byDay[day].length) return byDay[day];
          const arr = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          return arr.filter(s => {
            const sday = s.day || (s.time ? new Date(s.time).toISOString().split('T')[0] : day);
            return sday === day;
          });
        }

        const todayRequests = getRequestsForDay(today);
        const distinctUsersToday = new Set(todayRequests.map(s => s && s.usuario)).size;
        const userRequestedToday = todayRequests.some(s => s && s.usuario === currentUser);

        const todayValid = distinctUsersToday >= 2 && userRequestedToday;
        if (!todayValid) {
          return data.streaks.current;
        }

        const yesterdayValid = !!data.streaks.calendar[yesterday];
        if (yesterdayValid) {
          data.streaks.current++;
        } else if (data.streaks.lastActivity !== today) {
          data.streaks.current = 1;
        }

        if (data.streaks.current > data.streaks.best) {
          data.streaks.best = data.streaks.current;
        }

        data.streaks.lastActivity = today;
        data.streaks.calendar[today] = true;

        saveGamificationData(data);
        return data.streaks.current;
      }

      async function calculateStreaksForUser(username, data, allSolicitudes) {
        try {
          console.log(`ğŸ”¥ Calculando rachas para ${username}`);

          // Mapear usuarios distintos por dÃ­a
          const usersByDay = {};
          allSolicitudes.forEach(s => {
            let day;
            if (s.day) {
              day = s.day;
            } else if (s.time) {
              day = new Date(s.time).toISOString().split('T')[0];
            } else if (s.ts) {
              try {
                day = new Date(s.ts).toISOString().split('T')[0];
              } catch (_) {
                day = new Date().toISOString().split('T')[0];
              }
            } else {
              day = new Date().toISOString().split('T')[0];
            }
            const user = s.usuario;
            if (!usersByDay[day]) usersByDay[day] = new Set();
            if (user) usersByDay[day].add(user);
          });

          // DÃ­as en los que el usuario solicitÃ³ algo
          const userDays = new Set();
          // Utilidad robusta para obtener el dÃ­a (YYYY-MM-DD) desde una solicitud
          const getSongDay = (entry) => {
            try {
              if (entry.day && typeof entry.day === 'string') {
                const parts = entry.day.split('-');
                if (parts.length === 3) {
                  const y = parseInt(parts[0], 10);
                  const m = parseInt(parts[1], 10) - 1;
                  const d = parseInt(parts[2], 10);
                  const dt = new Date(y, m, d);
                  if (!isNaN(dt.getTime())) return dt.toISOString().split('T')[0];
                }
                const d2 = new Date(entry.day);
                if (!isNaN(d2.getTime())) return d2.toISOString().split('T')[0];
              }
              if (entry.ts) {
                const dt = entry.ts && entry.ts.toDate ? entry.ts.toDate() : new Date(entry.ts);
                if (!isNaN(dt.getTime())) return dt.toISOString().split('T')[0];
              }
              if (entry.time) {
                const dt = entry.time && entry.time.toDate ? entry.time.toDate() : new Date(entry.time);
                if (!isNaN(dt.getTime())) return dt.toISOString().split('T')[0];
              }
            } catch (_) {}
            return new Date().toISOString().split('T')[0];
          };
          allSolicitudes.forEach(s => {
            if (s && s.usuario === username) {
              const day = getSongDay(s);
              userDays.add(day);
            }
          });

          // DÃ­as vÃ¡lidos: al menos 2 usuarios distintos y el usuario solicitÃ³
          const validDays = Array.from(userDays).filter(day => (usersByDay[day]?.size || 0) >= 2);
          const sortedDays = validDays.sort();
          console.log(`ğŸ“… DÃ­as vÃ¡lidos para racha de ${username}:`, sortedDays);

          if (sortedDays.length === 0) {
            data.streaks = {
              current: 0,
              best: Math.max(data.streaks?.best || 0, 0),
              lastActivity: null,
              calendar: {}
            };
            return;
          }

          // Construir calendario con dÃ­as vÃ¡lidos
          const calendar = {};
          sortedDays.forEach(day => {
            calendar[day] = true;
          });

          // Calcular mejor racha histÃ³rica (dÃ­as vÃ¡lidos consecutivos)
          let bestStreak = 0;
          let tempStreak = sortedDays.length ? 1 : 0;
          for (let i = 1; i < sortedDays.length; i++) {
            const curr = new Date(sortedDays[i]);
            const prev = new Date(sortedDays[i - 1]);
            const diff = (curr - prev) / (1000 * 60 * 60 * 24);
            if (diff === 1) {
              tempStreak++;
            } else {
              bestStreak = Math.max(bestStreak, tempStreak);
              tempStreak = 1;
            }
          }
          bestStreak = Math.max(bestStreak, tempStreak);

          // Calcular racha actual (hasta hoy o ayer)
          const today = new Date().toISOString().split('T')[0];
          const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
          let currentStreak = 0;

          const lastActivityDay = sortedDays[sortedDays.length - 1];
          if (lastActivityDay === today || lastActivityDay === yesterday) {
            currentStreak = 1;
            for (let i = sortedDays.length - 2; i >= 0; i--) {
              const curr = new Date(sortedDays[i + 1]);
              const prev = new Date(sortedDays[i]);
              const diff = (curr - prev) / (1000 * 60 * 60 * 24);
              if (diff === 1) {
                currentStreak++;
              } else {
                break;
              }
            }
          } else {
            currentStreak = 0;
          }

          data.streaks = {
            current: currentStreak,
            best: Math.max(data.streaks?.best || 0, bestStreak),
            lastActivity: lastActivityDay || null,
            calendar
          };

          console.log(`ğŸ”¥ Rachas (validadas) para ${username}:`, {
            current: data.streaks.current,
            best: data.streaks.best,
            lastActivity: data.streaks.lastActivity,
            totalValidDays: sortedDays.length
          });
        } catch (error) {
          console.error(`Error calculando rachas para ${username}:`, error);
          data.streaks = {
            current: 0,
            best: Math.max(data.streaks?.best || 0, 0),
            lastActivity: null,
            calendar: {}
          };
        }
      }

      function checkAchievements() {
        const data = getGamificationData();
        const stats = calculateUserStats();
        data.stats = { ...data.stats, ...stats };
        
        const newAchievements = [];
        
        ACHIEVEMENTS.forEach(achievement => {
          if (!data.achievements.includes(achievement.id) && achievement.condition(data.stats)) {
            data.achievements.push(achievement.id);
            newAchievements.push(achievement);
            // Solo otorgar puntos por logros NUEVOS, no por recargar la pÃ¡gina
            data.points += achievement.points;
            data.xp += achievement.points;
          }
        });
        
        // Solo guardar y mostrar notificaciÃ³n si hay logros NUEVOS
        if (newAchievements.length > 0) {
          saveGamificationData(data);
          showAchievementNotification(newAchievements);
        } else {
          // Si no hay logros nuevos, solo actualizar stats sin cambiar puntos
          saveGamificationData(data);
        }
        
        return newAchievements;
      }

      function showLevelUpNotification(level) {
        const levelInfo = getLevelInfo(level);
        // Crear notificaciÃ³n temporal
        const notification = document.createElement('div');
        notification.className = 'level-up-notification';
        notification.innerHTML = `
          <div class="notification-content">
            <div class="notification-icon">ğŸ‰</div>
            <div class="notification-text">
              <strong>Â¡Nivel ${level}!</strong><br>
              Ahora eres ${levelInfo.name}
            </div>
          </div>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.remove();
        }, 4000);
      }

      function showAchievementNotification(achievements) {
        achievements.forEach((achievement, index) => {
          setTimeout(() => {
            const notification = document.createElement('div');
            notification.className = 'achievement-notification';
            notification.innerHTML = `
              <div class="notification-content">
                <div class="notification-icon">${achievement.icon}</div>
                <div class="notification-text">
                  <strong>Â¡Logro desbloqueado!</strong><br>
                  ${achievement.title} (+${achievement.points} pts)
                </div>
              </div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
              notification.remove();
            }, 4000);
          }, index * 1000);
        });
      }

      async function renderGamificationModalBasic() {
        const data = getGamificationData();
        const currentLevel = getLevelInfo(data.level);
        const nextLevel = getNextLevelInfo(data.level);
        const progressPercent = ((data.xp - currentLevel.xpRequired) / (nextLevel.xpRequired - currentLevel.xpRequired)) * 100;
        
        // Actualizar informaciÃ³n del usuario
        document.getElementById('user-name').textContent = getCurrentUser();
        document.getElementById('user-level-name').textContent = currentLevel.name;
        document.getElementById('user-level-number').textContent = `Nivel ${data.level}`;
        document.getElementById('user-points').textContent = data.points;
        
        // Actualizar barra de progreso
        const progressFillEl = document.getElementById('progress-fill');
        const currentXpEl = document.getElementById('current-xp');
        const nextLevelXpEl = document.getElementById('next-level-xp');
        
        if (progressFillEl) progressFillEl.style.width = `${Math.min(progressPercent, 100)}%`;
        if (currentXpEl) currentXpEl.textContent = data.xp - currentLevel.xpRequired;
        if (nextLevelXpEl) nextLevelXpEl.textContent = nextLevel.xpRequired - currentLevel.xpRequired;
        
        // Renderizar logros
        renderAchievements(data);
        
        // Renderizar rachas
        await renderStreaks(data);
        
        // Renderizar estadÃ­sticas personales
        renderPersonalStats(data);
      }

      function renderAchievements(data) {
        const container = document.getElementById('achievements-list');
        
        container.innerHTML = ACHIEVEMENTS.map(achievement => {
          const isUnlocked = data.achievements.includes(achievement.id);
          const prog = getAchievementProgress(achievement, data.stats);
          
          return `
            <div class="achievement-card ${isUnlocked ? 'unlocked' : 'locked'}">
              <div class="achievement-points">+${achievement.points}</div>
              <div class="achievement-icon">${achievement.icon}</div>
              <div class="achievement-title">${achievement.title}</div>
              <div class="achievement-description">${achievement.description}</div>
              ${prog ? `
              <div class="achievement-progress">
                <div class="progress-bar">
                  <div class="progress-fill" style="width: ${prog.percent}%;"></div>
                </div>
                <div class="progress-text">${prog.current}/${prog.target} ${prog.unit}</div>
              </div>` : ''}
            </div>
          `;
        }).join('');
      }

      function getAchievementProgress(achievement, stats) {
        const id = achievement.id;
        const safe = (v) => typeof v === 'number' && isFinite(v) ? v : 0;

        // Objetivos por cantidad de canciones
        const songTargets = {
          first_song: 1, music_lover: 10, music_addict: 50, music_master: 100,
          music_pro_200: 200, music_elite_500: 500, music_legend_1000: 1000
        };
        if (id in songTargets) {
          const current = safe(stats.totalSongs || 0);
          const target = songTargets[id];
          return { current, target, unit: 'canciones', percent: Math.min(100, Math.round((current / target) * 100)) };
        }

        // Objetivos por artistas Ãºnicos
        const artistTargets = {
          diverse_taste: 10, explorer: 25, diverse_50: 50, diverse_100: 100
        };
        if (id in artistTargets) {
          const current = safe(stats.uniqueArtists || 0);
          const target = artistTargets[id];
          return { current, target, unit: 'artistas', percent: Math.min(100, Math.round((current / target) * 100)) };
        }

        // Objetivos por racha
        const streakTargets = {
          streak_starter: 3, streak_master: 7, streak_legend: 30,
          streak_14: 14, streak_30: 30, streak_60: 60
        };
        if (id in streakTargets) {
          const current = safe(stats.bestStreak || 0);
          const target = streakTargets[id];
          return { current, target, unit: 'dÃ­as', percent: Math.min(100, Math.round((current / target) * 100)) };
        }

        // Objetivos por dÃ­as activos
        const activeDayTargets = {
          daily_user: 10, daily_25: 25, daily_50: 50, daily_100: 100
        };
        if (id in activeDayTargets) {
          const current = safe(stats.activeDays || 0);
          const target = activeDayTargets[id];
          return { current, target, unit: 'dÃ­as', percent: Math.min(100, Math.round((current / target) * 100)) };
        }

        // Objetivos por mismo artista
        const sameArtistTargets = {
          same_artist_5: 5, same_artist_10: 10, same_artist_20: 20, same_artist_50: 50
        };
        if (id in sameArtistTargets) {
          const current = safe(stats.topArtistCount || 0);
          const target = sameArtistTargets[id];
          return { current, target, unit: 'canciones', percent: Math.min(100, Math.round((current / target) * 100)) };
        }

        // Objetivos por ser el primero en pedir
        const firstRequestTargets = {
          first_request_1: 1, first_request_3: 3, first_request_6: 6, first_request_9: 9,
          first_request_12: 12, first_request_15: 15, first_request_18: 18, first_request_21: 21
        };
        if (id in firstRequestTargets) {
          const current = safe(stats.firstRequests || 0);
          const target = firstRequestTargets[id];
          return { current, target, unit: 'veces', percent: Math.min(100, Math.round((current / target) * 100)) };
        }

        // Progreso para logros Zero FM
        if (id === 'zerofm_listener_1' ||
            id === 'zerofm_listener_3' ||
            id === 'zerofm_listener_6' ||
            id === 'zerofm_listener_9' ||
            id === 'zerofm_listener_12') {
          const targetById = {
            zerofm_listener_1: 1,
            zerofm_listener_3: 3,
            zerofm_listener_6: 6,
            zerofm_listener_9: 9,
            zerofm_listener_12: 12,
          };
          const target = targetById[id] || 1;
          const current = safe(stats.zeroFMSongs || 0);
          const unit = 'pedido(s) Zero FM';
          const percent = Math.min(100, Math.floor((current / target) * 100));
          return { current, target, unit, percent };
        }

        // Logros de estado (VIP/Z0/Donador) no muestran progreso
        return null;
      }

      async function renderStreaks(data) {
        try {
          const currentUser = getCurrentUser();
          console.log(`ğŸ”¥ Generando rachas individuales para ${currentUser}`);
          
          // Generar actividad del usuario para calcular rachas
          const userActivity = generateUserActivity(currentUser, 60); // 60 dÃ­as para mejor cÃ¡lculo de rachas
          
          // Calcular racha actual y mejor racha
          const dates = Object.keys(userActivity).sort();
          let currentStreak = 0;
          let bestStreak = 0;
          let tempStreak = 0;
          
          // Calcular desde el dÃ­a mÃ¡s reciente hacia atrÃ¡s para la racha actual
          const today = new Date().toISOString().split('T')[0];
          let checkDate = new Date();
          
          // Racha actual (dÃ­as consecutivos desde hoy hacia atrÃ¡s)
          for (let i = 0; i < 30; i++) {
            const dateStr = checkDate.toISOString().split('T')[0];
            if (userActivity[dateStr] && userActivity[dateStr] > 0) {
              currentStreak++;
            } else {
              break;
            }
            checkDate.setDate(checkDate.getDate() - 1);
          }
          
          // Mejor racha (mÃ¡xima secuencia de dÃ­as consecutivos)
          for (const date of dates) {
            if (userActivity[date] > 0) {
              tempStreak++;
              bestStreak = Math.max(bestStreak, tempStreak);
            } else {
              tempStreak = 0;
            }
          }
          
          console.log(`ğŸ“Š Rachas calculadas para ${currentUser}: actual=${currentStreak}, mejor=${bestStreak}`);
          
          const currentStreakEl = document.getElementById('current-streak');
          const bestStreakEl = document.getElementById('best-streak');
          
          if (currentStreakEl) {
            currentStreakEl.textContent = `${currentStreak} dÃ­as`;
          }
          
          if (bestStreakEl) {
            bestStreakEl.textContent = `${bestStreak} dÃ­as`;
          }
          
          // Renderizar calendario de actividad (ya actualizado para usar datos individuales)
          await renderStreakCalendar();
          
        } catch (error) {
          console.error('Error renderizando rachas:', error);
          
          // Valores por defecto en caso de error
          const currentStreakEl = document.getElementById('current-streak');
          const bestStreakEl = document.getElementById('best-streak');
          
          if (currentStreakEl) currentStreakEl.textContent = '0 dÃ­as';
          if (bestStreakEl) bestStreakEl.textContent = '0 dÃ­as';
          
          // Renderizar calendario con datos del usuario actual
          await renderStreakCalendar();
        }
      }

      // Estado del mes/aÃ±o mostrado (calendario de rachas)
      let currentCalendarMonth = new Date().getMonth();
      let currentCalendarYear = new Date().getFullYear();

      async function renderStreakCalendar(calendar) {
        try {
          const container = document.getElementById('streak-calendar-grid');
          if (!container) return;

          const currentUser = getCurrentSelectedUser();

          // Actividad del usuario para el mes mostrado
          const userActivity = await getUserActivityForMonth(
            currentUser,
            currentCalendarYear,
            currentCalendarMonth
          );

          // Render del mes (6 semanas, 42 dÃ­as)
          const days = generateMonthCalendar(
            currentCalendarYear,
            currentCalendarMonth,
            userActivity
          );

          container.innerHTML = days.join('');

          // Sincronizar selects de mes/aÃ±o
          updateCalendarSelectors();
        } catch (error) {
          console.error('Error renderizando calendario de rachas:', error);
          const container = document.getElementById('streak-calendar-grid');
          if (container) {
            container.innerHTML = '<div class="calendar-day">Error al cargar actividad</div>';
          }
        }
      }

      function generateMonthCalendar(year, month, userActivity) {
        const today = new Date();
        const firstDay = new Date(year, month, 1);
        const startDate = new Date(firstDay);
        // Ajuste al domingo anterior
        startDate.setDate(startDate.getDate() - firstDay.getDay());

        const days = [];
        const currentDate = new Date(startDate);

        // Generar 6 semanas para cubrir el mes
        for (let i = 0; i < 42; i++) {
          const dateStr = currentDate.toISOString().split('T')[0];
          const isCurrentMonth = currentDate.getMonth() === month;
          const isToday = currentDate.toDateString() === today.toDateString();
          const activityCount = userActivity[dateStr] || 0;

          const classes = ['calendar-day'];
          let activityTitle = `${currentDate.getDate()}`;

          if (!isCurrentMonth) {
            classes.push('other-month');
            activityTitle += ' (otro mes)';
          } else {
            if (activityCount > 0) {
              if (activityCount >= 10) {
                classes.push('activity-very-high');
                activityTitle += ` - ${activityCount} canciones (Muy activo)`;
              } else if (activityCount >= 5) {
                classes.push('activity-high');
                activityTitle += ` - ${activityCount} canciones (Muy activo)`;
              } else if (activityCount >= 3) {
                classes.push('activity-medium');
                activityTitle += ` - ${activityCount} canciones (Activo)`;
              } else {
                classes.push('activity-low');
                activityTitle += ` - ${activityCount} canciÃ³n${activityCount > 1 ? 'es' : ''} (Poco activo)`;
              }
            } else {
              activityTitle += ' - Sin actividad';
            }
          }

          if (isToday) classes.push('today');

          days.push(
            `<div class="${classes.join(' ')}" title="${activityTitle}">${currentDate.getDate()}</div>`
          );

          currentDate.setDate(currentDate.getDate() + 1);
        }

        return days;
      }

      async function getUserActivityForMonth(username, year, month) {
        try {
          // Intentar usar datos reales si la funciÃ³n existe
          if (typeof computeActivityForMonth === 'function') {
            const activity = await computeActivityForMonth(username, month, year);
            return activity || {};
          }
        } catch (e) {
          // Continuar con datos simulados
        }

        // Fallback con datos simulados por usuario y mes
        const result = {};
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const userHash = typeof hashCode === 'function' ? hashCode(username) : 0;
        const rng = typeof seedRandom === 'function' ? seedRandom(userHash) : null;

        for (let d = 1; d <= daysInMonth; d++) {
          const date = new Date(year, month, d);
          const dateStr = date.toISOString().split('T')[0];
          const isWeekend = date.getDay() === 0 || date.getDay() === 6;
          let r = rng ? rng() : Math.random();
          let songs = 0;
          if (r < 0.05) songs = 0;
          else if (r < 0.25) songs = 1;
          else if (r < 0.5) songs = 2;
          else if (r < 0.75) songs = isWeekend ? 4 : 3;
          else if (r < 0.9) songs = isWeekend ? 5 : 4;
          else songs = isWeekend ? 6 : 5;
          result[dateStr] = songs;
        }

        return result;
      }

      function updateCalendarSelectors() {
        const monthSelect = document.getElementById('month-select');
        const yearSelect = document.getElementById('year-select');

        if (monthSelect) {
          monthSelect.value = String(currentCalendarMonth);
        }

        if (yearSelect) {
          const currentYear = new Date().getFullYear();
          // Mantener opciones razonables de aÃ±os
          const existingYears = Array.from(yearSelect.options).map(o => parseInt(o.value, 10));
          if (!existingYears.length) {
            yearSelect.innerHTML = '';
            for (let year = currentYear - 2; year <= currentYear + 1; year++) {
              const option = document.createElement('option');
              option.value = String(year);
              option.textContent = String(year);
              yearSelect.appendChild(option);
            }
          }
          yearSelect.value = String(currentCalendarYear);
        }
      }

      function initializeCalendarNavigation() {
        const prevBtn = document.getElementById('prev-month');
        const nextBtn = document.getElementById('next-month');
        const monthSelect = document.getElementById('month-select');
        const yearSelect = document.getElementById('year-select');

        prevBtn?.addEventListener('click', () => {
          currentCalendarMonth--;
          if (currentCalendarMonth < 0) {
            currentCalendarMonth = 11;
            currentCalendarYear--;
          }
          renderStreakCalendar();
        });

        nextBtn?.addEventListener('click', () => {
          currentCalendarMonth++;
          if (currentCalendarMonth > 11) {
            currentCalendarMonth = 0;
            currentCalendarYear++;
          }
          renderStreakCalendar();
        });

        monthSelect?.addEventListener('change', (e) => {
          currentCalendarMonth = parseInt(e.target.value, 10);
          renderStreakCalendar();
        });

        yearSelect?.addEventListener('change', (e) => {
          currentCalendarYear = parseInt(e.target.value, 10);
          renderStreakCalendar();
        });
      }

      // FunciÃ³n auxiliar para obtener la actividad del usuario por dÃ­as
      async function getUserActivityForDays(username, days) {
        try {
          console.log(`ğŸ“Š Generando actividad individual para ${username} (Ãºltimos ${days} dÃ­as)`);
          
          // Usar la funciÃ³n generateUserActivity para generar datos individuales consistentes
          const userActivity = await generateUserActivity(username, days);
          
          console.log(`âœ… Actividad generada para ${username}:`, userActivity);
          console.log(`ğŸ“… DÃ­as con actividad: ${Object.keys(userActivity).filter(day => userActivity[day] > 0).length}`);
          
          return userActivity;
        } catch (error) {
          console.error('Error generando actividad del usuario:', error);
          return {};
        }
      }

      async function renderPersonalStats(data) {
        try {
          const user = typeof getCurrentSelectedUser === 'function' ? getCurrentSelectedUser() : getCurrentUser();
          await renderPersonalStatsForUser(data, user);
        } catch (error) {
          console.error('Error renderizando estadÃ­sticas personales:', error);
          const elements = [
            'personal-total-songs',
            'personal-unique-artists', 
            'personal-active-days',
            'personal-rank'
          ];
          elements.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.textContent = id === 'personal-rank' ? '-' : '0';
          });
        }
      }

      async function renderFavoriteGenres() {
        try {
          const container = document.getElementById('favorite-genres-list');
          if (!container) return;
          const targetUser = typeof getCurrentSelectedUser === 'function' ? getCurrentSelectedUser() : getCurrentUser();
          async function normalizeExternalGenre(name, artist) {
            const g = String(name || '').toLowerCase();
            const a = String(artist || '').toLowerCase();
            if (!g) return null;
            if (g.includes('hip-hop') || g.includes('rap')) return 'Hip Hop';
            if (g.includes('r&b') || g.includes('soul')) return 'R&B';
            if (g.includes('electronic') || g.includes('dance')) return 'ElectrÃ³nica';
            if (g.includes('rock')) return 'Rock';
            if (g.includes('indie')) return 'Indie';
            if (g.includes('reggae')) return 'Reggae';
            if (g.includes('latin')) {
              const latinReggaeton = ['bad bunny','j balvin','daddy yankee','ozuna','anuel','karol g','maluma','nicky jam','sech','farruko','arcangel'];
              const latinSalsa = ['marc anthony','la india','victor manuelle'];
              const latinBachata = ['romeo santos','aventura','prince royce'];
              const latinCumbia = ['los Ã¡ngeles azules','angeles azules','grupo 5'];
              const latinRegional = ['grupo firme','peso pluma','fuerza regida','carin leÃ³n','natanael cano','marca mp','christian nodal'];
              if (latinReggaeton.some(n => a.includes(n))) return 'Reggaeton';
              if (latinSalsa.some(n => a.includes(n))) return 'Salsa';
              if (latinBachata.some(n => a.includes(n))) return 'Bachata';
              if (latinCumbia.some(n => a.includes(n))) return 'Cumbia';
              if (latinRegional.some(n => a.includes(n))) return 'Regional';
              return 'Latino';
            }
            if (g.includes('pop')) return 'Pop';
            return null;
          }
          async function fetchItunesGenre(artist, song) {
            try {
              const term = encodeURIComponent(`${artist} ${song}`);
              const url = `https://itunes.apple.com/search?term=${term}&entity=song&limit=3`;
              const res = await fetch(url);
              if (!res.ok) return [];
              const data = await res.json();
              const out = [];
              for (const r of (data.results || [])) {
                const matchArtist = String(r.artistName || '').toLowerCase();
                const target = String(artist || '').toLowerCase();
                if (matchArtist && target && !matchArtist.includes(target)) continue;
                const norm = await normalizeExternalGenre(r.primaryGenreName, artist);
                if (norm) out.push(norm);
              }
              return Array.from(new Set(out)).slice(0,2);
            } catch (_) {
              return [];
            }
          }
          async function inferGenres(artist, song) {
            const key = `${String(artist||'').toLowerCase()}|${String(song||'').toLowerCase()}`;
            const cacheStr = localStorage.getItem('genreCache') || '{}';
            const cache = JSON.parse(cacheStr);
            if (cache[key]) return cache[key];
            const web = await fetchItunesGenre(artist, song);
            if (web && web.length) {
              cache[key] = web;
              localStorage.setItem('genreCache', JSON.stringify(cache));
              return web;
            }
            const a = String(artist || '').toLowerCase();
            const t = String(song || '').toLowerCase();
            const contains = (k) => a.includes(k) || t.includes(k);
            const hits = [];
            if (contains('bachata') || ['romeo santos','aventura','prince royce'].some(n => a.includes(n))) hits.push('Bachata');
            if (contains('salsa') || ['marc anthony','la india','victor manuelle'].some(n => a.includes(n))) hits.push('Salsa');
            if (contains('cumbia') || ['los Ã¡ngeles azules','angeles azules','grupo 5'].some(n => a.includes(n))) hits.push('Cumbia');
            if (contains('corridos') || contains('regional') || ['grupo firme','peso pluma','fuerza regida','carin leÃ³n','natanael cano','marca mp','christian nodal'].some(n => a.includes(n))) hits.push('Regional');
            if (contains('reggaeton') || ['bad bunny','j balvin','daddy yankee','ozuna','anuel','karol g','maluma','nicky jam','sech','farruko','arcangel'].some(n => a.includes(n))) hits.push('Reggaeton');
            if (contains('trap') || ['myke towers','eladio carrion'].some(n => a.includes(n))) hits.push('Trap');
            if (contains('hip hop') || ['drake','kendrick lamar','travis scott','eminem','nicki minaj'].some(n => a.includes(n)) || a.startsWith('lil ')) hits.push('Hip Hop');
            if (contains('r&b') || ['the weeknd','bruno mars','sza','usher','chris brown'].some(n => a.includes(n))) hits.push('R&B');
            if (contains('electrÃ³nica') || contains('electro') || contains('edm') || ['calvin harris','avicii','tiesto','martin garrix','david guetta','daft punk','alesso','zedd','armin van buuren','afrojack'].some(n => a.includes(n))) hits.push('ElectrÃ³nica');
            if (contains('house') || ['fred again','swedish house mafia'].some(n => a.includes(n))) hits.push('House');
            if (contains('rock') || ['metallica','ac/dc','linkin park','foo fighters','guns n','queen','nirvana','red hot chili peppers'].some(n => a.includes(n))) hits.push('Rock');
            if (contains('indie') || ['arctic monkeys','the killers','tame impala','lana del rey','mgmt'].some(n => a.includes(n))) hits.push('Indie');
            if (contains('jazz')) hits.push('Jazz');
            if (contains('folk')) hits.push('Folk');
            if (contains('funk')) hits.push('Funk');
            if (contains('soul') || ['adele','sam smith','al green'].some(n => a.includes(n))) hits.push('Soul');
            if (contains('vallenato') || ['silvestre dangond','diomedes diaz'].some(n => a.includes(n))) hits.push('Vallenato');
            if (contains('merengue') || ['juan luis guerra'].some(n => a.includes(n))) hits.push('Merengue');
            if (contains('reggae') || ['bob marley'].some(n => a.includes(n))) hits.push('Reggae');
            if (contains('k-pop') || ['bts','blackpink','stray kids','newjeans'].some(n => a.includes(n))) hits.push('K-Pop');
            if (contains('afrobeats') || ['burna boy','wizkid','tems','rema'].some(n => a.includes(n))) hits.push('Afrobeats');
            if (contains('pop') || ['taylor swift','ed sheeran','dua lipa','shakira','billie eilish','coldplay','harry styles','selena gomez','olivia rodrigo'].some(n => a.includes(n))) hits.push('Pop');
            const local = Array.from(new Set(hits)).slice(0,2);
            cache[key] = local;
            localStorage.setItem('genreCache', JSON.stringify(cache));
            return local;
          }
          const all = await getAllCombinedSolicitudes();
          const norm = (x) => String(x||'').trim().replace(/^@/,'').toLowerCase();
          const userSongs = all.filter(s => norm(s.usuario) === norm(targetUser));
          const counts = {};
          for (const s of userSongs) {
            const gs = await inferGenres(s.artista, s.cancion);
            for (const g of gs) counts[g] = (counts[g] || 0) + 1;
          }
          let top = Object.entries(counts).sort((a, b) => b[1] - a[1]).map(([g]) => g);
          if (top.length < 3 && userSongs.length >= 6) {
            const seen = new Set(top);
            const candidates = ['Pop','ElectrÃ³nica','Indie','Rock','Reggaeton'];
            for (const c of candidates) {
              if (!seen.has(c)) top.push(c);
              if (top.length >= 3) break;
            }
          }
          top = top.slice(0,5);
          container.innerHTML = top.length
            ? top.map(genre => `<span class="genre-tag">${genre}</span>`).join('')
            : '<span class="genre-tag">Sin datos</span>';
        } catch (error) {
          const container = document.getElementById('favorite-genres-list');
          if (container) container.innerHTML = '<span class="genre-tag">Error cargando gÃ©neros</span>';
        }
      }

      // Event listeners para tabs de gamificaciÃ³n
      document.querySelectorAll('.gamification-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const targetTab = tab.dataset.tab;
          
          // Actualizar tabs activos
          document.querySelectorAll('.gamification-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.gamification-panel').forEach(p => p.classList.remove('active'));
          
          tab.classList.add('active');
          document.getElementById(`gamification-${targetTab}`).classList.add('active');
          
          // Forzar repintado de tÃ­tulos en TODOS los dispositivos (especialmente en modo oscuro)
          setTimeout(() => {
            const activePanel = document.getElementById(`gamification-${targetTab}`);
            if (activePanel) {
              const titles = activePanel.querySelectorAll('h3, h4');
              const isDarkTheme = document.body.classList.contains('dark-theme');
              
              titles.forEach(title => {
                // Forzar repintado mÃ¡s agresivo para modo oscuro
                if (isDarkTheme) {
                  // Forzar recÃ¡lculo de color en modo oscuro
                  const originalColor = title.style.color;
                  title.style.color = 'transparent';
                  
                  requestAnimationFrame(() => {
                    title.style.color = originalColor || '';
                    // Forzar repintado adicional con transform
                    const originalTransform = title.style.transform;
                    title.style.transform = 'translate3d(0.1px, 0, 0)';
                    
                    requestAnimationFrame(() => {
                      title.style.transform = originalTransform || 'translate3d(0, 0, 0)';
                    });
                  });
                } else {
                  // Repintado normal para modo claro
                  const originalTransform = title.style.transform;
                  title.style.transform = 'translateZ(0.1px)';
                  requestAnimationFrame(() => {
                    title.style.transform = originalTransform || 'translateZ(0)';
                  });
                }
              });
            }
          }, 10);
        });
      });

      // Admin Section Tabs Logic
      document.querySelectorAll('.admin-section-tabs .points-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const parent = tab.closest('.admin-section');
          if (!parent) return;
          
          // Deactivate all tabs in this section
          parent.querySelectorAll('.points-tab').forEach(t => t.classList.remove('active'));
          // Hide all panels in this section
          parent.querySelectorAll('.admin-tab-panel').forEach(p => p.classList.remove('active'));
          
          // Activate clicked tab
          tab.classList.add('active');
          // Show target panel
          const targetTab = tab.dataset.tab;
          const targetPanel = parent.querySelector(`#admin-tab-${targetTab}`);
          if (targetPanel) targetPanel.classList.add('active');
        });
      });

      // Event listeners para modal de gamificaciÃ³n
      gamificationOpenBtn?.addEventListener('click', async () => {
        // Cerrar el menÃº
        closeMenu();
        hideSearchResults();
        // Inicializar con el usuario actual
        currentSelectedUser = getCurrentUser();
        
        // Poblar selector de usuarios
        if (typeof populateUserSelector === 'function') {
          populateUserSelector().catch(error => {
            console.error('Error en populateUserSelector, usando fallback:', error);
            populateUserSelectorFromLocalStorage();
          });
        } else {
          populateUserSelectorFromLocalStorage();
        }
        
        // Asegurar que el usuario actual estÃ© seleccionado
        if (!currentSelectedUser) {
          currentSelectedUser = getCurrentUser();
        }
        
        console.log(`ğŸ® Abriendo modal de gamificaciÃ³n para: ${getCurrentSelectedUser()}`);
        console.log(`ğŸ“Š Estado inicial - currentSelectedUser: ${currentSelectedUser}`);
        
        renderGamificationModal().catch(console.error);
  // Asegurar inicializaciÃ³n de la navegaciÃ³n una sola vez y render del mes actual
  if (!window.__calendarNavInit__) {
    initializeCalendarNavigation();
    window.__calendarNavInit__ = true;
  }
        await renderStreakCalendar();
        if (gamificationModal) gamificationModal.hidden = false;
      });
      
      // FunciÃ³n para cargar solicitudes basada en el dÃ­a seleccionado
      window.loadSolicitudes = function() {
        const daySelect = document.getElementById('day-select');
        const dayValue = daySelect ? daySelect.value : '';
        if (dayValue && typeof subscribeSolicitudesForDay === 'function') {
          console.log(`ğŸ“… Cargando solicitudes para el dÃ­a: ${dayValue}`);
          subscribeSolicitudesForDay(dayValue);
        } else {
          console.warn('loadSolicitudes: No hay dÃ­a seleccionado o funciÃ³n de suscripciÃ³n no disponible');
          // Fallback: intentar cargar todo o lo que haya en localStorage
          if (typeof getAllCombinedSolicitudes === 'function') {
             getAllCombinedSolicitudes().then(items => {
               if (typeof renderSolicitudes === 'function') renderSolicitudes(items);
             });
          }
        }
      };

      document.addEventListener('DOMContentLoaded', async () => {
        console.log('ğŸš€ Inicializando aplicaciÃ³n...');

        const daySelectEl = document.getElementById('day-select');
        const recalculateBtn = document.getElementById('recalculate-users');
        
        if (recalculateBtn) {
          recalculateBtn.addEventListener('click', async () => {
            if (typeof window.corregirPuntosTodosLosUsuarios === 'function') {
              await window.corregirPuntosTodosLosUsuarios();
            }
          });
        }

        if (daySelectEl) {
          daySelectEl.addEventListener('change', () => {
            if (typeof window.loadSolicitudes === 'function') {
              window.loadSolicitudes();
            }
          });
        }

        // Initial load for transparency section
        setTimeout(async () => {
          const currentUser = getCurrentProfileUser();
          if (currentUser) {
            await renderPointsBreakdownForUser(currentUser);
          }
        }, 1000); // Small delay to ensure everything is loaded

        // Cargar dÃ­as disponibles
        if (typeof loadDays === 'function') {
          await loadDays();
        }
        
        // Si loadDays no seleccionÃ³ nada (o no disparÃ³ el evento), intentar cargar manualmente
        const daySelect = document.getElementById('day-select');
        if (daySelect && daySelect.value) {
           if (typeof window.loadSolicitudes === 'function') {
             window.loadSolicitudes();
           }
        }

        // Auto-test: ejecutar verificaciÃ³n automÃ¡tica si se incluye ?autotest=1
        try {
          const params = new URLSearchParams(window.location.search);
          if (params.get('autotest') === '1') {
            setTimeout(async () => {
              try {
                const u = (typeof getCurrentSelectedUser === 'function') ? getCurrentSelectedUser() : getCurrentUser();
                if (typeof window.runToggleVerification === 'function') {
                  const res = await window.runToggleVerification(u);
                  console.log('AUTOTEST RESULT:', res);
                }
              } catch (e) {
                console.log('AUTOTEST ERROR:', e);
              }
            }, 1500);
          }
        } catch (_) {}
      });

      // Event listener para el botÃ³n X de cerrar
      document.getElementById('gamification-close-x')?.addEventListener('click', () => {
        if (gamificationModal) gamificationModal.hidden = true;
      });
      
      // FunciÃ³n para analizar automÃ¡ticamente nuevos usuarios
      async function analyzeNewUsersAutomatically() {
        try {
          const allSolicitudes = await getAllCombinedSolicitudes();
          const allUsers = [...new Set(allSolicitudes
            .map(s => s.usuario)
            .filter(user => user && user.trim() !== '')
          )];
          
          // Verificar quÃ© usuarios no han sido procesados automÃ¡ticamente
          const newUsers = [];
          for (const user of allUsers) {
            const data = getGamificationDataForUser(user);
            if (!data.autoProcessed) {
              newUsers.push(user);
            }
          }
          
          if (newUsers.length > 0) {
            console.log(`ğŸ” Detectados ${newUsers.length} usuarios nuevos para anÃ¡lisis automÃ¡tico`);
            
            for (const user of newUsers) {
              await analyzeAndGrantPointsForUser(user);
            }
            
            console.log('âœ… AnÃ¡lisis automÃ¡tico completado para usuarios nuevos');
          }
        } catch (error) {
          console.error('Error en anÃ¡lisis automÃ¡tico de nuevos usuarios:', error);
        }
      }
      window.analyzeNewUsersAutomatically = analyzeNewUsersAutomatically;



      // FunciÃ³n para procesar nueva solicitud de canciÃ³n
      function processNewSongRequest() {
        const streakDays = updateStreak();
        let points = POINTS_CONFIG.SONG_REQUEST;
        
        // Bonus por racha
        if (streakDays > 1) {
          points += POINTS_CONFIG.STREAK_MULTIPLIER * Math.min(streakDays - 1, 10);
        }
        
        // Bonus VIP
        const vipUsers = JSON.parse(localStorage.getItem('vipUsers') || '[]');
        if (vipUsers.includes(getCurrentUser())) {
          points += POINTS_CONFIG.VIP_BONUS;
        }
        
        addPoints(points, 'Solicitud de canciÃ³n');
        checkAchievements();
      }

      // Agregar estilos para notificaciones
      const notificationStyles = document.createElement('style');
      notificationStyles.textContent = `
        .level-up-notification,
        .achievement-notification {
          position: fixed;
          top: 20px;
          right: 20px;
          background: linear-gradient(135deg, #4CAF50, #45a049);
          color: white;
          padding: 16px 20px;
          border-radius: 12px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          z-index: 1000;
          animation: slideInRight 0.3s ease, slideOutRight 0.3s ease 3.7s forwards;
          max-width: 300px;
        }
        
        .achievement-notification {
          background: linear-gradient(135deg, #FF6B6B, #ee5a24);
        }
        
        .notification-content {
          display: flex;
          align-items: center;
          gap: 12px;
        }
        
        .notification-icon {
          font-size: 24px;
        }
        
        .notification-text {
          font-size: 14px;
          line-height: 1.3;
        }
        
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutRight {
          from { transform: translateX(0); opacity: 1; }
          to { transform: translateX(100%); opacity: 0; }
        }
      `;
      document.head.appendChild(notificationStyles);

      async function updateUserHeaderUI(username, providedData = null) {
        const data = providedData || getGamificationDataForUser(username);
        if (!data) return;

        const currentLevel = getLevelInfo(data.level);
        
        const userNameEl = document.getElementById('user-name');
        const userLevelNameEl = document.getElementById('user-level-name');
        const userLevelNumberEl = document.getElementById('user-level-number');
        const userPointsEl = document.getElementById('user-points');
        
        if (userNameEl) userNameEl.textContent = username;
        if (userLevelNameEl) userLevelNameEl.textContent = currentLevel.name;
        if (userLevelNumberEl) userLevelNumberEl.textContent = `Nivel ${data.level}`;
        if (userPointsEl) userPointsEl.textContent = data.points;
        try { renderEarnedBadgesForUser(username); } catch (_) {}
      }

      // Inicializar sistema de gamificaciÃ³n
      async function initGamification() {
        try {
          console.log('ğŸ® INICIANDO SISTEMA DE GAMIFICACIÃ“N...');
          
          // Usar la funciÃ³n de actualizaciÃ³n forzada que es mÃ¡s robusta
          await forceUpdateAllUsers();

          // SETUP REALTIME LISTENERS FOR CURRENT USER
          if (window.db) {
             const currentUser = getCurrentUser();
             console.log(`ğŸ“¡ Configurando listeners en tiempo real para ${currentUser}`);
             
             // Escuchar cambios en playedSongs (global) para recalcular stats
             db.collection('playedSongs').onSnapshot(async (snapshot) => {
                if (snapshot.empty) return;
                
                console.log('ğŸ“¡ Cambio detectado en playedSongs - Recalculando stats del usuario actual...');
                
                // Recalcular stats del usuario actual
                await analyzeAndGrantPointsForUser(currentUser);
                
                // Actualizar UI del header
                try {
                   await updateUserHeaderUI(currentUser);
                } catch(e) { console.warn('Error actualizando header:', e); }
             });
          }
          
        } catch (error) {
          console.error('Error en inicializaciÃ³n automÃ¡tica:', error);
          // Fallback: inicializar solo el usuario actual
          try {
            const currentUser = getCurrentUser();
            await analyzeAndGrantPointsForUser(currentUser);
            await populateUserSelector();
          } catch (fallbackError) {
            console.error('Error en fallback:', fallbackError);
          }
        }
      }

      // FunciÃ³n para analizar y otorgar puntos automÃ¡ticamente a un usuario
      async function analyzeAndGrantPointsForUser(username) {
        try {
          const targetUser = username || getCurrentUser();
          console.log(`ğŸ” Analizando usuario: ${targetUser}`);
          
          // Obtener datos actuales del usuario
          let data = getGamificationDataForUser(targetUser);
          console.log(`ğŸ“Š Datos actuales de ${targetUser}:`, data);
          
          // Validar y corregir estructura de datos
          const existingAchievementPoints = validateAndFixGamificationData(data, targetUser);
          
          // Siempre recalcular para asegurar datos actualizados
          console.log(`ğŸ”„ Recalculando datos para ${targetUser}...`);
          
          // Calcular estadÃ­sticas del usuario
          const stats = await calculateUserStatsForUser(targetUser);
          console.log(`ğŸ“ˆ EstadÃ­sticas de ${targetUser}:`, stats);
          
          // Si las estadÃ­sticas parecen incorrectas, ejecutar diagnÃ³stico
          if (stats.totalSongs === 0 && targetUser !== 'test') {
            console.log(`âš ï¸ Usuario ${targetUser} tiene 0 canciones, ejecutando diagnÃ³stico...`);
            await diagnoseSolicitudesIssues(targetUser);
          }
          
          // Calcular puntos base por canciones reproducidas
          const basePoints = (stats.totalPlayedSongs || 0) * POINTS_CONFIG.SONG_REQUEST;
          
          // Bonus diario por conexiÃ³n (basado en dÃ­as activos)
          const dailyBonusPoints = (stats.activeDays || 0) * POINTS_CONFIG.DAILY_BONUS;

          console.log(`ğŸ’° Puntos base para ${targetUser}: ${basePoints} (${stats.totalPlayedSongs} canciones Ã— ${POINTS_CONFIG.SONG_REQUEST})`);
          console.log(`ğŸ’° Puntos por conexiÃ³n diaria: ${dailyBonusPoints} (${stats.activeDays} dÃ­as Ã— ${POINTS_CONFIG.DAILY_BONUS})`);
          
          // Bonus VIP si aplica, sobre canciones reproducidas
          const vipBonus = stats.isVip ? (stats.totalPlayedSongs || 0) * POINTS_CONFIG.VIP_BONUS : 0;
          
          // Calcular puntos totales base (sin logros)
          const totalBasePoints = basePoints + dailyBonusPoints + vipBonus;

          // Preservar logros existentes antes de actualizar datos base
          const existingAchievements = [...(data.achievements || [])];
          console.log(`ğŸ“‹ Preservando ${existingAchievements.length} logros existentes para ${targetUser}`);
          
          // Actualizar datos base (sin incluir puntos de logros aÃºn)
          data.points = totalBasePoints;
          data.xp = totalBasePoints;
          data.level = calculateLevel(totalBasePoints);
          data.stats = stats;
          data.autoProcessed = true;
          data.achievements = existingAchievements; // Preservar logros existentes
          
          // Preservar rachas existentes si las hay
          if (!data.streaks || !data.streaks.best) {
            data.streaks = {
              current: 0,
              best: Math.min(stats.activeDays, 7), // EstimaciÃ³n conservadora
              lastActivity: null,
              calendar: {}
            };
          }
          
          // Log de puntos base
          console.log(`ğŸ’° Puntos base calculados para ${targetUser}: ${totalBasePoints}`);
          console.log(`   - Canciones: ${stats.totalSongs} Ã— ${POINTS_CONFIG.SONG_REQUEST} = ${basePoints}`);
          console.log(`   - Bonus VIP: ${vipBonus}`);
          
          // Actualizar bestStreak en las estadÃ­sticas para los logros
          data.stats.bestStreak = data.streaks.best;
          
          // Verificar y otorgar logros automÃ¡ticamente
          let newAchievementPoints = 0;
          ACHIEVEMENTS.forEach(achievement => {
            if (achievement.condition(data.stats)) {
              if (!data.achievements.includes(achievement.id)) {
                data.achievements.push(achievement.id);
                newAchievementPoints += achievement.points;
                console.log(`ğŸ† Nuevo logro otorgado a ${targetUser}: ${achievement.title} (+${achievement.points} puntos)`);
              }
            }
          });
          
          // Calcular puntos totales de logros (existentes + nuevos)
          const totalAchievementPoints = existingAchievementPoints + newAchievementPoints;
          
          // Agregar puntos de logros al total
          data.points += totalAchievementPoints;
          data.xp += totalAchievementPoints;
          
          // Log de puntos de logros
          if (newAchievementPoints > 0) {
            console.log(`ğŸ’° Puntos de nuevos logros para ${targetUser}: +${newAchievementPoints}`);
          }
          if (existingAchievementPoints > 0) {
            console.log(`ğŸ’° Puntos de logros existentes para ${targetUser}: +${existingAchievementPoints}`);
          }
          
          // Recalcular nivel con puntos totales finales
          data.level = calculateLevel(data.points);
          
          // Log final de resumen
          console.log(`ğŸ“Š Resumen final para ${targetUser}:`);
          console.log(`   - Puntos base: ${totalBasePoints}`);
          console.log(`   - Puntos de logros existentes: ${existingAchievementPoints}`);
          console.log(`   - Puntos de logros nuevos: ${newAchievementPoints}`);
          console.log(`   - Total puntos: ${data.points}`);
          console.log(`   - Nivel: ${data.level}`);
          console.log(`   - Logros totales: ${data.achievements.length}`);
          
          // Guardar datos locales
          saveGamificationDataForUser(data, targetUser);
          console.log(`ğŸ’¾ Datos guardados para ${targetUser}`);

          // PASO FINAL: Usar la lÃ³gica maestra de computeUserBreakdown para obtener el total exacto
          // que incluye Manual Bonus, Top 1 Bonus, y Streak Bonus calculado correctamente.
          // Esto asegura que el Top 3 Global coincida con la Transparencia.
          try {
             console.log(`ğŸ”„ Calculando total autorizado para ${targetUser} usando computeUserBreakdown...`);
             const breakdown = await computeUserBreakdown(targetUser);
             
             if (breakdown && typeof breakdown.total === 'number') {
                console.log(`âœ… Total autorizado obtenido: ${breakdown.total} (vs local: ${data.points})`);
                data.points = breakdown.total;
                
                // Actualizar nivel basado en el total real
                data.level = calculateLevel(data.points);
                
                // Guardar de nuevo localmente con el total correcto
                saveGamificationDataForUser(data, targetUser);
             }
          } catch(bdError) {
             console.error('Error calculando breakdown autorizado:', bdError);
          }

          // Persistir en Firestore para ranking global
          if (window.db) {
            const normUser = normalizeUserKey(targetUser);
            db.collection('userStats').doc(normUser).set({
              totalPoints: data.points,
              level: data.level,
              achievements: data.achievements,
              lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true }).catch(err => console.error('Error guardando stats en Firestore:', err));
          }
          
          console.log(`âœ… Usuario ${targetUser}: ${data.points} puntos, nivel ${data.level}, ${data.achievements.length} logros`);
          
        } catch (error) {
          console.error(`Error procesando usuario ${targetUser}:`, error);
        }
      }

      // FunciÃ³n para diagnosticar problemas en la obtenciÃ³n de solicitudes
      async function diagnoseSolicitudesIssues(username) {
        console.log(`ğŸ” DIAGNÃ“STICO COMPLETO PARA: ${username}`);
        
        try {
          // 1. Verificar Firestore
          const firestoreSnapshot = await db.collection('solicitudes').where('usuario', '==', username).get();
          const firestoreCount = firestoreSnapshot.size;
          console.log(`ğŸ”¥ Firestore: ${firestoreCount} solicitudes para ${username}`);
          
          // 2. Verificar localStorage directo
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const localCount = localSolicitudes.filter(s => s.usuario === username).length;
          console.log(`ğŸ’¾ localStorage directo: ${localCount} solicitudes para ${username}`);
          
          // 3. Verificar localStorage byDay
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          let byDayCount = 0;
          Object.values(byDay).flat().forEach(s => {
            if (s.usuario === username) byDayCount++;
          });
          console.log(`ğŸ“… localStorage byDay: ${byDayCount} solicitudes para ${username}`);
          
          // 4. Verificar funciÃ³n combinada
          const allSolicitudes = await getAllCombinedSolicitudes();
          const combinedCount = allSolicitudes.filter(s => s.usuario === username).length;
          console.log(`ğŸµ FunciÃ³n combinada: ${combinedCount} solicitudes para ${username}`);
          
          // 5. Mostrar algunas solicitudes de ejemplo
          const userSongs = allSolicitudes.filter(s => s.usuario === username).slice(0, 5);
          console.log(`ğŸ“‹ Primeras 5 solicitudes de ${username}:`, userSongs);
          
          return {
            firestore: firestoreCount,
            localStorage: localCount,
            byDay: byDayCount,
            combined: combinedCount,
            samples: userSongs
          };
          
        } catch (error) {
          console.error(`âŒ Error en diagnÃ³stico para ${username}:`, error);
          return null;
        }
      }

      // FunciÃ³n para validar y corregir datos de gamificaciÃ³n
      function validateAndFixGamificationData(data, username) {
        console.log(`ğŸ” Validando datos de gamificaciÃ³n para ${username}`);
        
        // Asegurar que achievements es un array
        if (!Array.isArray(data.achievements)) {
          data.achievements = [];
          console.log(`âš ï¸ Corrigiendo achievements para ${username}: convertido a array`);
        } else {
          // Deduplicar logros para evitar puntos inflados
          const uniqueAchievements = [...new Set(data.achievements)];
          if (uniqueAchievements.length !== data.achievements.length) {
            console.log(`âš ï¸ Deduplicando achievements para ${username}: ${data.achievements.length} -> ${uniqueAchievements.length}`);
            data.achievements = uniqueAchievements;
          }
        }
        
        // Calcular puntos correctos de logros
        const achievementPoints = data.achievements.reduce((total, achievementId) => {
          const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
          if (!achievement) {
            console.log(`âš ï¸ Logro no encontrado: ${achievementId} para ${username}`);
            return total;
          }
          return total + achievement.points;
        }, 0);
        
        // Asegurar estructura de streaks
        if (!data.streaks || typeof data.streaks !== 'object') {
          data.streaks = {
            current: 0,
            best: 0,
            lastActivity: null,
            calendar: {}
          };
          console.log(`âš ï¸ Corrigiendo streaks para ${username}: estructura recreada`);
        }
        
        // Asegurar estructura de stats
        if (!data.stats || typeof data.stats !== 'object') {
          data.stats = {
            totalSongs: 0,
            uniqueArtists: 0,
            activeDays: 0,
            isVip: false,
            bestStreak: data.streaks.best || 0
          };
          console.log(`âš ï¸ Corrigiendo stats para ${username}: estructura recreada`);
        }
        
        // Asegurar que bestStreak estÃ© en stats
        if (typeof data.stats.bestStreak === 'undefined') {
          data.stats.bestStreak = data.streaks.best || 0;
        }
        
        // CORRECCIÃ“N CRÃTICA: Recalcular puntos totales correctos basado solo en reproducidas
        const safeStats = data.stats || { totalPlayedSongs: 0, isVip: false };
        const songPoints = (safeStats.totalPlayedSongs || 0) * 25; // 25 puntos por canciÃ³n reproducida
        const vipBonus = safeStats.isVip ? ((safeStats.totalPlayedSongs || 0) * 15) : 0; // 15 puntos extra por canciÃ³n si es VIP
        const correctTotalPoints = songPoints + vipBonus + achievementPoints;
        
        // Solo corregir si hay una diferencia significativa
        if (Math.abs(data.points - correctTotalPoints) > 5) {
          console.log(`ğŸ”§ CORRIGIENDO PUNTOS para ${username}:`);
          console.log(`   - Puntos actuales: ${data.points}`);
          console.log(`   - Puntos por canciones reproducidas: ${songPoints} (${safeStats.totalPlayedSongs || 0} Ã— 25)`);
          console.log(`   - Bonus VIP: ${vipBonus}`);
          console.log(`   - Puntos por logros: ${achievementPoints}`);
          console.log(`   - Total correcto: ${correctTotalPoints}`);
          
          data.points = correctTotalPoints;
          data.xp = correctTotalPoints; // XP debe ser igual a puntos totales
        }
        
        console.log(`âœ… ValidaciÃ³n completada para ${username}: ${data.achievements.length} logros, ${achievementPoints} puntos de logros, ${data.points} puntos totales`);
        return achievementPoints;
      }
      function getLocalGamificationData(u) {
        const allStr = localStorage.getItem('gamificationData') || '{}';
        const all = JSON.parse(allStr);
        const key = String(u || '').toLowerCase();
        return all[key] || null;
      }
      if (typeof window.toHourKey !== 'function') {
        window.toHourKey = function(ts) {
          try {
            if (!ts) return '00:00';
            const d = ts?.toDate ? ts.toDate() : new Date(ts);
            const hh = String(d.getHours()).padStart(2,'0');
            const mm = String(d.getMinutes()).padStart(2,'0');
            return `${hh}:${mm}`;
          } catch (_) { return '00:00'; }
        };
      }
      // NUEVA funciÃ³n unificada para contar canciones toggleadas (Reproducidas)
      // Esta funciÃ³n se declara aquÃ­ para estar disponible tanto para computeUserBreakdown como para renderPersonalStatsForUser
      async function countTotalToggledSongsForUser(usuario) {
         try {
           const norm = String(usuario||'').trim().toLowerCase().replace(/^@/,'');
           if (!norm) return 0;
           
           // 0. SHORT-CIRCUIT: Si ya tenemos el set en memoria (mantenido por el listener y updates optimistas), usarlo.
           // Esto es crucial para que el "unmark" se refleje instantÃ¡neamente antes de que llegue a Firestore.
           if (window.__toggleReady && window.__toggleReady[norm] && window.__userToggleSet && window.__userToggleSet[norm]) {
             console.log(`ğŸš€ Usando set en memoria para ${norm}: ${window.__userToggleSet[norm].size}`);
             return window.__userToggleSet[norm].size;
           }

           const sanitize = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
           const prefix = sanitize(`${norm}-`);
           const ids = new Set();
           
           // 1. LocalStorage
           try {
             const localPlayed = JSON.parse(localStorage.getItem('playedSongs') || '{}');
             Object.keys(localPlayed).forEach(day => {
               if (!isOnOrAfterStart(day)) return;
               const arr = Array.isArray(localPlayed[day]) ? localPlayed[day] : [];
               arr.forEach(x => {
                 const id = sanitize(x);
                 if (id.startsWith(prefix)) ids.add(id);
               });
             });
           } catch(e){}

           // 2. Firestore playedSongs
           try {
             const snap = await db.collection('playedSongs').get();
             snap.forEach(doc => {
               const day = doc.id;
               if (!isOnOrAfterStart(day)) return;
               const d = doc.data()||{};
               const arr = Array.isArray(d.songs) ? d.songs : (Array.isArray(d.list) ? d.list : []);
               arr.forEach(x => {
                 const id = sanitize(x);
                 if (id.startsWith(prefix)) ids.add(id);
               });
             });
           } catch(e){}
           
           // 3. System Events (unmark/mark logic)
           try {
             const qs = await db.collection('systemEvents').where('type','==','togglePlayed').where('usuario','==',norm).get();
             const latest = {};
             qs.forEach(doc => {
                const d = doc.data()||{};
                const sid = sanitize(d.songId);
                if (!sid) return;
                const ts = d.ts && d.ts.toMillis ? d.ts.toMillis() : 0;
                const k = sid;
                if (!latest[k] || ts > latest[k].ts) {
                  latest[k] = { action: d.action, ts };
                }
             });
             Object.keys(latest).forEach(sid => {
                if (latest[sid].action === 'mark') ids.add(sid);
                else if (latest[sid].action === 'unmark') ids.delete(sid);
             });
           } catch(e){}

           console.log(`ğŸ”¢ Conteo final (calculado) para ${norm}: ${ids.size}`);
           return ids.size;
         } catch(e) { console.error(e); return 0; }
      }

      const TOP1_BONUS_START_DATE = '2025-12-19';

      async function computeUserBreakdown(u) {
        const rawUser = String(u || '').trim();
        const usuario = rawUser.replace(/^@/, '');
        const norm = (s) => String(s || '').trim().replace(/^@/, '').toLowerCase();
        const unameLc = String(usuario||'').trim().toLowerCase();
        const rawLc = String(rawUser||'').trim().toLowerCase();
        let isVip = (window.vipSet && (window.vipSet.has(unameLc) || window.vipSet.has(rawLc))) || (window.z0VipSet && (window.z0VipSet.has(unameLc) || window.z0VipSet.has(rawLc)));
        const getHourKey = (x) => {
          try {
            if (typeof window.toHourKey === 'function') return window.toHourKey(x);
            if (typeof toHourKey === 'function') return toHourKey(x);
            if (typeof toHour === 'function') return toHour(x);
            return '00:00';
          } catch (_) {
            return '00:00';
          }
        };

        // --- CALCULO DE "TOP 1 DIARIO" ---
        let top1Count = 0;
        try {
           const allReqs = await getAllCombinedSolicitudes();
           // Agrupar por dÃ­a
           const byDay = {};
           allReqs.forEach(s => {
             let d = String(s.day || (s.fecha||'').split('T')[0] || '').trim();
             if (!d) return;
             // Solo considerar desde la fecha de inicio del evento
             if (d < TOP1_BONUS_START_DATE) return;
             
             // No contar el dÃ­a de HOY si no ha terminado (opcional, pero el usuario dijo "cuantas veces ha quedado")
             // Asumiremos que cuenta dÃ­as completados o actuales si ya va ganando.
             // Pero para evitar volatilidad, lo ideal es dÃ­as pasados. 
             // Sin embargo, si es "hoy", el usuario quiere ver si va ganando.
             // Vamos a contar todos los dÃ­as desde START_DATE hasta hoy (inclusive).
             
             if (!byDay[d]) byDay[d] = {};
             const uKey = String(s.usuario||'').trim().replace(/^@/,'').toLowerCase();
             byDay[d][uKey] = (byDay[d][uKey] || 0) + 1;
           });
           
           // Determinar ganador de cada dÃ­a
           Object.keys(byDay).forEach(day => {
              const counts = byDay[day];
              let max = -1;
              let winner = null;
              // Encontrar el maximo
              Object.keys(counts).forEach(user => {
                 if (counts[user] > max) {
                   max = counts[user];
                   winner = user;
                 } else if (counts[user] === max) {
                   // Empate: Â¿ambos ganan? O nadie? O el primero?
                   // Asumiremos empate = ambos ganan (o el sistema elige uno, pero mejor ambos).
                   // Para simplificar, si hay empate con el usuario actual, cuenta.
                   if (user === unameLc) winner = user; 
                 }
              });
              
              if (winner === unameLc && max > 0) {
                 top1Count++;
              }
           });
           
        } catch(e) { console.error('Error calculating Top 1 Bonus:', e); }
        // ---------------------------------
        const daysSet = new Set();
        const perDaySongs = new Map();
        try {
          const userSnap = await db.collection('solicitudes').where('usuario', '==', usuario).get();
          // Construir set de IDs validos de solicitudes para filtrar las reproducidas
          userSnap.forEach(doc => {
            const d = doc.data() || {};
            const day = normalizeDay(d.day || '');
            if (!day) return;
            if (isOnOrAfterStart(day)) daysSet.add(day);
            const arr = perDaySongs.get(day) || [];
            arr.push(d);
            perDaySongs.set(day, arr);
          });
        } catch (_) {}
        try {
          const playedDaysSnap = await db.collection('playedSongs').get();
          playedDaysSnap.forEach(ps => {
            const day = normalizeDay(ps.id);
            if (day && isOnOrAfterStart(day)) daysSet.add(day);
          });
        } catch (_) {}
        
        let playedCount = 0;
        try {
           playedCount = await countTotalToggledSongsForUser(usuario);
        } catch(e) { console.error('Error counting played from toggles:', e); }
        
        let activeDaysValid = 0;
        const playedArtistsSet = new Set();
        const detail = [];
        const days = Array.from(daysSet);
        const totalPlayedSet = new Set();
        // (El resto de la lÃ³gica de totalPlayedSet es redundante ahora, pero la mantengo limpia para evitar romper rachas)
        
        // Iterar dÃ­as SOLO para calcular dÃ­as activos y rachas, NO para recontar canciones
        for (let i = 0; i < days.length; i++) {
          const day = days[i];
          if (!isOnOrAfterStart(day)) continue;
          
          // Obtener canciones reproducidas del dÃ­a para validar actividad
          const playedDoc = await db.collection('playedSongs').doc(day).get();
          const pdata = playedDoc.exists ? (playedDoc.data() || {}) : {};
          const playedArr = Array.isArray(pdata.songs) ? pdata.songs : (Array.isArray(pdata.list) ? pdata.list : (Array.isArray(pdata.songIds) ? pdata.songIds : []));
          
          // Contar canciones del usuario en este dÃ­a especÃ­fico para validar "DÃ­a Activo"
          const cleanLc = (s) => String(s || '').trim().toLowerCase().replace(/[^a-z0-9-]/g, '');
          const userPrefix = `${cleanLc(usuario)}-`;
          let userPlayedThatDay = 0;
          
          for (let k = 0; k < playedArr.length; k++) {
            const x = playedArr[k] || '';
            if (typeof x === 'string' && cleanLc(x).startsWith(userPrefix)) {
              userPlayedThatDay++;
            }
          }
          
          const daySnap = await db.collection('solicitudes').where('day', '==', day).get();
          const distinctUsersDay = new Set();
          daySnap.forEach(dd => {
            const d2 = dd.data() || {};
            if (d2.usuario) distinctUsersDay.add(d2.usuario);
          });
          const validDay = distinctUsersDay.size >= 2 && userPlayedThatDay > 0;
          if (validDay) activeDaysValid++;
          if (userPlayedThatDay > 0) {
            detail.push({ day, played: userPlayedThatDay, distinctUsers: distinctUsersDay.size });
          }
        }
        // Calcular rachas a partir de detail (secuencias consecutivas de dÃ­as con actividad)
        let bestStreakComputed = 0;
        let streakPointsSum = 0;
        try {
          const parseDay = (d) => {
            const [y,m,dd] = String(d||'').split('-').map(Number);
            return new Date(y, (m||1)-1, dd||1);
          };
          const activeDays = detail.map(x => x.day).filter(Boolean).sort();
          // Agrupar en secuencias consecutivas
          let i = 0;
          while (i < activeDays.length) {
            let seqLen = 1;
            let prev = parseDay(activeDays[i]);
            let j = i + 1;
            while (j < activeDays.length) {
              const cur = parseDay(activeDays[j]);
              const diff = (cur - prev) / (1000*60*60*24);
              if (Math.round(diff) === 1) {
                seqLen++;
                prev = cur;
                j++;
              } else {
                break;
              }
            }
            // Mejor racha
            if (seqLen > bestStreakComputed) bestStreakComputed = seqLen;
            // Puntos acumulados por esta racha: sum_{i=1..min(seqLen-1,10)} i * STREAK_MULTIPLIER
            const steps = Math.min(Math.max(seqLen - 1, 0), 10);
            const tri = (steps * (steps + 1)) / 2;
            const mult = (POINTS_CONFIG && typeof POINTS_CONFIG.STREAK_MULTIPLIER === 'number') ? POINTS_CONFIG.STREAK_MULTIPLIER : 2;
            streakPointsSum += tri * mult;
            i = j;
          }
        } catch (_) {}
        const base = playedCount * 25;
        let vipBonus = 0;
        
        // Calcular Bonus VIP respetando fecha de activaciÃ³n
        if (isVip) {
           let vipActivationDate = null;
           if (window.vipMap && window.vipMap.has(unameLc)) {
              vipActivationDate = window.vipMap.get(unameLc).activatedAt;
           } else if (window.vipMap && window.vipMap.has(rawLc)) {
              vipActivationDate = window.vipMap.get(rawLc).activatedAt;
           }
           
           if (vipActivationDate) {
              let vipEligibleSongs = 0;
              detail.forEach(d => {
                 if (d.day >= vipActivationDate) {
                    vipEligibleSongs += d.played;
                 }
              });
              vipBonus = vipEligibleSongs * 40;
              console.log(`ğŸ’ VIP Bonus calculado desde ${vipActivationDate}: ${vipEligibleSongs} canciones (${vipBonus} pts)`);
           } else {
              // Comportamiento legacy: todas las canciones cuentan si no hay fecha
              vipBonus = playedCount * 40;
              // console.log(`ğŸ’ VIP Bonus legacy (sin fecha): ${playedCount} canciones (${vipBonus} pts)`);
           }
        }
        
        let dailyBonus = activeDaysValid * 5;
        const uniqueArtistsPlayed = Array.from(playedArtistsSet).filter(Boolean).length;
        let achievements = 0;
        let streakBonus = 0;
        try {
          const uid = norm(usuario);
          const idSet = new Set();
          // Preferir datos locales para consistencia con la cabecera
          try {
            const localData = getLocalGamificationData(usuario) || {};
            const st = localData.stats || {};
            if (typeof st.activeDays === 'number') activeDaysValid = st.activeDays;
            if (typeof st.isVip === 'boolean') {
              // Recalcular VIP con el flag local
              if (st.isVip) {
                isVip = true;
              }
            }
            // Recalcular partidas con valores locales
            vipBonus = isVip ? playedCount * 40 : 0;
            dailyBonus = activeDaysValid * 5;
            // Ruta rÃ¡pida deshabilitada para asegurar consistencia con nube
            if (false) {
              let fastBestStreak = 0;
              try {
                const bs = st.bestStreak;
                if (typeof bs === 'number') fastBestStreak = bs;
              } catch (_){}
              try {
                if (!fastBestStreak) {
                  const localStreaks = (localData.streaks || {});
                  if (typeof localStreaks.best === 'number') fastBestStreak = localStreaks.best;
                }
              } catch (_){}
              // Bono de racha aproximado por mejor racha
              try {
                const steps = Math.min(Math.max((fastBestStreak || 0) - 1, 0), 10);
                const tri = (steps * (steps + 1)) / 2;
                const mult = (POINTS_CONFIG && typeof POINTS_CONFIG.STREAK_MULTIPLIER === 'number') ? POINTS_CONFIG.STREAK_MULTIPLIER : 2;
                streakBonus = tri * mult;
              } catch (_){}
              // Calcular logros Ãºnicamente desbloqueados (union)
              try {
                const localAch = Array.isArray(localData.achievements) ? localData.achievements : [];
                (localAch || []).forEach(id => idSet.add(String(id)));
              } catch (_){}
              try {
                const statsDoc = await db.collection('userStats').doc(uid).get();
                if (statsDoc.exists) {
                  const sdata = statsDoc.data() || {};
                  const statAch = Array.isArray(sdata.achievements) ? sdata.achievements : [];
                  (statAch || []).forEach(id => idSet.add(String(id)));
                }
              } catch (_){}
              try {
                const achDoc = await db.collection('userAchievements').doc(uid).get();
                if (achDoc.exists) {
                  const a = achDoc.data() || {};
                  const ids = Array.isArray(a.ids) ? a.ids : (Array.isArray(a.achievements) ? a.achievements : (Array.isArray(a.list) ? a.list : []));
                  (ids || []).forEach(id => idSet.add(String(id)));
                }
              } catch (_){}
              achievements = Array.from(idSet).reduce((sum, id) => {
                const found = ACHIEVEMENTS && ACHIEVEMENTS.find ? ACHIEVEMENTS.find(x => x.id === id) : null;
                return sum + (found && typeof found.points === 'number' ? found.points : 0);
              }, 0);
              const fastBase = playedCount * 25;
              const fastVip = isVip ? playedCount * 40 : 0;
              const fastDaily = activeDaysValid * 5;
              const fastSum = fastBase + fastVip + fastDaily + achievements + streakBonus;
              let displayTotal = fastSum;
              return {
                usuario,
                playedCount,
                activeDaysValid,
                isVip,
                base: fastBase,
                vipBonus: fastVip,
                dailyBonus: fastDaily,
                achievements,
                streakBonus,
                residual: 0,
                total: displayTotal,
                detail: [],
                achievementsList: []
              };
            }
          } catch (_){}
          try {
            const achDoc = await db.collection('userAchievements').doc(uid).get();
            if (achDoc.exists) {
              const a = achDoc.data() || {};
              const ids = Array.isArray(a.ids) ? a.ids : (Array.isArray(a.achievements) ? a.achievements : (Array.isArray(a.list) ? a.list : []));
              (ids || []).forEach(id => idSet.add(String(id)));
            }
          } catch (_){}
          try {
            const bestStats = await fetchBestUserStatsDoc(uid);
            if (bestStats && bestStats.data) {
              const sdata = bestStats.data || {};
              const statAch = Array.isArray(sdata.achievements) ? sdata.achievements : [];
              (statAch || []).forEach(id => idSet.add(String(id)));
            }
          } catch (_){}
          try {
            const localData = getLocalGamificationData(usuario) || {};
            const localAch = Array.isArray(localData.achievements) ? localData.achievements : [];
            (localAch || []).forEach(id => idSet.add(String(id)));
          } catch (_){}
          achievements = Array.from(idSet).reduce((sum, id) => {
            const found = ACHIEVEMENTS && ACHIEVEMENTS.find ? ACHIEVEMENTS.find(x => x.id === id) : null;
            return sum + (found && typeof found.points === 'number' ? found.points : 0);
          }, 0);
          // Ensure achievements is never negative
          achievements = Math.max(0, achievements);
        } catch (_) {}
        let cloudTotal = 0;
        let bestStreakVal = 0;
        let lastManualAdjustment = null;
        try {
          const bestStats = await fetchBestUserStatsDoc(usuario);
          const statsDoc = bestStats && bestStats.data ? (bestStats.data || {}) : {};
          cloudTotal = Number((statsDoc.totalPoints || 0));
          if (typeof statsDoc.bestStreak === 'number') bestStreakVal = statsDoc.bestStreak;
          if (statsDoc.lastManualAdjustment) lastManualAdjustment = statsDoc.lastManualAdjustment;
        } catch (_) {}
        // Fallback a localData para bestStreak si no se encontrÃ³ en nube
        try {
          if (!bestStreakVal) {
            const localData = getLocalGamificationData(usuario) || {};
            const streaks = localData.streaks || {};
            if (typeof streaks.best === 'number') bestStreakVal = streaks.best;
          }
        } catch (_) {}
        // Calcular bono acumulado por racha usando secuencias detectadas; si no hay, aproximar por bestStreakVal
        try {
          if (streakPointsSum > 0) {
            streakBonus = streakPointsSum;
          } else {
            const steps = Math.min(Math.max((bestStreakVal || 0) - 1, 0), 10);
            const tri = (steps * (steps + 1)) / 2;
            const mult = (POINTS_CONFIG && typeof POINTS_CONFIG.STREAK_MULTIPLIER === 'number') ? POINTS_CONFIG.STREAK_MULTIPLIER : 2;
            streakBonus = Math.max(0, tri * mult); // Ensure non-negative
          }
        } catch (_) { streakBonus = 0; }
        const top1Bonus = top1Count * 150;
        // Calcular manual bonus
        let manualBonus = 0;
        if (lastManualAdjustment && typeof lastManualAdjustment.amount === 'number') {
           manualBonus = lastManualAdjustment.amount;
        }

        let redemptionsSpent = 0;
        let redemptions = [];
        try {
          const dbRef = window.db || db;
          const userKey = normalizeUserKey(usuario);
          const candidates = Array.from(new Set([rawUser, usuario, unameLc].map(x => String(x || '').trim()).filter(Boolean)));
          const map = new Map();
          try {
            const snapKey = await dbRef.collection('rewardRequests').where('userKey', '==', userKey).get();
            snapKey.forEach(doc => {
              const d = doc.data() || {};
              map.set(doc.id, {
                id: doc.id,
                rewardId: d.rewardId,
                rewardName: d.rewardName,
                cost: Number(d.cost || 0),
                status: String(d.status || ''),
                timestamp: d.timestamp || d.processedAt || ''
              });
            });
          } catch (_) {}
          for (let i = 0; i < candidates.length; i++) {
            const cand = candidates[i];
            try {
              const snap = await dbRef.collection('rewardRequests').where('userId', '==', cand).get();
              snap.forEach(doc => {
                const d = doc.data() || {};
                map.set(doc.id, {
                  id: doc.id,
                  rewardId: d.rewardId,
                  rewardName: d.rewardName,
                  cost: Number(d.cost || 0),
                  status: String(d.status || ''),
                  timestamp: d.timestamp || d.processedAt || ''
                });
              });
            } catch (_) {}
          }
          redemptions = Array.from(map.values()).sort((a, b) => new Date(b.timestamp || 0) - new Date(a.timestamp || 0));
          redemptionsSpent = redemptions
            .filter(r => r && (r.status === 'pending' || r.status === 'approved'))
            .reduce((sum, r) => sum + Math.max(0, Number(r.cost || 0)), 0);
        } catch (_) {}

        const earnedTotal = (playedCount * 25) + (isVip ? (playedCount * 40) : 0) + (activeDaysValid * 5) + achievements + streakBonus + top1Bonus + manualBonus;
        const predictedNet = earnedTotal - redemptionsSpent;
        
        // --- COHERENCIA GLOBAL: Usar siempre el cÃ¡lculo reconstruido como verdad ---
        // Si el historial (playedSongs + requests) dice X, entonces es X.
        // Ignoramos el valor cacheado 'cloudTotal' para el display, pero lo actualizamos si difiere.
        const displayTotal = Math.max(0, predictedNet);
        const adjustment = 0; 

        try {
          // Sincronizar con Firebase si hay discrepancia para que otros dispositivos vean el dato actualizado
          if (window.__ALLOW_BREAKDOWN_WRITE__) {
            const diff = Math.abs(Number(cloudTotal || 0) - displayTotal);
            if (diff > 0.1 || !cloudTotal) {
                const docRef = db.collection('userStats').doc(norm(usuario));
                // Guardamos desglose completo para debugging y coherencia
                await docRef.set({
                  totalPoints: displayTotal,
                  breakdown: {
                    base: (playedCount * 25),
                    vip: (isVip ? (playedCount * 40) : 0),
                    daily: (activeDaysValid * 5),
                    achievements: achievements,
                    streak: streakBonus,
                    top1: top1Bonus,
                    manual: manualBonus,
                    spent: redemptionsSpent
                  },
                  lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                  updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                cloudTotal = displayTotal;
            }
          }
        } catch (e) { console.error('Error syncing points to cloud:', e); }
        // Construir lista de insignias para UI
        let achievementsList = [];
        try {
          const achCatalog = Array.isArray(ACHIEVEMENTS) ? ACHIEVEMENTS : [];
          // Usar los IDs encontrados arriba
          const uid = norm(usuario);
          const idSet = new Set();
          try {
            const achDoc = await db.collection('userAchievements').doc(uid).get();
            if (achDoc.exists) {
              const a = achDoc.data() || {};
              const ids = Array.isArray(a.ids) ? a.ids : (Array.isArray(a.achievements) ? a.achievements : (Array.isArray(a.list) ? a.list : []));
              (ids || []).forEach(id => idSet.add(String(id)));
            }
          } catch (_){}
          try {
            const statsDoc2 = await db.collection('userStats').doc(uid).get();
            if (statsDoc2.exists) {
              const sdata2 = statsDoc2.data() || {};
              const statAch = Array.isArray(sdata2.achievements) ? sdata2.achievements : [];
              (statAch || []).forEach(id => idSet.add(String(id)));
            }
          } catch (_){}
          try {
            const localData = getLocalGamificationData(usuario) || {};
            const localAch = Array.isArray(localData.achievements) ? localData.achievements : [];
            (localAch || []).forEach(id => idSet.add(String(id)));
          } catch (_){}
          achievementsList = Array.from(idSet).map(id => {
            const found = achCatalog.find(x => x && x.id === id);
            return { id, title: (found && found.title) || id, points: (found && typeof found.points === 'number') ? found.points : 0 };
          });
        } catch (_){}
        return {
          usuario,
          playedCount,
          activeDaysValid,
          isVip,
          base: (playedCount * 25),
          vipBonus: (isVip ? (playedCount * 40) : 0),
          dailyBonus: (activeDaysValid * 5),
          achievements,
          streakBonus,
          top1Count,
          top1Bonus,
          manualBonus,
          cloudTotal: Math.max(0, Number(cloudTotal || 0)),
          earnedTotal: Math.max(0, Number(earnedTotal || 0)),
          redemptionsSpent: Math.max(0, Number(redemptionsSpent || 0)),
          redemptions: redemptions || [],
          adjustment: Number(adjustment || 0),
          total: Math.max(0, Number(displayTotal || 0)),
          detail,
          achievementsList,
          redemptions
        };
      }
      async function renderPointsBreakdownForUser(u, force=false) {
        // Cache simple para mejorar tiempos de carga
        window.__breakdownCache = window.__breakdownCache || {};
        const key = String(u||'').toLowerCase();
        const now = Date.now();
        const cached = window.__breakdownCache[key];
        let bd;
        // Render rÃ¡pido con conteo consistente (uniÃ³n de fuentes)
        try {
          const quickTotalPlayed = await countTotalToggledSongsForUser(u);
          const quickBase = Number(quickTotalPlayed||0) * 25;
          const setNum = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = String(val); };
          setNum('breakdown-played-base', quickBase);
          setNum('breakdown-vip-bonus', 0);
          setNum('breakdown-daily-bonus', 0);
          setNum('breakdown-achievements', 0);
          setNum('breakdown-streak-residual', 0);
        } catch (_){}
        if (!force && cached && (now - cached.updatedAt) < 5000) { // Reduced from 30000 to 5000 for faster updates
          bd = cached.data;
        } else {
          bd = await computeUserBreakdown(u);
          window.__breakdownCache[key] = { updatedAt: now, data: bd };
        }
        const activePanel = document.getElementById('gamification-breakdown');
        const currentUserAtPaint = getCurrentProfileUser();
        if (!activePanel || !activePanel.classList.contains('active') || String(currentUserAtPaint||'').toLowerCase() !== key) {
          return;
        }
        const setNum = (id, val) => {
          const el = document.getElementById(id);
          if (el) el.textContent = String(val);
        };
          // --- Transparencia: recalcular con conteo consistente ---
          try {
             const totalPlayed = await countTotalToggledSongsForUser(u);
             bd.playedCount = totalPlayed;
             bd.base = totalPlayed * 25;
             bd.vipBonus = bd.isVip ? (totalPlayed * 40) : 0;
             
             const earnedTotal = bd.base + (bd.vipBonus||0) + (bd.dailyBonus||0) + (bd.achievements||0) + (bd.streakBonus||0) + (bd.top1Bonus||0) + (bd.manualBonus||0);
             const predictedNet = earnedTotal - Number(bd.redemptionsSpent || 0);
             bd.earnedTotal = earnedTotal;
             // --- COHERENCIA: Usar cÃ¡lculo real ---
             bd.adjustment = 0; 
             bd.total = Math.max(0, predictedNet);
             
          } catch(e) { console.error('Error actualizando transparencia con conteo consistente:', e); }

        setNum('breakdown-played-base', Number(bd.base||0));
        setNum('breakdown-vip-bonus', Number(bd.vipBonus||0));
        setNum('breakdown-daily-bonus', Number(bd.dailyBonus||0));
        const achPlus = Number(bd.achievements||0) + Number(bd.streakBonus||0) + Number(bd.top1Bonus||0) + Number(bd.manualBonus||0) + Number(bd.adjustment||0);
        setNum('breakdown-achievements', Number(achPlus||0));
        const red = -Math.max(0, Number(bd.redemptionsSpent || 0));
        setNum('breakdown-streak-residual', String(red));
        setNum('breakdown-total', Number(bd.total||0));
        bd.playedCount = Number(bd.playedCount || Math.floor(Number(bd.base||0)/25));
        const headerPoints = document.getElementById('user-points');
        if (headerPoints) headerPoints.textContent = String(Number(bd.total||0));
        const rewardsPoints = document.getElementById('rewards-user-points');
        if (rewardsPoints) rewardsPoints.textContent = String(Number(bd.total||0));
        const list = document.getElementById('breakdown-detail-list');
        if (list) {
          const lines = [];
          
          // Canciones
          lines.push(`<div class="genre-chip"><span>ğŸµ Canciones </span><span>${bd.playedCount} Ã— 25 = ${bd.base}</span></div>`);
          
          // VIP (solo si es VIP)
          if (bd.isVip) {
            lines.push(`<div class="genre-chip"><span>ğŸ‘‘ VIP </span><span>${bd.playedCount} Ã— 40 = ${bd.vipBonus}</span></div>`);
          }
          
          // Diario
          lines.push(`<div class="genre-chip"><span>ğŸ“… Diario </span><span>${bd.activeDaysValid} Ã— 5 = ${bd.dailyBonus}</span></div>`);
          
          // Top 1 Diario (Nuevo)
          if (bd.top1Bonus > 0) {
             lines.push(`<div class="genre-chip"><span>ğŸ† Top 1 Diario </span><span>${bd.top1Count} Ã— 150 = ${bd.top1Bonus}</span></div>`);
          }
          
          // Rachas (solo si hay puntos)
          if (bd.streakBonus > 0) {
            lines.push(`<div class="genre-chip"><span>ğŸ”¥ Rachas </span><span>${bd.streakBonus}</span></div>`);
          }
          
          // Logros (solo si hay puntos)
          if (bd.achievements > 0) {
            lines.push(`<div class="genre-chip"><span>ğŸ… Logros </span><span>${bd.achievements}</span></div>`);
          }

          // CompensaciÃ³n (si existe)
          if (bd.manualBonus && bd.manualBonus !== 0) {
            lines.push(`<div class="genre-chip"><span>ğŸ CompensaciÃ³n </span><span>${bd.manualBonus}</span></div>`);
          }

          if (Number(bd.redemptionsSpent || 0) > 0 || (Array.isArray(bd.redemptions) && bd.redemptions.length > 0)) {
            lines.push(`<div class="genre-chip"><span>ğŸ Canjes </span><span>-${Number(bd.redemptionsSpent || 0)}</span></div>`);
            try {
              const statusText = (s) => s === 'approved' ? 'Aprobado' : (s === 'rejected' ? 'Rechazado' : 'Pendiente');
              const listRed = Array.isArray(bd.redemptions) ? bd.redemptions : [];
              listRed.slice(0, 10).forEach(r => {
                if (!r || !r.cost) return;
                const st = statusText(String(r.status || 'pending'));
                const cost = Math.max(0, Number(r.cost || 0));
                const sign = (r.status === 'rejected') ? '+' : '-';
                lines.push(`<div class="genre-chip"><span>â€¢ ${r.rewardName || r.rewardId || 'Recompensa'} (${st})</span><span>${sign}${cost}</span></div>`);
              });
            } catch (_) {}
          }

          if (Number(bd.adjustment || 0) !== 0) {
            const adj = Number(bd.adjustment || 0);
            const sign = adj > 0 ? '+' : '';
            lines.push(`<div class="genre-chip"><span>ğŸ§© Ajuste </span><span>${sign}${adj}</span></div>`);
          }
          
          // Total
          lines.push(`<div class="genre-chip"><span>ğŸ’° Total </span><span>${bd.total}</span></div>`);
          
          list.innerHTML = lines.join('');
        }
        // Reintento ligero si base quedÃ³ en 0 pero existe total positivo
        try {
          if ((bd.base === 0 || bd.playedCount === 0) && bd.total > 0 && !force) {
            const again = await computeUserBreakdown(u);
            if (again && (again.base > bd.base || again.playedCount > bd.playedCount)) {
              window.__breakdownCache[key] = { updatedAt: Date.now(), data: again };
              return renderPointsBreakdownForUser(u, true);
            }
          }
        } catch (_){}
      }
      window.__ALLOW_BREAKDOWN_WRITE__ = true;
      function getCurrentProfileUser() {
        const sel = document.getElementById('gamification-user-select');
        const v = sel ? String(sel.value || '').trim().replace(/^@/, '') : '';
        if (v) return v;
        const cur = localStorage.getItem('currentUser') || '';
        const fallback = (cur || '').replace(/^@/, '');
        if (fallback) return fallback;
        try {
          if (typeof getCurrentSelectedUser === 'function') {
            const s = String(getCurrentSelectedUser() || '').trim().replace(/^@/, '');
            if (s) return s;
          }
          if (typeof getCurrentUser === 'function') {
            const u = String(getCurrentUser() || '').trim().replace(/^@/, '');
            if (u) return u;
          }
        } catch (_){}
        return '';
      }
      (function setupBreakdownTab(){
        document.addEventListener('click', async function(e){
          const btn = e.target && e.target.closest('.gamification-tab');
          if (!btn) return;
          const tab = btn.getAttribute('data-tab') || '';
          const panels = document.querySelectorAll('.gamification-panel');
          panels.forEach(p => p.classList.remove('active'));
          const activePanel = document.getElementById('gamification-' + tab);
          if (activePanel) activePanel.classList.add('active');
          const tabs = document.querySelectorAll('.gamification-tab');
          tabs.forEach(t => t.classList.remove('active'));
          btn.classList.add('active');
          if (tab === 'breakdown') {
            const u = getCurrentProfileUser();
            if (u) {
              // Limpiar valores visuales para evitar ver datos viejos
              ['breakdown-played-base','breakdown-vip-bonus','breakdown-daily-bonus','breakdown-achievements','breakdown-streak-residual','breakdown-total'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = '-';
              });
              await renderPointsBreakdownForUser(u, true);
            }
          }
          if (tab === 'stats') {
            const u = getCurrentProfileUser();
            if (u) {
              try {
                const localData = getLocalGamificationData(u) || {};
                await renderPersonalStatsForUser(localData, u);
                startCloudRealtimeForUser(u);
              } catch (_){
                const ids = ['personal-total-songs','personal-unique-artists','personal-active-days','personal-rank'];
                ids.forEach(id => { const el = document.getElementById(id); if (el) el.textContent = id==='personal-rank' ? '-' : '0'; });
              }
            }
          }
        });
        const sel = document.getElementById('gamification-user-select');
        if (sel) {
          sel.addEventListener('change', async function(){
            const panel = document.getElementById('gamification-breakdown');
            if (panel && panel.classList.contains('active')) {
              const u = getCurrentProfileUser();
              if (u) await renderPointsBreakdownForUser(u, true);
            }
            const statsPanel = document.getElementById('gamification-stats');
            if (statsPanel && statsPanel.classList.contains('active')) {
              const u = getCurrentProfileUser();
              if (u) {
                try {
                  const localData = getLocalGamificationData(u) || {};
                  await renderPersonalStatsForUser(localData, u);
                  startCloudRealtimeForUser(u);
                } catch (_){}
              }
            }
          });
        }
      })();
      function countLocalPlayedForUser(usuario) {
        const norm = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
        const localPlayedMap = JSON.parse(localStorage.getItem('playedSongs') || '{}');
        const sanitize = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
        const prefix = sanitize(`${norm}-`);
        const ids = new Set();
        const days = Object.keys(localPlayedMap);
        for (let i=0;i<days.length;i++) {
          if (!isOnOrAfterStart(days[i])) continue;
          const arr = Array.isArray(localPlayedMap[days[i]]) ? localPlayedMap[days[i]] : [];
          for (let j=0;j<arr.length;j++) {
            const id = sanitize(arr[j]);
            if (id.startsWith(prefix)) ids.add(id);
          }
        }
        return ids.size;
      }
      function computeLocalSolicitudesStats(usuario) {
        const norm = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
        const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
        const mine = solicitudes.filter(s => {
          const okUser = String(s.usuario||'').trim().replace(/^@/,'').toLowerCase() === norm;
          const d = String(s.day || (s.fecha||'').split('T')[0] || '').trim();
          return okUser && (!d || isOnOrAfterStart(d));
        });
        const totalSongs = mine.length;
        const uniqueArtists = new Set(mine.map(s => s.artista).filter(Boolean)).size;
        const days = new Set(mine.map(s => String(s.day || (s.fecha||'').split('T')[0] || '').trim()).filter(d => d && isOnOrAfterStart(d)));
        const activeDays = days.size;
        return { totalSongs, uniqueArtists, activeDays };
      }
      function stableSetStat(id, val, usuario) {
        const el = document.getElementById(id);
        if (!el) return;
        const nextNum = Number(val || 0);
        el.textContent = String(nextNum);
      }
      function setPlayedStat(val) {
        const el = document.getElementById('personal-total-played');
        if (!el) return;
        const cur = Number(el.textContent || 0);
        const next = Number(val || 0);
        try {
          const u = typeof getCurrentProfileUser === 'function' ? String(getCurrentProfileUser()||'').toLowerCase() : '';
          const ready = window.__toggleReady && window.__toggleReady[u];
          if (!ready && next === 0 && cur > 0) return;
        } catch(_){ }
        el.textContent = String(next);
      }
      function stableSetRank(id, userRank, usuario) {
        const el = document.getElementById(id);
        if (!el) return;
        el.textContent = userRank > 0 ? `#${userRank}` : '-';
      }
      window.__userSubs = window.__userSubs || {};
      function unsubscribeUserRealtime() {
        const subs = window.__userSubs;
        try { subs.solicitudes && subs.solicitudes(); } catch (_){}
        try { subs.played && subs.played(); } catch (_){}
        try { subs.allSolicitudes && subs.allSolicitudes(); } catch (_){}
        window.__userSubs = {};
      }
      function startCloudRealtimeForUser(usuario) {
        unsubscribeUserRealtime();
        const u = String(usuario||'').trim().replace(/^@/,'');
        const norm = u.toLowerCase();
        const sanitize = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
        window.__userReqPrefixes = window.__userReqPrefixes || {};
        window.__userReqPrefixes[norm] = new Set();
        
        let localRequests = new Set();
        let localPlayedSnapshot = null;
        window.__userToggleSet = window.__userToggleSet || {};
        window.__userToggleSet[norm] = window.__userToggleSet[norm] || new Set();

        const recalcPlayed = () => {
          if (!localPlayedSnapshot) return;
          const prefix = sanitize(`${u}-`);
          const ids = new Set();
          
          // Solo procesar si tenemos requests cargados para validar
          const hasRequests = localRequests && localRequests.size > 0;
          
          // 1. Incorporar datos de Firestore (Snapshot)
          localPlayedSnapshot.forEach(doc => {
            const dayId = String(doc.id||'');
            if (!isOnOrAfterStart(dayId)) return;
            const d = doc.data()||{};
            const arr = Array.isArray(d.songs) ? d.songs : (Array.isArray(d.list) ? d.list : (Array.isArray(d.songIds) ? d.songIds : []));
            arr.forEach(x => {
              const id = sanitize(x);
              if (id.startsWith(prefix)) { 
                 ids.add(id); 
              }
            });
          });

          // 2. Incorporar datos de LocalStorage (Prioridad local)
          try {
            const localPlayedMap = JSON.parse(localStorage.getItem('playedSongs') || '{}');
            Object.keys(localPlayedMap).forEach(day => {
               if (!isOnOrAfterStart(day)) return;
               const arr = Array.isArray(localPlayedMap[day]) ? localPlayedMap[day] : [];
               arr.forEach(x => {
                   const id = sanitize(x);
                   if (id.startsWith(prefix)) {
                      ids.add(id);
                   }
               });
            });
          } catch(_){}

          // Actualizar el Set global y la UI
          window.__userToggleSet[norm] = ids;
          window.__toggleReady = window.__toggleReady || {};
          window.__toggleReady[norm] = true;
          
          setPlayedStat(ids.size);

          // NEW: Actualizar tambiÃ©n la secciÃ³n de Transparencia (Breakdown) si estÃ¡ visible
          const bdPanel = document.getElementById('gamification-breakdown');
          if (bdPanel && bdPanel.classList.contains('active')) {
             // Verificar que estamos viendo el perfil de este usuario
             const curProfile = getCurrentProfileUser();
             if (curProfile && String(curProfile).toLowerCase() === norm) {
                renderPointsBreakdownForUser(u, true).catch(()=>{});
             }
          }
        };

        try {
          window.__userSubs.solicitudes = db.collection('solicitudes').where('usuario','==',u).onSnapshot(snap => {
            let totalSongs = 0;
            const artists = new Set();
            const days = new Set();
            const reqIds = new Set();
            snap.forEach(doc => {
              const d = doc.data()||{};
              const day = String(d.day || (d.fecha||'').split('T')[0] || '').trim();
              if (day && !isOnOrAfterStart(day)) return;
              totalSongs++;
              if (d.artista) artists.add(String(d.artista));
              if (day) days.add(day);
              
              // Construir ID esperado
              const hora = (window.resolveHourKey ? window.resolveHourKey(d.ts) : '00:00') || (window.resolveHourKey ? window.resolveHourKey(d.time) : '00:00') || String(d.hora||'').trim() || '00:00';
              const rid = `${d.usuario}-${d.cancion}-${d.artista}-${hora}`.replace(/[^a-zA-Z0-9-]/g,'');
              
              // NEW: TambiÃ©n agregar versiÃ³n sin hora para fallback, por si acaso el formato de hora cambiÃ³
              const ridNoHour = `${d.usuario}-${d.cancion}-${d.artista}`.replace(/[^a-zA-Z0-9-]/g,'');
              
              const sid = sanitize(rid);
              reqIds.add(sid);
              reqIds.add(sanitize(ridNoHour)); // Agregar al set de validaciÃ³n
            });
            
            localRequests = reqIds;
            window.__userReqPrefixes[norm] = reqIds; // Backup
            stableSetStat('personal-total-songs', totalSongs, u);
            stableSetStat('personal-unique-artists', artists.size, u);
            stableSetStat('personal-active-days', days.size, u);
            
            // Recalcular played con la nueva lista de solicitudes
            if (localPlayedSnapshot) recalcPlayed();
          });
        } catch (_){}
        try {
          window.__userSubs.played = db.collection('playedSongs').onSnapshot(snap => {
            localPlayedSnapshot = snap;
            // Si ya tenemos requests, filtramos. Si no, esperamos a que lleguen (el snapshot de solicitudes llega casi junto)
            if (localRequests.size > 0 || (window.__userReqPrefixes[norm] && window.__userReqPrefixes[norm].size > 0)) {
               if (localRequests.size === 0 && window.__userReqPrefixes[norm]) localRequests = window.__userReqPrefixes[norm];
               recalcPlayed();
            } else {
               // Primera carga: intentar recalcular sin filtro estricto si estÃ¡ vacÃ­o, o esperar?
               // Si localRequests estÃ¡ vacÃ­o, recalcPlayed devuelve todo.
               // Mejor esperar un poco o confiar en el estado inicial
               recalcPlayed(); 
            }
          });
        } catch (_){}
        try {
          window.__userSubs.allSolicitudes = db.collection('solicitudes').onSnapshot(snap => {
            const counts = {};
            snap.forEach(doc => {
              const d = doc.data()||{};
              const day = String(d.day || (d.fecha||'').split('T')[0] || '').trim();
              if (day && !isOnOrAfterStart(day)) return;
              const key = String(d.usuario||'').trim().replace(/^@/,'').toLowerCase();
              counts[key] = (counts[key]||0)+1;
            });
            const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
            const rank = sorted.findIndex(([name])=>name===norm)+1;
            stableSetRank('personal-rank', rank, u);
          });
        } catch (_){}
        try {
          window.__userSubs.toggleEvents = db.collection('systemEvents')
            .where('type','==','togglePlayed')
            .where('usuario','==',String(u||'').trim().replace(/^@/,'').toLowerCase())
            .onSnapshot(snap => {
              const latest = {};
              snap.forEach(doc => {
                const d = doc.data()||{};
                const sid = sanitize(String(d.songId||''));
                if (!sid) return;
                const day = String(d.day || '');
                const ts = d.ts && d.ts.toMillis ? d.ts.toMillis() : 0;
                const action = String(d.action||'').toLowerCase();
                const key = `${sid}|${day}`;
                const cur = latest[key];
                if (!cur || ts >= cur.ts) latest[key] = { action, ts, sid, day };
              });
              const set = new Set();
              Object.keys(latest).forEach(k => {
                const it = latest[k];
                if (it && it.action === 'mark') set.add(it.sid);
              });
              window.__userToggleSet = window.__userToggleSet || {};
              window.__userToggleSet[norm] = set;
              window.__toggleReady = window.__toggleReady || {};
              window.__toggleReady[norm] = true;
              try { setPlayedStat(set.size); } catch(_){ }
              recalcPlayed();
            });
        } catch(_){ }
        try { backfillToggleEventsForUser(u); } catch(_){ }
      }
      async function recountToggleTotalsForUser(usuario, startDay = '', endDay = '') {
        try {
          const user = String(usuario||'').trim().replace(/^@/,'').toLowerCase();
          const lo = startDay ? String(startDay).trim() : '';
          const hi = endDay ? String(endDay).trim() : '';
          const qs = await db.collection('systemEvents').where('type','==','togglePlayed').where('usuario','==',user).get();
          const latest = {};
          qs.forEach(doc => {
            const d = doc.data()||{};
            const day = String(d.day||'');
            if (lo && day && day < lo) return;
            if (hi && day && day > hi) return;
            const sid = String(d.songId||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
            if (!sid) return;
            const ts = d.ts && d.ts.toMillis ? d.ts.toMillis() : 0;
            const key = `${sid}|${day}`;
            const cur = latest[key];
            if (!cur || ts >= cur.ts) latest[key] = { action: String(d.action||'').toLowerCase(), ts, sid, day };
          });
          const set = new Set();
          Object.keys(latest).forEach(k => { const it = latest[k]; if (it.action === 'mark') set.add(it.sid); });
          // Union con playedSongs por dÃ­a para capturar IDs ya marcadas histÃ³ricamente
          try {
            const snap = await db.collection('playedSongs').get();
            snap.forEach(doc => {
              const dayId = String(doc.id||'');
              if (lo && dayId && dayId < lo) return;
              if (hi && dayId && dayId > hi) return;
              const d = doc.data()||{};
              const arr = Array.isArray(d.songs) ? d.songs : (Array.isArray(d.list) ? d.list : (Array.isArray(d.songIds) ? d.songIds : []));
              const skippedArr = Array.isArray(d.skipped) ? d.skipped : [];
              const skippedSet = new Set((skippedArr || []).map(x => String(x || '').toLowerCase().replace(/[^a-z0-9-]/g,'')));
              (arr||[]).forEach(x => {
                const id = String(x||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
                if (id.startsWith(`${user}-`)) set.add(id);
              });
              skippedSet.forEach((sid) => { if (sid && sid.startsWith(`${user}-`)) set.delete(sid); });
            });
          } catch(_){ }
          const total = set.size;
          const ref = db.collection('playedSongs').doc('userTotals');
          await ref.set({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp(), totals: {} }, { merge: true });
          const payload = {}; payload[`totals.${user}`] = total; await ref.set(payload, { merge: true });
          window.__userToggleSet = window.__userToggleSet || {}; window.__userToggleSet[user] = set;
          window.__toggleReady = window.__toggleReady || {}; window.__toggleReady[user] = true;
          try { setPlayedStat(total); } catch(_){ }
          return { user, total };
        } catch (err) {
          console.error('Error en recountToggleTotalsForUser:', err);
          return { user: String(usuario||'').trim(), total: 0, error: String(err) };
        }
      }
      async function recountToggleTotalsAll(startDay = '', endDay = '') {
        try {
          const lo = startDay ? String(startDay).trim() : '';
          const hi = endDay ? String(endDay).trim() : '';
          const qs = await db.collection('systemEvents').where('type','==','togglePlayed').get();
          const latest = {};
          qs.forEach(doc => {
            const d = doc.data()||{};
            const user = String(d.usuario||'').toLowerCase();
            const day = String(d.day||'');
            if (lo && day && day < lo) return;
            if (hi && day && day > hi) return;
            const sid = String(d.songId||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
            if (!sid || !user) return;
            const ts = d.ts && d.ts.toMillis ? d.ts.toMillis() : 0;
            const key = `${user}|${sid}|${day}`;
            const cur = latest[key];
            if (!cur || ts >= cur.ts) latest[key] = { user, action: String(d.action||'').toLowerCase(), ts, sid, day };
          });
          const totals = {}; const sets = {};
          Object.keys(latest).forEach(k => {
            const it = latest[k]; if (!it || it.action !== 'mark') return;
            const u = it.user; sets[u] = sets[u] || new Set(); sets[u].add(it.sid);
          });
          // Union con playedSongs por dÃ­a para cada usuario
          try {
            const snap = await db.collection('playedSongs').get();
            snap.forEach(doc => {
              const dayId = String(doc.id||'');
              if (lo && dayId && dayId < lo) return;
              if (hi && dayId && dayId > hi) return;
              const d = doc.data()||{};
              const arr = Array.isArray(d.songs) ? d.songs : (Array.isArray(d.list) ? d.list : (Array.isArray(d.songIds) ? d.songIds : []));
              const skippedArr = Array.isArray(d.skipped) ? d.skipped : [];
              const skippedSet = new Set((skippedArr || []).map(x => String(x || '').toLowerCase().replace(/[^a-z0-9-]/g,'')));
              (arr||[]).forEach(x => {
                const id = String(x||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
                const u = id.split('-')[0] || '';
                if (!u) return;
                sets[u] = sets[u] || new Set();
                if (!skippedSet.has(id)) sets[u].add(id);
              });
            });
          } catch(_){ }
          Object.keys(sets).forEach(u => { totals[u] = sets[u].size; });
          const ref = db.collection('playedSongs').doc('userTotals');
          await ref.set({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp(), totals }, { merge: true });
          window.__userToggleSet = window.__userToggleSet || {}; Object.keys(sets).forEach(u => { window.__userToggleSet[u] = sets[u]; });
          return { users: Object.keys(totals).length };
        } catch (err) {
          console.error('Error en recountToggleTotalsAll:', err);
          return { users: 0, error: String(err) };
        }
      }
      (function attachRebuildButton(){
        const btn = document.getElementById('rebuild-played-btn');
        if (!btn) return;
        function showToast(message, type='info') {
          let container = document.getElementById('toast-container');
          if (!container) {
            container = document.createElement('div');
            container.id = 'toast-container';
            document.body.appendChild(container);
          }
          const toast = document.createElement('div');
          toast.className = `toast toast-${type}`;
          toast.textContent = String(message||'');
          container.appendChild(toast);
          requestAnimationFrame(() => toast.classList.add('show'));
          setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 200);
          }, 3500);
        }
        btn.addEventListener('click', async () => {
          const uInput = document.getElementById('rebuild-user-input');
          const startInput = document.getElementById('rebuild-start-day');
          const endInput = document.getElementById('rebuild-end-day');
          const mode = uInput ? String(uInput.value||'').trim() : '';
          const dStart = startInput ? String(startInput.value||'').trim() : '';
          const dEnd = endInput ? String(endInput.value||'').trim() : '';
          let res;
          btn.disabled = true;
          showToast('Recontando canciones toggleadasâ€¦', 'info');
          if (mode) {
            res = await recountToggleTotalsForUser(mode, dStart, dEnd);
          } else {
            res = await recountToggleTotalsAll(dStart, dEnd);
          }
          if (res && !res.error) {
            const msg = res.total ? `Recuento para ${mode}: ${res.total}` : `Recuento global: ${res.users} usuarios`;
            showToast(msg, 'success');
          } else {
            const msg = res && res.error ? res.error : 'Recuento parcial';
            showToast(msg, 'warning');
          }
          btn.disabled = false;
        });
      })();

      (function attachSetMasterDJ(){
        const btn = document.getElementById('set-master-dj');
        if (!btn) return;

        // Actualizar estado visual del botÃ³n al cargar
        const updateBtnState = () => {
            const isDJ = localStorage.getItem('isMasterDJDevice') === 'true';
            btn.innerHTML = isDJ 
              ? 'ğŸ›ï¸ Liberar Control DJ (Modo Solo Lectura)' 
              : 'ğŸ›ï¸ Establecer ESTE dispositivo como DJ Maestro';
            btn.style.background = isDJ ? '#dc3545' : '#6610f2'; // Rojo para soltar, PÃºrpura para tomar
        };
        updateBtnState();

        btn.addEventListener('click', async () => {
            const isCurrentlyDJ = localStorage.getItem('isMasterDJDevice') === 'true';
            
            if (isCurrentlyDJ) {
                // Desactivar modo DJ
                if (!confirm('Â¿Liberar control DJ? Los botones de las canciones se podrÃ¡n presionar pero NO cambiarÃ¡n el estado.')) return;
                localStorage.setItem('isMasterDJDevice', 'false');
                alert('âœ… Control liberado. Modo "Invitado" activo.');
                location.reload();
            } else {
                // Activar modo DJ
                if (!confirm('Â¿Tomar control DJ? PodrÃ¡s marcar canciones como reproducidas.')) return;
                
                try {
                    const currentFingerprint = generateDeviceFingerprint();
                    if (window.db) {
                        await window.db.collection('systemConfig').doc('djConfig').set({
                          masterFingerprint: currentFingerprint,
                          lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                    
                    localStorage.setItem('masterDJFingerprint', currentFingerprint);
                    localStorage.setItem('isMasterDJDevice', 'true');
                    alert('âœ… Control DJ asignado. Modo "Admin" activo.');
                    // Forzar actualizaciÃ³n de UI
                    if (typeof updateDJControls === 'function') updateDJControls();
                    location.reload();
                } catch (e) {
                    console.error(e);
                    alert('âŒ Error al asignar control: ' + e.message);
                }
            }
        });
      })();
      
      // FunciÃ³n para corregir puntos de todos los usuarios
      window.corregirPuntosTodosLosUsuarios = async function() {
        console.log('ğŸ”§ INICIANDO CORRECCIÃ“N MASIVA DE PUNTOS...');
        
        try {
          // Obtener todos los usuarios Ãºnicos
          const allUsers = new Set();
          
          // Usuarios de localStorage
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          localSolicitudes.forEach(sol => {
            if (sol.usuario && sol.usuario.trim()) {
              allUsers.add(sol.usuario.trim());
            }
          });
          
          // Usuarios de Firebase
          try {
            const solicitudesSnap = await db.collection('solicitudes').get();
            solicitudesSnap.forEach(doc => {
              const { usuario } = doc.data();
              if (usuario && usuario.trim()) allUsers.add(usuario.trim());
            });
          } catch (error) {
            console.warn('Error obteniendo usuarios de Firebase:', error);
          }
          
          console.log(`ğŸ“Š Corrigiendo puntos para ${allUsers.size} usuarios...`);
          
          let correctedCount = 0;
          for (const username of allUsers) {
            try {
              let data = getGamificationDataForUser(username);
              const oldPoints = data.points;
              
              // Validar y corregir datos
              validateAndFixGamificationData(data, username);
              
              // Guardar datos corregidos
              saveGamificationDataForUser(data, username);
              
              if (oldPoints !== data.points) {
                correctedCount++;
                console.log(`âœ… ${username}: ${oldPoints} â†’ ${data.points} puntos`);
              }
            } catch (error) {
              console.error(`âŒ Error corrigiendo ${username}:`, error);
            }
          }
          
          console.log(`ğŸ‰ CORRECCIÃ“N COMPLETADA: ${correctedCount} usuarios corregidos de ${allUsers.size} totales`);
          alert(`CorrecciÃ³n completada: ${correctedCount} usuarios tuvieron sus puntos corregidos.`);
          
          return { total: allUsers.size, corrected: correctedCount };
        } catch (error) {
          console.error('Error en correcciÃ³n masiva:', error);
          alert('Error durante la correcciÃ³n. Revisa la consola para mÃ¡s detalles.');
        }
      };
      
      // FunciÃ³n simple para correcciÃ³n inmediata (sin async)
      window.corregirPuntosRapido = function() {
        console.log('âš¡ CORRECCIÃ“N RÃPIDA DE PUNTOS...');
        
        try {
          // Obtener todos los usuarios de localStorage
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const allUsers = new Set();
          
          localSolicitudes.forEach(sol => {
            if (sol.usuario && sol.usuario.trim()) {
              allUsers.add(sol.usuario.trim());
            }
          });
          
          console.log(`ğŸ“Š Corrigiendo puntos para ${allUsers.size} usuarios...`);
          
          let correctedCount = 0;
          for (const username of allUsers) {
            try {
              let data = getGamificationDataForUser(username);
              const oldPoints = data.points;
              
              // Calcular puntos correctos basado en canciones
              const userSongs = localSolicitudes.filter(s => s.usuario === username);
              const songPoints = userSongs.length * 25; // 25 puntos por canciÃ³n
              
              // Calcular puntos de logros
              const achievementPoints = data.achievements.reduce((total, achievementId) => {
                const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
                return achievement ? total + achievement.points : total;
              }, 0);
              
              const correctTotalPoints = songPoints + achievementPoints;
              
              // Solo corregir si hay diferencia
              if (Math.abs(data.points - correctTotalPoints) > 5) {
                data.points = correctTotalPoints;
                data.xp = correctTotalPoints;
                saveGamificationDataForUser(data, username);
                correctedCount++;
                console.log(`âœ… ${username}: ${oldPoints} â†’ ${data.points} puntos`);
              }
            } catch (error) {
              console.error(`âŒ Error corrigiendo ${username}:`, error);
            }
          }
          
          console.log(`ğŸ‰ CORRECCIÃ“N COMPLETADA: ${correctedCount} usuarios corregidos`);
          alert(`CorrecciÃ³n completada: ${correctedCount} usuarios tuvieron sus puntos corregidos.`);
          
          return { total: allUsers.size, corrected: correctedCount };
        } catch (error) {
          console.error('Error en correcciÃ³n rÃ¡pida:', error);
          alert('Error durante la correcciÃ³n. Revisa la consola para mÃ¡s detalles.');
        }
      };

      // FunciÃ³n para recalcular todos los usuarios y corregir inconsistencias
      async function recalculateAllUsers() {
        console.log('ğŸ”„ INICIANDO RECÃLCULO MASIVO DE USUARIOS...');
        
        try {
          // Obtener todos los usuarios Ãºnicos de todas las fuentes
          const allUsers = new Set();
          
          // Usuarios de Firebase
          try {
            const usersSnap = await db.collection('users').get();
            usersSnap.forEach(doc => {
              const { name } = doc.data();
              if (name && name.trim()) allUsers.add(name.trim());
            });
            
            const solicitudesSnap = await db.collection('solicitudes').get();
            solicitudesSnap.forEach(doc => {
              const { usuario } = doc.data();
              if (usuario && usuario.trim()) allUsers.add(usuario.trim());
            });
          } catch (error) {
            console.warn('Error obteniendo usuarios de Firebase:', error);
          }
          
          // Usuarios de localStorage
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          localSolicitudes.forEach(s => {
            if (s.usuario && s.usuario.trim()) allUsers.add(s.usuario.trim());
          });
          
          Object.values(byDay).flat().forEach(s => {
            if (s.usuario && s.usuario.trim()) allUsers.add(s.usuario.trim());
          });
          
          console.log(`ğŸ‘¥ Encontrados ${allUsers.size} usuarios Ãºnicos para recalcular`);
          
          // Recalcular cada usuario
          let processed = 0;
          for (const username of allUsers) {
            try {
              console.log(`ğŸ”„ Recalculando usuario ${++processed}/${allUsers.size}: ${username}`);
              
              // Limpiar flag de procesado para forzar recÃ¡lculo
              const data = getGamificationDataForUser(username);
              delete data.autoProcessed;
              saveGamificationDataForUser(data, username);
              
              // Recalcular
              await analyzeAndGrantPointsForUser(username);
              
            } catch (error) {
              console.error(`Error recalculando usuario ${username}:`, error);
            }
          }
          
          console.log('âœ… RECÃLCULO MASIVO COMPLETADO');
          showSuccessNotification(`RecÃ¡lculo completado: ${processed} usuarios procesados`);
          
          // Actualizar modal si estÃ¡ abierto
          if (document.getElementById('gamification-modal').style.display !== 'none') {
            await renderGamificationModal();
          }
          
        } catch (error) {
          console.error('Error en recÃ¡lculo masivo:', error);
          showErrorNotification('Error durante el recÃ¡lculo masivo');
        }
      }

      // ===== FUNCIONES PARA SELECTOR DE USUARIO =====
      
      let currentSelectedUser = ''; // Se inicializarÃ¡ correctamente en getCurrentSelectedUser()

      async function populateUserSelector() {
        const userSelect = document.getElementById('gamification-user-select');
        if (!userSelect) {
          return;
        }

        try {
          const users = new Map();
          const addUser = (name) => {
            const u = String(name || '').trim();
            if (!u) return;
            const key = u.toLowerCase();
            if (!users.has(key)) users.set(key, u);
          };

          try {
            const items = Array.isArray(window.__dayItems) ? window.__dayItems : [];
            items.forEach(it => {
              addUser(it?.usuario);
            });
          } catch (_) {}

          try {
            const all = await getAllCombinedSolicitudes();
            (all || []).forEach(s => {
              addUser(s?.usuario);
            });
          } catch (_) {}

          try {
            const cached = JSON.parse(localStorage.getItem('knownUsers') || '[]') || [];
            cached.forEach(name => {
              addUser(name);
            });
          } catch (_) {}

          try {
            const dbRef = window.db || db;
            if (dbRef) {
              const statsSnap = await dbRef.collection('userStats').get();
              statsSnap.forEach(doc => { if (doc.id) addUser(doc.id); });
            }
          } catch (_) {}

          try {
            const dbRef = window.db || db;
            if (dbRef) {
              const usersSnap = await dbRef.collection('users').get();
              usersSnap.forEach(doc => {
                const d = doc.data() || {};
                if (d.name) addUser(d.name);
              });
            }
          } catch (_) {}

          // Complementar con usuarios de localStorage
          try {
            const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
            const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
            
            // Agregar usuarios de solicitudes locales
            solicitudes.forEach(s => {
              addUser(s.usuario);
            });
            
            // Agregar usuarios de byDay
            Object.values(byDay).flat().forEach(s => {
              addUser(s.usuario);
            });
          } catch (error) {
            console.error('Error obteniendo usuarios de localStorage:', error);
          }
          
          // Incluir usuarios presentes en sets de insignias otorgadas
          try {
            const addFromSet = (s) => {
              if (!s) return;
              Array.from(s).forEach(name => addUser(name));
            };
            addFromSet(window.vipSet);
            addFromSet(window.z0VipSet);
            addFromSet(window.donadorSet);
            addFromSet(window.z0FanSet);
            addFromSet(window.z0PlatinumSet);
          } catch (setErr) {
            console.warn('No se pudieron agregar usuarios desde sets de insignias:', setErr);
          }

          const usersList = Array.from(users.values()).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          const lastProfileUser = String(localStorage.getItem('lastProfileUser')||'').trim();
          const ordered = lastProfileUser && usersList.includes(lastProfileUser)
            ? [lastProfileUser, ...usersList.filter(u => u !== lastProfileUser)]
            : usersList;
          console.log(`ğŸ‘¥ Usuarios encontrados para selector:`, usersList);

          const hasLast = !!(lastProfileUser && ordered.length && ordered[0] === lastProfileUser);
          const sep = '<option value="" disabled>------</option>';
          const firstOpt = hasLast ? `<option value="${ordered[0]}">${ordered[0]}</option>${sep}` : '';
          const restOpts = ordered.slice(hasLast ? 1 : 0).map(user => `<option value="${user}">${user}</option>`).join('');
          const options = '<option value="">Selecciona un usuario</option>' + firstOpt + restOpts;

          userSelect.innerHTML = options;
          console.log(`âœ… Selector poblado con ${usersList.length} usuarios`);

          if (usersList.length === 0) {
            userSelect.innerHTML = '<option value="">No hay usuarios disponibles</option>';
            console.log(`âš ï¸ No se encontraron usuarios para el selector`);
          }

          // Seleccionar el usuario actual si existe en la lista
          const current = getCurrentSelectedUser();
          if (current && usersList.includes(current)) {
            userSelect.value = current;
          }
          // Refrescar selector de insignias para el usuario actual
          populateBadgeSelectForUser(getCurrentSelectedUser());
        } catch (error) {
          console.error('Error al cargar usuarios:', error);
          userSelect.innerHTML = '<option value="">Error al cargar usuarios</option>';
        }
      }

      // FunciÃ³n de respaldo que usa solo localStorage
      function populateUserSelectorFromLocalStorage() {
        const userSelect = document.getElementById('gamification-user-select');
        if (!userSelect) return;

        try {
          const users = new Map();
          const addUser = (name) => {
            const u = String(name || '').trim();
            if (!u) return;
            const key = u.toLowerCase();
            if (!users.has(key)) users.set(key, u);
          };
          
          // Obtener usuarios de localStorage
          const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
          
          // Agregar usuarios de solicitudes locales
          solicitudes.forEach(s => {
            addUser(s.usuario);
          });
          
          // Agregar usuarios de byDay
          Object.values(byDay).flat().forEach(s => {
            addUser(s.usuario);
          });
          
          const usersList = Array.from(users.values()).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          const lastProfileUser = String(localStorage.getItem('lastProfileUser')||'').trim();
          const ordered = lastProfileUser && usersList.includes(lastProfileUser)
            ? [lastProfileUser, ...usersList.filter(u => u !== lastProfileUser)]
            : usersList;
          const hasLast = !!(lastProfileUser && ordered.length && ordered[0] === lastProfileUser);
          const sep = '<option value="" disabled>------</option>';
          const firstOpt = hasLast ? `<option value="${ordered[0]}">${ordered[0]}</option>${sep}` : '';
          const restOpts = ordered.slice(hasLast ? 1 : 0).map(user => `<option value="${user}">${user}</option>`).join('');
          const options = '<option value="">Selecciona un usuario</option>' + firstOpt + restOpts;
          
          userSelect.innerHTML = options;
          
          if (usersList.length === 0) {
            userSelect.innerHTML = '<option value="">No hay usuarios disponibles</option>';
          }
        } catch (error) {
          console.error('Error en fallback localStorage:', error);
          userSelect.innerHTML = '<option value="">Error al cargar usuarios</option>';
        }
      }
      window.populateUserSelectorFromLocalStorage = populateUserSelectorFromLocalStorage;

      // --- NUEVA FUNCIÃ“N: Poblar selector de compensaciÃ³n (Admin) ---
      async function populateAdminCompensationSelector() {
        const compSelect = document.getElementById('comp-user-select');
        if (!compSelect) return;
        
        try {
           compSelect.innerHTML = '<option value="">Cargando usuarios...</option>';
           const users = new Map();
           const addUser = (name) => {
             const u = String(name || '').trim();
             if (!u) return;
             const key = u.toLowerCase();
             if (!users.has(key)) users.set(key, u);
           };
           
           // 1. Firebase Users
           try {
             const snap = await db.collection('users').get();
             snap.forEach(d => { const n = d.data().name; if(n) addUser(n); });
           } catch(e){}
           
           // 2. Solicitudes recientes
           try {
             const snap = await db.collection('solicitudes').orderBy('day','desc').limit(500).get();
             snap.forEach(d => { const u = d.data().usuario; if(u) addUser(u); });
           } catch(e){}
           
           // 3. LocalStorage
           try {
              const local = JSON.parse(localStorage.getItem('solicitudes')||'[]');
              local.forEach(s => { if(s.usuario) addUser(s.usuario); });
           } catch(e){}
           
           const sorted = Array.from(users.values()).sort((a,b) => a.toLowerCase().localeCompare(b.toLowerCase()));
           
           let opts = '<option value="">Seleccionar usuario...</option>';
           sorted.forEach(u => {
              opts += `<option value="${u}">${u}</option>`;
           });
           compSelect.innerHTML = opts;
           
        } catch(e) {
           console.error('Error poblando selector admin:', e);
           compSelect.innerHTML = '<option value="">Error al cargar</option>';
        }
      }
      // Exponer globalmente
      window.populateAdminCompensationSelector = populateAdminCompensationSelector;


      // FunciÃ³n auxiliar para obtener todos los datos combinados
      async function getAllCombinedSolicitudes() {
        const allSolicitudesMap = new Map();
        const toKey = (s) => {
          const usuario = String(s?.usuario || '').trim();
          const cancion = String(s?.cancion || '').trim();
          const artista = String(s?.artista || '').trim();
          const hora = String(s?.hora || '').trim() || String(s?.time || s?.ts || '').trim();
          return `${usuario}-${cancion}-${artista}-${hora}`.replace(/[^a-zA-Z0-9-]/g, '');
        };
        const add = (s) => {
          if (!s || !s.usuario || !s.cancion || !s.artista) return;
          const key = toKey(s);
          if (!key) return;
          allSolicitudesMap.set(key, s);
        };

        try {
          const dayItems = Array.isArray(window.__dayItems) ? window.__dayItems : [];
          dayItems.forEach(it => add({
            usuario: it.usuario,
            cancion: it.cancion,
            artista: it.artista,
            day: it.day,
            ts: it.ts || it.time,
            hora: it.hora || ''
          }));
        } catch (_) {}

        try {
          const localSolicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]') || [];
          localSolicitudes.forEach(s => add({
            usuario: s.usuario,
            cancion: s.cancion,
            artista: s.artista,
            day: s.day,
            ts: s.time || s.ts,
            hora: s.hora || ''
          }));
        } catch (_) {}

        try {
          const byDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}') || {};
          Object.values(byDay).forEach(arr => (arr || []).forEach(s => add({
            usuario: s.usuario,
            cancion: s.cancion,
            artista: s.artista,
            day: s.day,
            ts: s.time || s.ts,
            hora: s.hora || ''
          })));
        } catch (_) {}

        try {
          const daySel = document.getElementById('day-select')?.value || '';
          const dbRef = window.db || db;
          if (dbRef && daySel) {
            const snap = await dbRef.collection('solicitudes').where('day', '==', daySel).orderBy('ts', 'desc').limit(1000).get();
            snap.forEach(doc => {
              const data = doc.data() || {};
              add({
                usuario: data.usuario,
                cancion: data.cancion,
                artista: data.artista,
                day: data.day,
                ts: data.ts ? data.ts.toMillis() : Date.now(),
                hora: data.hora || ''
              });
            });
          }
        } catch (_) {}

        return Array.from(allSolicitudesMap.values());
      }

      async function switchToUser(username) {
        console.log(`ğŸ”„ INICIO - Cambiando a usuario: ${username || 'usuario actual'}`);
        console.log(`ğŸ“ Usuario anterior: ${currentSelectedUser}`);
        
        if (!username) {
          currentSelectedUser = getCurrentUser();
          username = currentSelectedUser;
          console.log(`ğŸ”„ Sin username proporcionado, usando usuario actual: ${username}`);
        } else {
          currentSelectedUser = username;
          console.log(`âœ… currentSelectedUser actualizado a: ${currentSelectedUser}`);
        }
        
        // Verificar datos existentes
        console.log(`ğŸ“Š Verificando datos para usuario: ${username}`);
        // Limpiar caches y pines para evitar valores del usuario previo
        try { window.__breakdownCache = {}; } catch (_) {}
        
        // Renderizar modal y refrescar paneles activos para el usuario seleccionado
        console.log(`ğŸ¨ Llamando renderGamificationModal para ${username}`);
        await renderGamificationModal();
        const u = currentSelectedUser;
        try {
          const statsPanel = document.getElementById('gamification-stats');
          if (statsPanel && statsPanel.classList.contains('active')) {
            const localData = getLocalGamificationData(u) || getGamificationDataForUser(u);
            await renderPersonalStatsForUser(localData, u);
          }
          const breakdownPanel = document.getElementById('gamification-breakdown');
          if (breakdownPanel && breakdownPanel.classList.contains('active')) {
            await renderPointsBreakdownForUser(u, true);
          }
        } catch (_){ }
        console.log(`âœ… FIN - Modal actualizado para usuario: ${currentSelectedUser}`);
        try { subscribeUserStatsPointsForUser(currentSelectedUser); } catch (_) {}
      }

      function getCurrentSelectedUser() {
        return currentSelectedUser || getCurrentUser();
      }

      function normalizeUserKey(username) {
        return String(username || '').trim().replace(/^@/, '').toLowerCase();
      }

      function normalizeUserKeyLoose(username) {
        return String(username || '').replace(/^@/, '').toLowerCase();
      }

      function getUserStatsDocKeys(username) {
        const a = normalizeUserKey(username);
        const b = normalizeUserKeyLoose(username);
        return Array.from(new Set([a, b].filter(Boolean)));
      }

      function getMillisFromTs(ts) {
        try {
          if (!ts) return 0;
          if (typeof ts.toMillis === 'function') return ts.toMillis();
          if (typeof ts.toDate === 'function') return ts.toDate().getTime();
          const d = new Date(ts);
          const t = d.getTime();
          return Number.isFinite(t) ? t : 0;
        } catch (_) { return 0; }
      }

      async function fetchBestUserStatsDoc(username) {
        try {
          const dbRef = window.db || db;
          if (!dbRef) return null;
          const keys = getUserStatsDocKeys(username);
          if (!keys.length) return null;
          const docs = await Promise.all(keys.map(async (k) => {
            try {
              const ref = dbRef.collection('userStats').doc(k);
              const snap = await ref.get();
              return { key: k, snap, data: snap.exists ? (snap.data() || {}) : null };
            } catch (_) {
              return { key: k, snap: null, data: null };
            }
          }));
          const existing = docs.filter(d => d && d.data);
          if (!existing.length) return null;
          existing.sort((x, y) => {
            const px = Number(x.data.totalPoints || 0);
            const py = Number(y.data.totalPoints || 0);
            const diff = Math.abs(px - py);
            if (diff >= 5000) return px - py;
            const tx = Math.max(getMillisFromTs(x.data.updatedAt), getMillisFromTs(x.data.lastUpdated));
            const ty = Math.max(getMillisFromTs(y.data.updatedAt), getMillisFromTs(y.data.lastUpdated));
            if (ty !== tx) return ty - tx;
            return px - py;
          });
          return existing[0];
        } catch (_) {
          return null;
        }
      }

      function subscribeUserStatsPointsForUser(username) {
        try {
          if (Array.isArray(window._userStatsPointsUnsubs)) {
            window._userStatsPointsUnsubs.forEach(fn => { try { fn && fn(); } catch (_) {} });
          }
          window._userStatsPointsUnsubs = [];
        } catch (_) {}
        try {
          const dbRef = window.db || db;
          if (!dbRef || !username) return;
          const keys = getUserStatsDocKeys(username);
          const latest = {};
          const applyBest = () => {
            try {
              const u = getCurrentSelectedUser();
              const currentNorm = normalizeUserKey(u);
              const lookingFor = normalizeUserKey(username);
              if (currentNorm !== lookingFor) return;
              const arr = Object.values(latest).filter(Boolean);
              if (!arr.length) return;
              arr.sort((x, y) => {
                const px = Number(x.totalPoints || 0);
                const py = Number(y.totalPoints || 0);
                const diff = Math.abs(px - py);
                if (diff >= 5000) return px - py;
                const tx = Math.max(getMillisFromTs(x.updatedAt), getMillisFromTs(x.lastUpdated));
                const ty = Math.max(getMillisFromTs(y.updatedAt), getMillisFromTs(y.lastUpdated));
                if (ty !== tx) return ty - tx;
                return px - py;
              });
              const best = arr[0];
              const cloudPoints = Number(best.totalPoints || 0);
              const local = getGamificationDataForUser(u) || {};
              local.points = cloudPoints;
              local._cloudSyncedPoints = cloudPoints;
              saveGamificationDataForUser(local, u);
              const ptsEl = document.getElementById('user-points');
              if (ptsEl) ptsEl.textContent = String(cloudPoints);
              const rewardsPtsEl = document.getElementById('rewards-user-points');
              if (rewardsPtsEl) rewardsPtsEl.textContent = String(cloudPoints);
            } catch (_) {}
          };
          keys.forEach((k) => {
            const unsub = dbRef.collection('userStats').doc(k).onSnapshot((doc) => {
              try {
                if (!doc || !doc.exists) return;
                const d = doc.data() || {};
                latest[k] = d;
                applyBest();
              } catch (_) {}
            }, () => {});
            window._userStatsPointsUnsubs.push(unsub);
          });
        } catch (_) {}
      }

      // FunciÃ³n de prueba para verificar y otorgar todos los logros de insignias
      window.testBadgeAchievements = function(username) {
        console.log(`ğŸ§ª PRUEBA MANUAL: Verificando logros de insignias para ${username}`);
        
        try {
          // Obtener datos del usuario
          let userData = getGamificationDataForUser(username);
          console.log(`ğŸ“Š Datos actuales:`, userData);
          
          if (!userData.achievements) userData.achievements = [];
          
          // Verificar todas las insignias desde la gestiÃ³n de insignias (Firebase)
          const isVipFromSet = (typeof vipSet !== 'undefined' && vipSet.has(username));
          const isZ0VipFromSet = (typeof z0VipSet !== 'undefined' && z0VipSet.has(username));
          const isDonadorFromSet = (typeof donadorSet !== 'undefined' && donadorSet.has(username));
          
          console.log(`ğŸ” Estado de insignias desde gestiÃ³n:`);
          console.log(`  - VIP (vipSet de Firebase): ${isVipFromSet}`);
          console.log(`  - Z0-VIP (z0VipSet de Firebase): ${isZ0VipFromSet}`);
          console.log(`  - Donador (donadorSet de Firebase): ${isDonadorFromSet}`);
          console.log(`  - vipSet disponible: ${typeof vipSet !== 'undefined'}`);
          console.log(`  - z0VipSet disponible: ${typeof z0VipSet !== 'undefined'}`);
          console.log(`  - donadorSet disponible: ${typeof donadorSet !== 'undefined'}`);
          
          const isVip = isVipFromSet;
          const isZ0Vip = isZ0VipFromSet;
          const isDonador = isDonadorFromSet;
          
          let pointsAwarded = 0;
          let achievementsGranted = [];
          
          // Verificar y otorgar logro VIP
          if (isVip && !userData.achievements.includes('vip_member')) {
            console.log(`ğŸ‰ OTORGANDO logro VIP...`);
            userData.achievements.push('vip_member');
            pointsAwarded += 200;
            achievementsGranted.push('Miembro VIP (+200 pts)');
          }
          
          // Verificar y otorgar logro Z0-VIP
          if (isZ0Vip && !userData.achievements.includes('z0_vip_member')) {
            console.log(`ğŸ‰ OTORGANDO logro Z0-VIP...`);
            userData.achievements.push('z0_vip_member');
            pointsAwarded += 300;
            achievementsGranted.push('Z0-VIP Exclusivo (+300 pts)');
          }
          
          // Verificar y otorgar logro Donador
          if (isDonador && !userData.achievements.includes('donador_member')) {
            console.log(`ğŸ‰ OTORGANDO logro Donador...`);
            userData.achievements.push('donador_member');
            pointsAwarded += 250;
            achievementsGranted.push('Donador Generoso (+250 pts)');
          }
          
          // Aplicar cambios si hay logros nuevos
          if (pointsAwarded > 0) {
            userData.points = (userData.points || 0) + pointsAwarded;
            userData.xp = (userData.xp || 0) + pointsAwarded;
            userData.level = calculateLevel(userData.xp);
            
            saveGamificationDataForUser(userData, username);
            
            console.log(`âœ… Ã‰XITO: Logros otorgados a ${username}:`, achievementsGranted);
            console.log(`ğŸ’° Puntos totales: ${userData.points} (+${pointsAwarded})`);
            console.log(`â­ Nivel: ${userData.level}`);
            
            return true;
          } else {
            console.log(`â„¹ï¸ INFO: ${username} ya tiene todos los logros de insignias disponibles`);
            console.log(`ğŸ† Logros actuales:`, userData.achievements);
            return false;
          }
          
        } catch (error) {
          console.error('âŒ ERROR en prueba:', error);
          return false;
        }
      };
      
      // FunciÃ³n simple para otorgar logros de insignias
      window.grantBadgeAchievement = function(username) {
        if (!username) {
          console.warn('âš ï¸ No se proporcionÃ³ nombre de usuario');
          return false;
        }
        
        console.log(`ğŸ¯ Otorgando logros de insignias para: ${username}`);
        
        try {
          // Verificar que los sets estÃ©n definidos y cargados
          if (typeof window.vipSet === 'undefined' || typeof window.z0VipSet === 'undefined' || typeof window.donadorSet === 'undefined') {
            console.warn(`âš ï¸ Sets no definidos para ${username}, inicializando...`);
            // Inicializar sets si no existen
            if (typeof window.vipSet === 'undefined') window.vipSet = new Set();
            if (typeof window.z0VipSet === 'undefined') window.z0VipSet = new Set();
            if (typeof window.donadorSet === 'undefined') window.donadorSet = new Set();
            return false;
          }
          
          if (!window.vipSet || !window.z0VipSet || !window.donadorSet) {
            console.warn(`âš ï¸ Sets no inicializados para ${username}`);
            return false;
          }
          
          const totalUsers = window.vipSet.size + window.z0VipSet.size + window.donadorSet.size;
          if (totalUsers === 0) {
            console.warn(`âš ï¸ Sets vacÃ­os para ${username}, datos aÃºn no cargados`);
            return false;
          }
          // Verificar que los sets estÃ©n disponibles
          console.log(`ğŸ“Š Estado de sets: vipSet=${typeof window.vipSet !== 'undefined'}, z0VipSet=${typeof window.z0VipSet !== 'undefined'}, donadorSet=${typeof window.donadorSet !== 'undefined'}`);
          
          // Obtener datos del usuario
          let userData = getGamificationDataForUser(username);
          console.log(`ğŸ“Š Datos actuales de ${username}:`, userData);
          
          if (!userData.achievements) userData.achievements = [];
          
          let pointsAdded = 0;
          let newAchievements = [];
          
          // Verificar VIP
          if (typeof window.vipSet !== 'undefined' && window.vipSet.has(username)) {
            console.log(`ğŸ” ${username} estÃ¡ en vipSet`);
            if (!userData.achievements.includes('vip_member')) {
              userData.achievements.push('vip_member');
              pointsAdded += 200;
              newAchievements.push('VIP (+200)');
              console.log(`âœ… Logro VIP otorgado a ${username}`);
            } else {
              console.log(`â„¹ï¸ ${username} ya tiene el logro VIP`);
            }
          } else {
            console.log(`â„¹ï¸ ${username} no estÃ¡ en vipSet`);
          }
          
          // Verificar Z0-VIP
          if (typeof window.z0VipSet !== 'undefined' && window.z0VipSet.has(username)) {
            console.log(`ğŸ” ${username} estÃ¡ en z0VipSet`);
            if (!userData.achievements.includes('z0_vip_member')) {
              userData.achievements.push('z0_vip_member');
              pointsAdded += 300;
              newAchievements.push('Z0-VIP (+300)');
              console.log(`âœ… Logro Z0-VIP otorgado a ${username}`);
            } else {
              console.log(`â„¹ï¸ ${username} ya tiene el logro Z0-VIP`);
            }
          } else {
            console.log(`â„¹ï¸ ${username} no estÃ¡ en z0VipSet`);
          }
          
          // Verificar Donador
          if (typeof window.donadorSet !== 'undefined' && window.donadorSet.has(username)) {
            console.log(`ğŸ” ${username} estÃ¡ en donadorSet`);
            if (!userData.achievements.includes('donador_member')) {
              userData.achievements.push('donador_member');
              pointsAdded += 250;
              newAchievements.push('Donador (+250)');
              console.log(`âœ… Logro Donador otorgado a ${username}`);
            } else {
              console.log(`â„¹ï¸ ${username} ya tiene el logro Donador`);
            }
          } else {
            console.log(`â„¹ï¸ ${username} no estÃ¡ en donadorSet`);
          }
          
          // Aplicar puntos si hay logros nuevos
          if (pointsAdded > 0) {
            userData.points = (userData.points || 0) + pointsAdded;
            userData.xp = (userData.xp || 0) + pointsAdded;
            userData.level = calculateLevel(userData.xp);
            
            console.log(`ğŸ’¾ Guardando datos actualizados para ${username}:`, userData);
            saveGamificationDataForUser(userData, username);
            
            console.log(`ğŸ‰ ${username}: ${newAchievements.join(', ')} - Total: ${userData.points} pts`);
            return true;
          } else {
            console.log(`â„¹ï¸ ${username} ya tiene todos los logros de insignias`);
            return false;
          }
          
        } catch (error) {
          console.error(`âŒ Error otorgando logros a ${username}:`, error);
          console.error('Stack trace:', error.stack);
          return false;
        }
      };
      
      // FunciÃ³n para procesar todos los usuarios con insignias
      window.processAllBadges = function() {
        console.log(`ğŸš€ Procesando TODOS los usuarios con insignias...`);
        
        let total = 0;
        let success = 0;
        
        // Procesar VIP
        if (typeof vipSet !== 'undefined') {
          vipSet.forEach(username => {
            total++;
            if (window.grantBadgeAchievement(username)) success++;
          });
        }
        
        // Procesar Z0-VIP
        if (typeof z0VipSet !== 'undefined') {
          z0VipSet.forEach(username => {
            total++;
            if (window.grantBadgeAchievement(username)) success++;
          });
        }
        
        // Procesar Donadores
        if (typeof donadorSet !== 'undefined') {
          donadorSet.forEach(username => {
            total++;
            if (window.grantBadgeAchievement(username)) success++;
          });
        }
        
        console.log(`ğŸ COMPLETADO: ${success}/${total} usuarios recibieron nuevos logros`);
        return { total, success };
      };

      // FunciÃ³n de diagnÃ³stico para verificar el estado del sistema
      window.diagnosticBadges = async function() {
        console.log('ğŸ” === DIAGNÃ“STICO DEL SISTEMA DE LOGROS ===');
        
        // 1. Verificar sets
        console.log('ğŸ“Š Estado de los sets:');
        console.log(`- VIP Set: ${vipSet ? vipSet.size : 'NO DEFINIDO'} usuarios`);
        console.log(`- Z0-VIP Set: ${z0VipSet ? z0VipSet.size : 'NO DEFINIDO'} usuarios`);
        console.log(`- Donador Set: ${donadorSet ? donadorSet.size : 'NO DEFINIDO'} usuarios`);
        
        if (vipSet && vipSet.size > 0) {
          console.log('ğŸ‘¥ Usuarios VIP:', Array.from(vipSet));
        }
        if (z0VipSet && z0VipSet.size > 0) {
          console.log('ğŸ‘¥ Usuarios Z0-VIP:', Array.from(z0VipSet));
        }
        if (donadorSet && donadorSet.size > 0) {
          console.log('ğŸ‘¥ Usuarios Donador:', Array.from(donadorSet));
        }
        
        // 2. Verificar Firebase
        console.log('ğŸ”¥ Verificando conexiÃ³n a Firebase...');
        try {
          const testDoc = await db.collection('vipUsers').limit(1).get();
          console.log('âœ… ConexiÃ³n a Firebase OK');
        } catch (error) {
          console.error('âŒ Error de conexiÃ³n a Firebase:', error);
          return;
        }
        
        // 3. Probar con un usuario especÃ­fico
        if (vipSet && vipSet.size > 0) {
          const testUser = Array.from(vipSet)[0];
          console.log(`ğŸ§ª Probando con usuario: ${testUser}`);
          
          try {
            // Verificar datos existentes
            const userData = getGamificationDataForUser(testUser);
            console.log(`ğŸ“Š Datos actuales de ${testUser}:`, userData);
            
            // Intentar otorgar logro
            console.log(`ğŸ¯ Intentando otorgar logro a ${testUser}...`);
            const result = window.grantBadgeAchievement(testUser);
            console.log(`ğŸ¯ Resultado: ${result ? 'Ã‰xito' : 'Sin cambios'}`);
            
          } catch (error) {
            console.error(`âŒ Error probando con ${testUser}:`, error);
          }
        }
        
        console.log('ğŸ” === FIN DEL DIAGNÃ“STICO ===');
        };

        // FunciÃ³n para otorgar puntos manualmente (sin depender de sets)
        window.grantPointsManual = async function(username, isVip = false, isZ0Vip = false, isDonador = false) {
          console.log(`ğŸ¯ Otorgando puntos manualmente a: ${username}`);
          console.log(`Estado: VIP=${isVip}, Z0-VIP=${isZ0Vip}, Donador=${isDonador}`);
          
          try {
            // Obtener datos actuales
            const userStatsRef = db.collection('userStats').doc(username);
            const userStatsDoc = await userStatsRef.get();
            
            let userData = userStatsDoc.exists ? userStatsDoc.data() : {
              points: 0,
              level: 1,
              achievements: [],
              lastUpdated: new Date()
            };
            
            console.log('Datos actuales:', userData);
            
            let pointsAwarded = 0;
            let achievementsGranted = [];
            
            // Otorgar logros segÃºn parÃ¡metros
            if (isVip && !userData.achievements.includes('vip_badge')) {
              userData.achievements.push('vip_badge');
              userData.points += 200;
              pointsAwarded += 200;
              achievementsGranted.push('VIP');
            }
            
            if (isZ0Vip && !userData.achievements.includes('z0vip_badge')) {
              userData.achievements.push('z0vip_badge');
              userData.points += 300;
              pointsAwarded += 300;
              achievementsGranted.push('Z0-VIP');
            }
            
            if (isDonador && !userData.achievements.includes('donador_badge')) {
              userData.achievements.push('donador_badge');
              userData.points += 150;
              pointsAwarded += 150;
              achievementsGranted.push('Donador');
            }
            
            if (pointsAwarded > 0) {
              userData.lastUpdated = new Date();
              console.log('Guardando datos:', userData);
              
              await userStatsRef.set(userData, { merge: true });
              console.log(`ğŸ‰ ${username}: ${achievementsGranted.join(', ')} (+${pointsAwarded}) - Total: ${userData.points} pts`);
              
              // Verificar que se guardÃ³
              const verification = await userStatsRef.get();
              if (verification.exists) {
                console.log('âœ… VerificaciÃ³n exitosa:', verification.data());
              } else {
                console.error('âŒ Error: datos no se guardaron');
              }
              
            } else {
              console.log('â„¹ï¸ No hay logros nuevos para otorgar');
            }
            
          } catch (error) {
            console.error('âŒ Error:', error);
          }
        };

        // FunciÃ³n para forzar la carga de sets y procesar logros
        window.forceLoadAndProcess = function() {
          console.log('ğŸš€ Forzando carga de sets y procesamiento de logros...');
          
          // Verificar estado actual
          console.log(`ğŸ“Š Estado actual: VIP(${vipSet ? vipSet.size : 'undefined'}), Z0-VIP(${z0VipSet ? z0VipSet.size : 'undefined'}), Donador(${donadorSet ? donadorSet.size : 'undefined'})`);
          
          // Esperar un poco mÃ¡s y luego procesar
          setTimeout(() => {
            console.log('â° Esperando 5 segundos para asegurar carga completa...');
            setTimeout(() => {
              console.log(`ğŸ“Š Estado despuÃ©s de espera: VIP(${vipSet ? vipSet.size : 'undefined'}), Z0-VIP(${z0VipSet ? z0VipSet.size : 'undefined'}), Donador(${donadorSet ? donadorSet.size : 'undefined'})`);
              
              if (vipSet && z0VipSet && donadorSet) {
                const totalUsers = vipSet.size + z0VipSet.size + donadorSet.size;
                if (totalUsers > 0) {
                  console.log('âœ… Sets cargados, procesando logros...');
                  window.processAllBadges();
                } else {
                  console.warn('âš ï¸ Sets definidos pero vacÃ­os. Puede que no haya usuarios VIP/Z0-VIP/Donador o los datos no se han cargado.');
                }
              } else {
                console.error('âŒ Sets aÃºn no definidos despuÃ©s de la espera');
              }
            }, 5000);
          }, 1000);
        };
      
      // Funciones de compatibilidad
      window.testVipAchievement = window.grantBadgeAchievement;
      window.testBadgeAchievements = window.grantBadgeAchievement;
      window.processAllVipAchievements = window.processAllBadges;

      // FunciÃ³n simplificada para procesar solo logros
      async function processAchievementsForUser(username, existingData) {
        try {
          console.log(`ğŸ† Procesando logros para ${username}...`);
          
          // Verificar que los sets estÃ©n inicializados y cargados
          if (typeof vipSet === 'undefined' || typeof z0VipSet === 'undefined' || typeof donadorSet === 'undefined' ||
              !vipSet || !z0VipSet || !donadorSet) {
            console.log(`â³ Sets de insignias aÃºn no inicializados para ${username}, reintentando en 2 segundos...`);
            setTimeout(() => processAchievementsForUser(username, existingData), 2000);
            return existingData;
          }
          
          // Verificar que al menos uno de los sets tenga datos (indicando que ya se cargaron)
          const totalUsers = vipSet.size + z0VipSet.size + donadorSet.size;
          if (totalUsers === 0) {
            console.log(`â³ Sets de insignias vacÃ­os para ${username}, esperando carga de datos... reintentando en 3 segundos`);
            setTimeout(() => processAchievementsForUser(username, existingData), 3000);
            return existingData;
          }
          
          console.log(`âœ… Sets cargados: VIP(${vipSet.size}), Z0-VIP(${z0VipSet.size}), Donador(${donadorSet.size})`);
          
          // Usar datos existentes como base
          const data = { ...existingData };
          
          if (!data.achievements) data.achievements = [];
          
          // Verificar insignias del usuario desde la gestiÃ³n de insignias (Firebase)
          const isVipFromSet = vipSet.has(username);
          const isZ0VipFromSet = z0VipSet.has(username);
          const isDonadorFromSet = donadorSet.has(username);
          
          console.log(`ğŸ” Verificando insignias desde gestiÃ³n para ${username}:`);
          console.log(`   - VIP (vipSet de Firebase): ${isVipFromSet}`);
          console.log(`   - Z0-VIP (z0VipSet de Firebase): ${isZ0VipFromSet}`);
          console.log(`   - Donador (donadorSet de Firebase): ${isDonadorFromSet}`);
          console.log(`   - vipSet size: ${vipSet.size}, z0VipSet size: ${z0VipSet.size}, donadorSet size: ${donadorSet.size}`);
          
          const isVip = isVipFromSet;
          const isZ0Vip = isZ0VipFromSet;
          const isDonador = isDonadorFromSet;
          
          let pointsAwarded = 0;
          let achievementsGranted = [];
          
          // Procesar logro VIP
          if (isVip && !data.achievements.includes('vip_member')) {
            console.log(`ğŸ‰ Otorgando logro VIP a ${username}`);
            data.achievements.push('vip_member');
            pointsAwarded += 200;
            achievementsGranted.push('Miembro VIP (+200 pts)');
          }
          
          // Procesar logro Z0-VIP
          if (isZ0Vip && !data.achievements.includes('z0_vip_member')) {
            console.log(`ğŸ‰ Otorgando logro Z0-VIP a ${username}`);
            data.achievements.push('z0_vip_member');
            pointsAwarded += 300;
            achievementsGranted.push('Z0-VIP Exclusivo (+300 pts)');
          }
          
          // Procesar logro Donador
          if (isDonador && !data.achievements.includes('donador_member')) {
            console.log(`ğŸ‰ Otorgando logro Donador a ${username}`);
            data.achievements.push('donador_member');
            pointsAwarded += 250;
            achievementsGranted.push('Donador Generoso (+250 pts)');
          }
          
          // Aplicar puntos y XP si se otorgaron logros
          if (pointsAwarded > 0) {
            data.points += pointsAwarded;
            data.xp += pointsAwarded;
            data.level = calculateLevel(data.xp);
            
            // Guardar datos actualizados
            saveGamificationDataForUser(data, username);
            
            console.log(`âœ… Logros otorgados a ${username}:`, achievementsGranted);
            console.log(`ğŸ’° Puntos totales: ${data.points} (+${pointsAwarded})`);
            console.log(`â­ Nivel: ${data.level}`);
          } else {
            console.log(`â„¹ï¸ ${username} ya tiene todos los logros de insignias disponibles`);
          }
          
          // Actualizar stats con estados de insignias
          if (!data.stats) data.stats = {};
          data.stats.isVip = isVip;
          data.stats.isZ0Vip = isZ0Vip;
          data.stats.isDonador = isDonador;
          
          return data;
        } catch (error) {
          console.error(`âŒ Error procesando logros para ${username}:`, error);
          return existingData;
        }
      }

      // Modificar funciones existentes para usar el usuario seleccionado
      function getGamificationDataForUser(usuario = null) {
        const targetUser = usuario || getCurrentSelectedUser();
        const normUser = String(targetUser || '').trim().replace(/^@/, '').toLowerCase();
        const data = localStorage.getItem('gamificationData');
        const allData = data ? JSON.parse(data) : {};
        
        // console.log(`ğŸ“– Recuperando datos para ${targetUser} de localStorage`);
        const userData = allData[targetUser.toLowerCase()];
        
        return userData || {
          points: 0,
          level: 1,
          xp: 0,
          achievements: [],
          streaks: {
            current: 0,
            best: 0,
            lastActivity: null,
            calendar: {}
          },
          stats: {
            totalSongs: 0,
            uniqueArtists: 0,
            activeDays: 0,
            isVip: false
          }
        };
      }

      // NUEVA FUNCIÃ“N: Sincronizar datos con la nube
      async function syncGamificationDataWithCloud(username) {
         try {
            console.log(`â˜ï¸ Sincronizando gamificaciÃ³n para ${username}...`);
            const normUser = normalizeUserKey(username);
            const docRef = db.collection('userStats').doc(normUser);
            const best = await fetchBestUserStatsDoc(username);
            
            const localData = getGamificationDataForUser(username);
            
            if (!best || !best.data) {
               console.log('â˜ï¸ No hay datos en nube. Subiendo locales...');
               // Subir datos locales si existen y tienen algo de valor
               if (localData.points > 0 || localData.achievements.length > 0) {
                  await docRef.set({
                     totalPoints: localData.points,
                     gamification: localData,
                     updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                  }, { merge: true });
               }
               return localData;
            }
            
            const cloudDataFull = best.data || {};
            const cloudPoints = Number(cloudDataFull.totalPoints || 0);
            const cloudGamification = cloudDataFull.gamification || null;
            
            console.log(`â˜ï¸ Puntos nube: ${cloudPoints}, Puntos locales: ${localData.points}`);
            
            // Estrategia de fusiÃ³n:
            // 1. Si no hay objeto gamification en nube, pero hay puntos, intentar reconstruir o priorizar local si es mayor.
            // 2. Si hay objeto gamification, fusionar logros y tomar mÃ¡ximos de rachas/puntos.
            
            let mergedData = { ...localData };
            
            if (cloudGamification) {
               // Fusionar logros (UniÃ³n)
               const localAch = new Set(localData.achievements || []);
               const cloudAch = new Set(cloudGamification.achievements || []);
               const mergedAch = [...new Set([...localAch, ...cloudAch])];
               
               // Puntos: la fuente de verdad es totalPoints en la nube (puede bajar por canjes)
               mergedData.achievements = mergedAch;
               mergedData.points = cloudPoints;
               mergedData._cloudSyncedPoints = cloudPoints;
               
               // Rachas: Tomar la mejor racha histÃ³rica registrada
               mergedData.streaks = {
                  ...localData.streaks,
                  ...cloudGamification.streaks,
                  best: Math.max(localData.streaks?.best || 0, cloudGamification.streaks?.best || 0)
               };
               
               // Si la nube tiene mÃ¡s puntos, confiar en su nivel/xp tambiÃ©n (o recalcular despuÃ©s)
               if ((cloudGamification.points || 0) > (localData.points || 0)) {
                  mergedData.level = cloudGamification.level;
                  mergedData.xp = cloudGamification.xp;
                  mergedData.stats = cloudGamification.stats || mergedData.stats;
               }
            } else {
               // Nube solo tiene totalPoints (migraciÃ³n o ajuste manual admin)
               mergedData.points = cloudPoints;
               mergedData._cloudSyncedPoints = cloudPoints;
            }
            
            // Guardar fusiÃ³n en local
            saveGamificationDataForUser(mergedData, username);
            
            // Guardar fusiÃ³n en nube (para que el otro dispositivo se actualice tambiÃ©n)
            // Solo si hubo cambios o si es necesario unificar
            if ((best && best.key && best.key !== normUser) || JSON.stringify(mergedData) !== JSON.stringify(cloudGamification) || cloudPoints !== mergedData.points) {
               console.log('â˜ï¸ Actualizando nube con datos fusionados...');
               await docRef.set({
                  totalPoints: mergedData.points,
                  gamification: mergedData,
                  updatedAt: firebase.firestore.FieldValue.serverTimestamp()
               }, { merge: true });
            }
            
            return mergedData;
            
         } catch (e) {
            console.error('Error sincronizando con nube:', e);
            return getGamificationDataForUser(username); // Fallback local
         }
      }

      function saveGamificationDataForUser(data, usuario = null) {
        const targetUser = usuario || getCurrentSelectedUser();
        
        // ValidaciÃ³n de usuario
        if (!targetUser || targetUser === 'null' || targetUser === 'undefined' || targetUser.toLowerCase() === 'text/plain' || targetUser.toLowerCase() === 'plain') {
          console.warn(`âš ï¸ Intento de guardar datos para usuario invÃ¡lido: ${targetUser}`);
          return;
        }

        const allDataStr = localStorage.getItem('gamificationData');
        const allData = allDataStr ? JSON.parse(allDataStr) : {};
        
        // console.log(`ğŸ’¾ Guardando datos para ${targetUser}:`, data);
        
        allData[targetUser.toLowerCase()] = data;
        localStorage.setItem('gamificationData', JSON.stringify(allData));
        
        // console.log(`âœ… Datos guardados en localStorage para ${targetUser}`);
        
        // PUSH AUTOMÃTICO A LA NUBE (Debounce simple para evitar saturaciÃ³n)
        // Esto asegura que los cambios locales (como puntos por canciones o logros) se reflejen globalmente
        if (window.db) {
           const now = Date.now();
           window._lastCloudPush = window._lastCloudPush || {};
           const lastPush = window._lastCloudPush[targetUser.toLowerCase()] || 0;
           
           // Si han pasado mÃ¡s de 10 segundos desde el Ãºltimo push, o si es un cambio crÃ­tico (muchos puntos)
           if (now - lastPush > 10000) {
              window._lastCloudPush[targetUser.toLowerCase()] = now;
              const normUser = normalizeUserKey(targetUser);
              
              // No bloquear la UI, hacerlo en segundo plano
              const safePoints = Math.max(0, Number(data.points || 0));
              const docRef = db.collection('userStats').doc(normUser);
              const pushWithBase = (basePoints) => {
                 const base = Math.max(0, Number(basePoints || 0));
                 const delta = safePoints - base;
                 const payload = {
                    gamification: Object.assign({}, data, { _cloudSyncedPoints: base + Math.max(0, delta) }),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                 };
                 if (delta > 0) {
                    payload.totalPoints = firebase.firestore.FieldValue.increment(delta);
                    try {
                      data._cloudSyncedPoints = base + delta;
                      const allDataStr2 = localStorage.getItem('gamificationData');
                      const allData2 = allDataStr2 ? JSON.parse(allDataStr2) : {};
                      allData2[targetUser.toLowerCase()] = data;
                      localStorage.setItem('gamificationData', JSON.stringify(allData2));
                    } catch (_) {}
                 }
                 docRef.set(payload, { merge: true }).catch(err => console.error("Error auto-pushing stats:", err));
              };
              if (typeof data._cloudSyncedPoints === 'number') {
                 pushWithBase(data._cloudSyncedPoints);
              } else {
                 docRef.get().then((doc) => {
                    const cloudPoints = doc && doc.exists ? Number((doc.data() || {}).totalPoints || 0) : 0;
                    pushWithBase(cloudPoints);
                 }).catch(() => {
                    pushWithBase(safePoints);
                 });
              }
           }
        }
      }

      async function calculateUserStatsForUser(usuario = null) {
        const targetUser = usuario || getCurrentSelectedUser();
        
        // Utilitario para estandarizar el dÃ­a (YYYY-MM-DD) de una solicitud
        const getSongDay = (s) => {
          try {
            if (s.day && typeof s.day === 'string') {
              const parts = s.day.split('-');
              if (parts.length === 3) {
                const y = parseInt(parts[0], 10);
                const m = parseInt(parts[1], 10) - 1;
                const d = parseInt(parts[2], 10);
                const dt = new Date(y, m, d);
                if (!isNaN(dt.getTime())) return dt.toISOString().split('T')[0];
              }
              const d2 = new Date(s.day);
              if (!isNaN(d2.getTime())) return d2.toISOString().split('T')[0];
            }
            if (s.ts) {
              const dt = s.ts && s.ts.toDate ? s.ts.toDate() : new Date(s.ts);
              if (!isNaN(dt.getTime())) return dt.toISOString().split('T')[0];
            }
            if (s.timestamp) {
              const dt = s.timestamp && s.timestamp.toDate ? s.timestamp.toDate() : new Date(s.timestamp);
              if (!isNaN(dt.getTime())) return dt.toISOString().split('T')[0];
            }
            if (s.time) {
              const dt = s.time && s.time.toDate ? s.time.toDate() : new Date(s.time);
              if (!isNaN(dt.getTime())) return dt.toISOString().split('T')[0];
            }
          } catch (_) {}
          return new Date().toISOString().split('T')[0];
        };
        
        // Normalizador para detectar "Zero FM" o variantes (espacios/MayÃºsculas)
      const isZeroFM = (name) => {
        const n = String(name || '').toLowerCase();
        return n.includes('zerofm') || n.includes('zero fm');
      };
        
        // Determinar si una solicitud estÃ¡ marcada como reproducida
        const isEntryPlayed = (s) => {
          try {
            const day = getSongDay(s);
            // Usar la hora almacenada si existe, sino calcularla de forma segura (HH:MM)
            const hour = s.hora || (window.toHourKey ? window.toHourKey(s.ts || s.timestamp || s.time) : toHour(s.ts || s.timestamp || s.time));
            const sid = `${s.usuario}-${s.cancion}-${s.artista}-${hour}`.replace(/[^a-zA-Z0-9-]/g, '');
            const playedMap = getLocalPlayedMap();
            const skippedMap = getLocalSkippedMap();
            const dayArr = Array.isArray(playedMap[day]) ? playedMap[day] : [];
            const skippedArr = Array.isArray(skippedMap[day]) ? skippedMap[day] : [];
            const skippedSet = new Set(skippedArr.map(x => String(x || '')));
            return sid && dayArr.includes(sid) && !skippedSet.has(String(sid || ''));
          } catch (_) {
            return false;
          }
        };
        
        try {
          // Obtener datos combinados de Firebase y localStorage
          const allSolicitudes = await getAllCombinedSolicitudes();
          
          const userSongs = allSolicitudes.filter(s => s.usuario === targetUser && !isTestRequestForStats(s));
          console.log(`ğŸµ ${targetUser}: ${userSongs.length} canciones encontradas de ${allSolicitudes.length} totales`);
          
          const uniqueArtists = [...new Set(userSongs.map(s => s.artista))].length;
          const playedSongs = userSongs.filter(isEntryPlayed);
          const totalPlayedSongs = playedSongs.length;
          const uniqueArtistsPlayed = [...new Set(playedSongs.map(s => s.artista))].length;
          console.log(`ğŸ¤ ${targetUser}: ${uniqueArtists} artistas Ãºnicos`);
          
          // Calcular el mÃ¡ximo de pedidos por artista (para logros del mismo artista)
          const artistCounts = userSongs.reduce((acc, s) => {
            const k = (s.artista || '').toLowerCase();
            if (!k) return acc;
            acc[k] = (acc[k] || 0) + 1;
            return acc;
          }, {});
          const topArtistCount = Object.values(artistCounts).reduce((max, n) => Math.max(max, n), 0);
          const playedArtistCounts = playedSongs.reduce((acc, s) => {
            const k = (s.artista || '').toLowerCase();
            if (!k) return acc;
            acc[k] = (acc[k] || 0) + 1;
            return acc;
          }, {});
          const topArtistCountPlayed = Object.values(playedArtistCounts).reduce((max, n) => Math.max(max, n), 0);
          
          // Calcular dÃ­as Ãºnicos usando getSongDay
          const uniqueDays = [...new Set(userSongs.map(getSongDay))].length;
          console.log(`ğŸ“… ${targetUser}: ${uniqueDays} dÃ­as Ãºnicos de actividad`);
          
          // Canciones de Zero FM
          const zeroFMSongs = userSongs.filter(s => isZeroFM(s.artista)).length;
          const zeroFMSongsPlayed = playedSongs.filter(s => isZeroFM(s.artista)).length;
          
          // â€œPrimero en pedirâ€: contar dÃ­as donde el primer pedido del dÃ­a es del usuario
          // SOLO si hubo al menos 2 solicitudes ese dÃ­a
          const allWithTime = allSolicitudes.filter(s => (s.timestamp || s.ts || s.time) && !isTestRequestForStats(s));
          const earliestByDay = new Map();
          const countsByDay = new Map();
          
          allWithTime.forEach(s => {
            let dt;
            try {
              dt = s.ts && s.ts.toDate ? s.ts.toDate() : new Date(s.timestamp || s.ts || s.time);
            } catch (_) {
              dt = new Date(s.timestamp || s.ts || s.time);
            }
            const day = getSongDay(s);
            countsByDay.set(day, (countsByDay.get(day) || 0) + 1);
            const curr = earliestByDay.get(day);
            if (!curr || dt < curr.dt) {
              earliestByDay.set(day, { usuario: s.usuario, dt, day });
            }
          });
          let firstRequests = 0;
          earliestByDay.forEach(({ usuario, day }) => {
            if (usuario === targetUser && (countsByDay.get(day) || 0) >= 2) firstRequests++;
          });
          
          // Verificar estado VIP desde Firebase (sets globales)
          const vipSetAvailable = typeof vipSet !== 'undefined';
          const z0VipSetAvailable = typeof z0VipSet !== 'undefined';
          const isVip = (vipSetAvailable && vipSet.has(targetUser)) || (z0VipSetAvailable && z0VipSet.has(targetUser));

          // Obtener datos de gamificaciÃ³n existentes para preservar rachas
          const existingData = getGamificationDataForUser(targetUser);
          const bestStreak = existingData.streaks ? existingData.streaks.best : 0;

          return {
            totalSongs: userSongs.length,
            totalPlayedSongs,
            uniqueArtists,
            uniqueArtistsPlayed,
            activeDays: uniqueDays,
            isVip,
            bestStreak,
            topArtistCount,
            topArtistCountPlayed,
            firstRequests,
            zeroFMSongs,
            zeroFMSongsPlayed
          };
        } catch (error) {
          console.error('Error al calcular estadÃ­sticas del usuario:', error);
          // Fallback a localStorage
          const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          
          const userSongs = solicitudes.filter(s => s.usuario === targetUser);
          const uniqueArtists = [...new Set(userSongs.map(s => s.artista))].length;
          const playedSongs = userSongs.filter(isEntryPlayed);
          const totalPlayedSongs = playedSongs.length;
          const uniqueArtistsPlayed = [...new Set(playedSongs.map(s => s.artista))].length;
          
          // Calcular el mÃ¡ximo de pedidos por artista (para logros del mismo artista)
          const artistCounts = userSongs.reduce((acc, s) => {
            const k = (s.artista || '').toLowerCase();
            if (!k) return acc;
            acc[k] = (acc[k] || 0) + 1;
            return acc;
          }, {});
          const topArtistCount = Object.values(artistCounts).reduce((max, n) => Math.max(max, n), 0);
          const playedArtistCounts = playedSongs.reduce((acc, s) => {
            const k = (s.artista || s.artist || '').toLowerCase();
            if (!k) return acc;
            acc[k] = (acc[k] || 0) + 1;
            return acc;
          }, {});
          const topArtistCountPlayed = Object.values(playedArtistCounts).reduce((max, n) => Math.max(max, n), 0);
          
          const uniqueDays = [...new Set(userSongs.map(getSongDay))].length;
          
          // Canciones de Zero FM (fallback local)
          const zeroFMSongs = (userSongs || []).filter(s => {
            const artist = (s.artist || '').toLowerCase();
            return artist.includes('zero fm') || artist.includes('zerofm');
          }).length;
          const zeroFMSongsPlayed = (playedSongs || []).filter(s => {
            const artist = (s.artist || s.artista || '').toLowerCase();
            return artist.includes('zero fm') || artist.includes('zerofm');
          }).length;
          
          // â€œPrimero en pedirâ€ por dÃ­a con condiciÃ³n de mÃ­nimo 2 solicitudes (fallback local)
          const allWithTimeLS = solicitudes.filter(s => s.timestamp || s.ts || s.time);
          const earliestByDayLS = new Map();
          const countsByDayLS = new Map();
          
          allWithTimeLS.forEach(s => {
            const dtRaw = s.timestamp || s.ts || s.time;
            let dt;
            try {
              dt = s.ts && s.ts.toDate ? s.ts.toDate() : new Date(dtRaw);
            } catch (_) {
              dt = new Date(dtRaw);
            }
            const day = s.day ? s.day : getSongDay(s);
            countsByDayLS.set(day, (countsByDayLS.get(day) || 0) + 1);
            const curr = earliestByDayLS.get(day);
            if (!curr || dt < curr.dt) {
              earliestByDayLS.set(day, { usuario: s.usuario, dt, day });
            }
          });
          let firstRequests = 0;
          earliestByDayLS.forEach(({ usuario, day }) => {
            if (usuario === targetUser && (countsByDayLS.get(day) || 0) >= 2) firstRequests++;
          });
          
          // Verificar estado VIP desde Firebase (sets globales)
          const vipSetAvailable = typeof vipSet !== 'undefined' && vipSet;
          const z0VipSetAvailable = typeof z0VipSet !== 'undefined' && z0VipSet;
          const isVip = (vipSetAvailable && vipSet.has(targetUser)) || (z0VipSetAvailable && z0VipSet.has(targetUser));
          
          console.log(`ğŸ‘‘ VerificaciÃ³n VIP para ${targetUser}:`);
          console.log(`   - vipSet disponible: ${vipSetAvailable}`);
          console.log(`   - z0VipSet disponible: ${z0VipSetAvailable}`);
          if (vipSetAvailable) console.log(`   - En vipSet: ${vipSet.has(targetUser)}`);
          if (z0VipSetAvailable) console.log(`   - En z0VipSet: ${z0VipSet.has(targetUser)}`);
          console.log(`   - Es VIP final: ${isVip}`);

          // Obtener datos de gamificaciÃ³n existentes para preservar rachas
          const existingData = getGamificationDataForUser(targetUser);
          const bestStreak = existingData.streaks ? existingData.streaks.best : 0;

          return {
            totalSongs: userSongs.length,
            totalPlayedSongs,
            uniqueArtists,
            uniqueArtistsPlayed,
            activeDays: uniqueDays,
            isVip,
            bestStreak,
            topArtistCount,
            topArtistCountPlayed,
            firstRequests,
            zeroFMSongs,
            zeroFMSongsPlayed
          };
        }
      }



      // Modificar renderGamificationModal para usar el usuario seleccionado
      async function renderGamificationModal() {
        const targetUser = getCurrentSelectedUser();
        console.log(`ğŸ¨ INICIO - Renderizando modal para usuario: ${targetUser}`);
        
        // PRIMER PASO: Intentar sincronizar con la nube para asegurar datos consistentes
        // Esto arregla el problema de "diferentes puntos en diferentes dispositivos"
        let data = await syncGamificationDataWithCloud(targetUser);
        try { subscribeUserStatsPointsForUser(targetUser); } catch (_) {}
        
        if (!data || !data.stats) {
          console.warn(`âš ï¸ No hay datos para ${targetUser}, creando datos bÃ¡sicos`);
          data = {
            points: 0,
            xp: 0,
            level: 1,
            achievements: [],
            streaks: { current: 0, best: 0, calendar: {} },
            stats: { songCount: 0, uniqueArtists: 0, activeDays: 0 }
          };
        }
        
        // Procesar logros para el usuario si es necesario
        console.log(`ğŸ“Š Verificando logros para ${targetUser}...`);
        try {
          data = await processAchievementsForUser(targetUser, data);
          // Si hubo cambios al procesar logros (ej: desbloqueo nuevo), guardar de nuevo
          saveGamificationDataForUser(data, targetUser);
        } catch (error) {
          console.warn(`âš ï¸ Error procesando logros para ${targetUser}:`, error);
        }
        
        // Verificar y otorgar logros de insignias
        console.log(`ğŸ† Verificando logros de insignias para ${targetUser}...`);
        window.grantBadgeAchievement(targetUser);
        const currentLevel = getLevelInfo(data.level);
        const nextLevel = getNextLevelInfo(data.level);
        const progressPercent = ((data.xp - currentLevel.xpRequired) / (nextLevel.xpRequired - currentLevel.xpRequired)) * 100;
        
        // Actualizar informaciÃ³n del usuario
        updateUserHeaderUI(targetUser, data);
        
        console.log(`âœ… InformaciÃ³n actualizada: ${targetUser}, Nivel ${data.level}, ${data.points} puntos`);
        
        // Refrescar paneles con el usuario seleccionado
        // IMPORTANTE: Renderizar transparencia aunque no estÃ© en esa pestaÃ±a para actualizar los valores
        try {
          await renderPointsBreakdownForUser(targetUser, true);
        } catch (_){ }
        
        try {
          await renderPersonalStatsForUser(data, targetUser);
        } catch (_){ }
        
        // Actualizar barra de progreso
        const progressFillEl = document.getElementById('progress-fill');
        const currentXpEl = document.getElementById('current-xp');
        const nextLevelXpEl = document.getElementById('next-level-xp');
        
        if (progressFillEl) progressFillEl.style.width = `${Math.min(progressPercent, 100)}%`;
        if (currentXpEl) currentXpEl.textContent = data.xp - currentLevel.xpRequired;
        if (nextLevelXpEl) nextLevelXpEl.textContent = nextLevel.xpRequired - currentLevel.xpRequired;
        
        // Renderizar logros
        console.log(`ğŸ† Llamando renderAchievementsForUser con datos:`, data);
        try {
          renderAchievementsForUser(data);
        } catch (error) {
          console.error('Error renderizando logros:', error);
        }
        
        // Renderizar rachas
        console.log(`ğŸ”¥ Llamando renderStreaksForUser con datos:`, data);
        try {
          await renderStreaksForUser(data);
        } catch (error) {
          console.error('Error renderizando rachas:', error);
        }
        // Actualizar selector de usuario
        populateUserSelector().then(() => {
          const userSelect = document.getElementById('gamification-user-select');
          console.log(`ğŸ¯ Configurando selector: targetUser=${targetUser}, getCurrentUser()=${getCurrentUser()}`);
          
          if (userSelect) {
            if (targetUser !== getCurrentUser()) {
              userSelect.value = targetUser;
              console.log(`âœ… Selector configurado a: ${targetUser}`);
            } else {
              userSelect.value = '';
              console.log(`ğŸ  Usuario actual, selector limpio`);
            }
          }
        }).catch(console.error);
      }

      function renderAchievementsForUser(data) {
        console.log(`ğŸ† Renderizando logros para usuario:`, data.achievements);
        
        const container = document.getElementById('achievements-list');
        if (!container) {
          console.error('âŒ Contenedor achievements-list no encontrado');
          return;
        }
        
        if (!ACHIEVEMENTS || ACHIEVEMENTS.length === 0) {
          console.error('âŒ No hay logros definidos');
          return;
        }
        
        console.log(`ğŸ¯ Renderizando ${ACHIEVEMENTS.length} logros con progreso`);
        
        container.innerHTML = ACHIEVEMENTS.map(achievement => {
          const isUnlocked = data.achievements.includes(achievement.id);
          const prog = typeof getAchievementProgress === 'function'
            ? getAchievementProgress(achievement, data.stats || {})
            : null;
          
          return `
            <div class="achievement-card ${isUnlocked ? 'unlocked' : 'locked'}">
              <div class="achievement-points">+${achievement.points}</div>
              <div class="achievement-icon">${achievement.icon}</div>
              <div class="achievement-title">${achievement.title}</div>
              <div class="achievement-description">${achievement.description}</div>
              ${prog ? `
              <div class="achievement-progress">
                <div class="progress-bar">
                  <div class="progress-fill" style="width: ${prog.percent}%;"></div>
                </div>
                <div class="progress-text">${prog.current}/${prog.target} ${prog.unit}</div>
              </div>` : ''}
            </div>
          `;
        }).join('');
      }

      function getAchievementProgressForUser(achievement, stats) {
        const id = achievement.id;
        
        if (id === 'first_song' || id === 'music_lover' || id === 'music_addict' || id === 'music_master') {
          const targets = { first_song: 1, music_lover: 10, music_addict: 50, music_master: 100 };
          return `${stats.totalSongs}/${targets[id]} canciones`;
        }
        
        if (id === 'diverse_taste' || id === 'explorer') {
          const targets = { diverse_taste: 10, explorer: 25 };
          return `${stats.uniqueArtists}/${targets[id]} artistas`;
        }
        
        if (id === 'streak_starter' || id === 'streak_master' || id === 'streak_legend') {
          const targets = { streak_starter: 3, streak_master: 7, streak_legend: 30 };
          const bestStreak = stats.bestStreak || 0;
          return `${bestStreak}/${targets[id]} dÃ­as`;
        }
        
        if (id === 'daily_user') {
          return `${stats.activeDays}/10 dÃ­as`;
        }
        
        return null;
      }

      async function renderStreaksForUser(data) {
        console.log(`ğŸ”¥ Renderizando rachas para usuario:`, data.streaks);
        
        const currentStreakEl = document.getElementById('current-streak');
        const bestStreakEl = document.getElementById('best-streak');
        
        if (currentStreakEl) {
          currentStreakEl.textContent = `${data.streaks.current || 0} dÃ­as`;
        } else {
          console.warn('âŒ Elemento current-streak no encontrado');
        }
        
        if (bestStreakEl) {
          bestStreakEl.textContent = `${data.streaks.best || 0} dÃ­as`;
        } else {
          console.warn('âŒ Elemento best-streak no encontrado');
        }
        
        // Renderizar calendario de actividad
        await renderStreakCalendarForUser(data.streaks.calendar || {});
      }

      async function renderStreakCalendarForUser(calendar) {
        try {
          console.log('ğŸ—“ï¸ Renderizando calendario de rachas con datos combinados...');
          
          const container = document.getElementById('streak-calendar-grid');
          if (!container) {
            console.warn('âŒ Contenedor del calendario de rachas no encontrado');
            return;
          }
          
          // Verificar si ya existe un calendario oficial
          const isOfficial = container.getAttribute('data-calendar-source') === 'official';
          const hasContent = container.innerHTML.trim().length > 500 && container.innerHTML.includes('calendar-day');
          
          if (isOfficial && hasContent) {
            console.log('âœ… Calendario oficial ya existe y estÃ¡ completo, no sobrescribir');
            return;
          }

          // Prioridad 1: Usar datos pasados explÃ­citamente (del perfil de usuario)
          let allActivity = {};
          
          if (calendar && Object.keys(calendar).length > 0) {
             console.log('âœ… Usando datos de calendario del perfil:', Object.keys(calendar).length, 'dÃ­as');
             allActivity = calendar;
          } else {
              // Prioridad 2: Fallback a createSimpleCalendar si es el usuario actual
              // (Esto asegura consistencia si estamos viendo nuestra propia info)
              const currentUser = getCurrentUser();
              const selectedUser = typeof getCurrentSelectedUser === 'function' ? getCurrentSelectedUser() : currentUser;
              
              if (normalizeUserKey(currentUser) === normalizeUserKey(selectedUser) && typeof createSimpleCalendar === 'function') {
                  console.log('âœ… Usando createSimpleCalendar para usuario actual');
                  await createSimpleCalendar();
                  return;
              }
              
              // Prioridad 3: Fallback manual con datos locales
              console.log('ğŸ“¦ Fallback: combinando datos manualmente...');
              
              // Obtener TODOS los datos
              const playedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
              const solicitudesByDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
              const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
              
              // 1. Agregar playedSongs
              Object.keys(playedSongs).forEach(function(date) {
                allActivity[date] = (allActivity[date] || 0) + playedSongs[date].length;
              });
              
              // 2. Agregar solicitudes_by_day
              Object.keys(solicitudesByDay).forEach(function(date) {
                const dayData = solicitudesByDay[date] || [];
                allActivity[date] = (allActivity[date] || 0) + dayData.length;
              });
              
              // 3. Agregar solicitudes legacy
              solicitudes.forEach(function(song) {
                if (song.time) {
                  const date = new Date(song.time).toISOString().split('T')[0];
                  allActivity[date] = (allActivity[date] || 0) + 1;
                }
              });
          }
          
          const today = new Date();
          const days = [];
          
          // Generar Ãºltimos 28 dÃ­as
          for (let i = 27; i >= 0; i--) {
            const date = new Date(today.getTime() - (i * 86400000));
            const dateStr = date.toISOString().split('T')[0];
            const isToday = i === 0;
            const activityCount = allActivity[dateStr] || 0;
            
            // Determinar nivel de actividad
            let activityClass = '';
            let activityTitle = dateStr;
            
            if (activityCount > 0) {
              if (activityCount >= 10) {
                activityClass = 'activity-very-high';
                activityTitle += ' - ' + activityCount + ' canciones (Muy activo)';
              } else if (activityCount >= 5) {
                activityClass = 'activity-high';
                activityTitle += ' - ' + activityCount + ' canciones (Activo)';
              } else if (activityCount >= 3) {
                activityClass = 'activity-medium';
                activityTitle += ' - ' + activityCount + ' canciones (Activo)';
              } else {
                activityClass = 'activity-low';
                activityTitle += ' - ' + activityCount + ' canciÃ³n' + (activityCount > 1 ? 'es' : '') + ' (Poco activo)';
              }
            } else {
              activityTitle += ' - Sin actividad';
            }
            
            days.push('<div class="calendar-day ' + activityClass + (isToday ? ' today' : '') + '" title="' + activityTitle + '">' + date.getDate() + '</div>');
          }
          
          container.innerHTML = days.join('');
          container.setAttribute('data-calendar-source', 'fallback-v2');
          console.log('âœ… Calendario renderizado con datos (fallback-v2)');
          
        } catch (error) {
          console.error('Error renderizando calendario de rachas:', error);
          const container = document.getElementById('streak-calendar-grid');
          if (container) {
            container.innerHTML = '<div class="calendar-day">Error al cargar actividad</div>';
          }
        }
      }

      // ===== NavegaciÃ³n de calendario de rachas (mes completo) =====
      const monthNamesEs = ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'];
      const calendarState = { month: new Date().getMonth(), year: new Date().getFullYear(), initialized: false };

      async function populateYearOptionsForCalendar() {
        const yearSelect = document.getElementById('year-select');
        if (!yearSelect) return;
        let minYear = new Date().getFullYear() - 2;
        let maxYear = new Date().getFullYear() + 1;
        try {
          const all = await getAllCombinedSolicitudes();
          const years = all.map(s => {
            const d = s.ts ? new Date(s.ts) : (s.day ? new Date(s.day) : null);
            return d && !isNaN(d.getTime()) ? d.getFullYear() : null;
          }).filter(Boolean);
          if (years.length) {
            minYear = Math.min(...years);
            maxYear = Math.max(...years);
          }
        } catch (e) {}
        const options = [];
        for (let y = maxYear; y >= minYear; y--) {
          options.push(`<option value="${y}">${y}</option>`);
        }
        yearSelect.innerHTML = options.join('');
      }

      function setCalendarTitle(month, year) {
        const titleEl = document.querySelector('.streak-calendar h4');
        if (titleEl) {
          titleEl.textContent = `ğŸ“… Actividad - ${monthNamesEs[month]} ${year}`;
        }
      }

      async function initStreakCalendarNavigation() {
        const prevBtn = document.getElementById('prev-month');
        const nextBtn = document.getElementById('next-month');
        const monthSelect = document.getElementById('month-select');
        const yearSelect = document.getElementById('year-select');
        const grid = document.getElementById('streak-calendar-grid');
        if (!grid || !monthSelect || !yearSelect || !prevBtn || !nextBtn) {
          return;
        }
        if (!calendarState.initialized) {
          await populateYearOptionsForCalendar();
          const now = new Date();
          calendarState.month = now.getMonth();
          calendarState.year = now.getFullYear();
          monthSelect.value = String(calendarState.month);
          yearSelect.value = String(calendarState.year);
          prevBtn.addEventListener('click', async () => {
            if (calendarState.month === 0) {
              calendarState.month = 11;
              calendarState.year--;
              yearSelect.value = String(calendarState.year);
            } else {
              calendarState.month--;
            }
            monthSelect.value = String(calendarState.month);
            await renderSelectedMonth();
          });
          nextBtn.addEventListener('click', async () => {
            if (calendarState.month === 11) {
              calendarState.month = 0;
              calendarState.year++;
              yearSelect.value = String(calendarState.year);
            } else {
              calendarState.month++;
            }
            monthSelect.value = String(calendarState.month);
            await renderSelectedMonth();
          });
          monthSelect.addEventListener('change', async () => {
            calendarState.month = parseInt(monthSelect.value, 10) || calendarState.month;
            await renderSelectedMonth();
          });
          yearSelect.addEventListener('change', async () => {
            calendarState.year = parseInt(yearSelect.value, 10) || calendarState.year;
            await renderSelectedMonth();
          });
          calendarState.initialized = true;
        }
        await renderSelectedMonth();
      }

      async function renderSelectedMonth() {
        const username = getCurrentSelectedUser ? getCurrentSelectedUser() : getCurrentUser();
        await renderMonthForUser(username, calendarState.month, calendarState.year);
      }

      async function renderMonthForUser(username, month, year) {
        try {
          const activity = await computeActivityForMonth(username, month, year);
          renderMonthGrid(activity, month, year);
          setCalendarTitle(month, year);
        } catch (e) {
          console.error('Error renderizando mes:', e);
        }
      }

      async function computeActivityForMonth(username, month, year) {
        const activity = {};
        try {
           const normUser = String(username||'').trim().replace(/^@/,'').toLowerCase();
           const all = await getAllCombinedSolicitudes();
           
           // TambiÃ©n considerar las reproducidas para pintar dÃ­as activos
           // A veces un usuario no pide, pero si le reproducen canciones antiguas, Â¿cuenta?
           // Generalmente "actividad" es pedir canciones. Pero si la regla es "canciones reproducidas cuentan", deberÃ­amos incluirlas.
           // Por ahora, nos basamos en SOLICITUDES que es lo que define "actividad" principal en este contexto (pedir).
           // Si el usuario quiere que "reproducidas" tambiÃ©n pinten el calendario, habrÃ­a que cruzar datos.
           // Asumiremos que actividad = solicitudes hechas ese dÃ­a.
           
           all.forEach(s => {
            const u = String(s.usuario||'').trim().replace(/^@/,'').toLowerCase();
            if (u !== normUser) return;
            
            let d = null;
            if (s.ts) {
              d = new Date(s.ts);
            } else if (s.day) {
              // Ajuste de zona horaria para strings de fecha (YYYY-MM-DD)
              // Al hacer new Date("YYYY-MM-DD") es UTC. Queremos evitar desfases de dÃ­a.
              const parts = String(s.day).split('-');
              if (parts.length === 3) {
                // Crear fecha local a las 12:00 para evitar bordes
                d = new Date(parseInt(parts[0],10), parseInt(parts[1],10)-1, parseInt(parts[2],10), 12, 0, 0);
              } else {
                d = new Date(s.day);
              }
            }
            
            if (!d || isNaN(d.getTime())) return;
            
            if (d.getMonth() === month && d.getFullYear() === year) {
              // Construir key local YYYY-MM-DD
              const y = d.getFullYear();
              const m = String(d.getMonth() + 1).padStart(2, '0');
              const da = String(d.getDate()).padStart(2, '0');
              const key = `${y}-${m}-${da}`;
              activity[key] = (activity[key] || 0) + 1;
            }
          });
        } catch (e) { console.error(e); }
        return activity;
      }

      function renderMonthGrid(activityByDay, month, year) {
        const grid = document.getElementById('streak-calendar-grid');
        if (!grid) return;
        grid.innerHTML = '';
        const firstDay = new Date(year, month, 1);
        const startDow = firstDay.getDay(); // 0=Domingo
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const prevMonthDays = new Date(year, month, 0).getDate();
        const totalCells = 42; // 6 semanas
        const today = new Date();
        for (let i = 0; i < totalCells; i++) {
          let displayDay, displayMonth = month, displayYear = year, isOther = false;
          if (i < startDow) {
            displayDay = prevMonthDays - (startDow - 1 - i);
            if (month === 0) {
              displayMonth = 11; displayYear = year - 1;
            } else {
              displayMonth = month - 1;
            }
            isOther = true;
          } else if (i >= startDow + daysInMonth) {
            displayDay = i - (startDow + daysInMonth) + 1;
            if (month === 11) {
              displayMonth = 0; displayYear = year + 1;
            } else {
              displayMonth = month + 1;
            }
            isOther = true;
          } else {
            displayDay = i - startDow + 1;
          }
          const dateObj = new Date(displayYear, displayMonth, displayDay);
          const dateKey = dateObj.toISOString().split('T')[0];
          const count = activityByDay[dateKey] || 0;
          let activityClass = '';
          if (count > 0) {
            if (count >= 10) activityClass = 'activity-very-high';
            else if (count >= 5) activityClass = 'activity-high';
            else if (count >= 3) activityClass = 'activity-medium';
            else activityClass = 'activity-low';
          }
          const isToday = today.getFullYear() === displayYear && today.getMonth() === displayMonth && today.getDate() === displayDay;
          const cell = document.createElement('div');
          cell.className = `calendar-day ${activityClass}${isToday ? ' today' : ''}${isOther ? ' other-month' : ''}`;
          cell.setAttribute('title', `${dateKey}${count ? ` - ${count} canciÃ³n${count!==1?'es':''}` : ' - Sin actividad'}`);
          cell.setAttribute('data-date', dateKey);
          cell.setAttribute('data-songs', String(count));
          cell.textContent = String(displayDay);
          grid.appendChild(cell);
        }
      }

      // NUEVA funciÃ³n simplificada para contar canciones toggleadas (Reproducidas)
      async function countTotalToggledSongsForUser(usuario) {
         try {
           const norm = String(usuario||'').trim().toLowerCase().replace(/^@/,'');
           const sanitize = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9-]/g,'');
           const prefix = sanitize(`${norm}-`);
           const ids = new Set();
           
           // 1. LocalStorage
           try {
             const localPlayed = JSON.parse(localStorage.getItem('playedSongs') || '{}');
             Object.keys(localPlayed).forEach(day => {
               if (!isOnOrAfterStart(day)) return;
               const arr = Array.isArray(localPlayed[day]) ? localPlayed[day] : [];
               arr.forEach(x => {
                 const id = sanitize(x);
                 if (id.startsWith(prefix)) ids.add(id);
               });
             });
           } catch(e){}

           // 2. Firestore playedSongs
           try {
             const snap = await db.collection('playedSongs').get();
             snap.forEach(doc => {
               const day = doc.id;
               if (!isOnOrAfterStart(day)) return;
               const d = doc.data()||{};
               const arr = Array.isArray(d.songs) ? d.songs : (Array.isArray(d.list) ? d.list : []);
               arr.forEach(x => {
                 const id = sanitize(x);
                 if (id.startsWith(prefix)) ids.add(id);
               });
             });
           } catch(e){}
           
           // 3. System Events (unmark/mark logic)
           try {
             const qs = await db.collection('systemEvents').where('type','==','togglePlayed').where('usuario','==',norm).get();
             const latest = {};
             qs.forEach(doc => {
                const d = doc.data()||{};
                const sid = sanitize(d.songId);
                if (!sid) return;
                const ts = d.ts && d.ts.toMillis ? d.ts.toMillis() : 0;
                const k = sid; // Solo ID importa, no el dÃ­a
                if (!latest[k] || ts > latest[k].ts) {
                  latest[k] = { action: d.action, ts };
                }
             });
             Object.keys(latest).forEach(sid => {
                if (latest[sid].action === 'mark') ids.add(sid);
                else if (latest[sid].action === 'unmark') ids.delete(sid);
             });
           } catch(e){}

           return ids.size;
         } catch(e) { return 0; }
      }

      // NUEVA funciÃ³n para contar solicitudes histÃ³ricas de un usuario (TOTALES)
      async function countTotalRequestedSongsForUser(usuario) {
         try {
           const norm = String(usuario||'').trim().toLowerCase().replace(/^@/,'');
           if (!norm) return 0;
           
           // 1. Obtener de Firestore (donde estÃ¡ el histÃ³rico completo)
           const snap = await db.collection('solicitudes').where('usuario', '==', norm).get();
           
           // Si Firestore falla o estÃ¡ vacÃ­o, intentamos localStorage pero priorizamos Firestore
           // Nota: where('usuario') es case-sensitive en Firestore, por lo que puede fallar si el casing no coincide.
           // Mejor estrategia: traer todo y filtrar en cliente o confiar en un Ã­ndice correcto.
           // Dado el volumen, filtrar en cliente de getAllCombinedSolicitudes es mÃ¡s seguro para coincidir casing.
           
           const all = await getAllCombinedSolicitudes();
           const filtered = all.filter(s => {
              const u = String(s.usuario||'').trim().replace(/^@/,'').toLowerCase();
              const d = String(s.day || (s.fecha||'').split('T')[0] || '').trim();
              if (d && window.isOnOrAfterStart && !window.isOnOrAfterStart(d)) return false;
              return u === norm;
           });
           
           return filtered.length;
         } catch(e) { console.error(e); return 0; }
      }

      async function renderPersonalStatsForUser(data, usuario) {
        const stats = (data && data.stats) || {};
        const targetUser = usuario || getCurrentSelectedUser();
        const normUser = String(targetUser || '').trim().replace(/^@/, '').toLowerCase();
        
        console.log(`ğŸ“Š Renderizando estadÃ­sticas para ${targetUser}:`, stats);
        
        const totalSongsEl = document.getElementById('personal-total-songs');
        const totalPlayedEl = document.getElementById('personal-total-played');
        const uniqueArtistsEl = document.getElementById('personal-unique-artists');
        const activeDaysEl = document.getElementById('personal-active-days');
        
        // --- NUEVA LÃ“GICA: Calcular canciones reproducidas (toggleadas) de cero ---
        try {
          const totalToggled = await countTotalToggledSongsForUser(targetUser);
          if (totalPlayedEl) totalPlayedEl.textContent = String(totalToggled);
          
          // Actualizar globalmente para consistencia
          setPlayedStat(totalToggled); 
        } catch(e) {
          // if (totalPlayedEl) totalPlayedEl.textContent = '0';
        }

        /* 
           BLOQUE ANTERIOR ELIMINADO: 
           Antes aquÃ­ habÃ­a una llamada a computeLocalSolicitudesStats que causaba el parpadeo 129 -> 130.
           Al quitarla y depender solo de countTotalRequestedSongsForUser (abajo), aseguramos consistencia.
        */

        // --- NUEVA LÃ“GICA: Calcular canciones pedidas (Requested) de cero ---
        try {
           // Primero intentar una actualizaciÃ³n rÃ¡pida si tenemos datos locales, pero SIN escribir si es 0 y sabemos que hay mÃ¡s
           // Para evitar el parpadeo 129 -> 130, vamos directo a la fuente completa combinada.
           // Pero getAllCombinedSolicitudes puede ser lenta.
           // La inconsistencia reportada es "129 y despuÃ©s 130".
           // Esto significa que primero pintÃ³ 129 (local) y luego 130 (total).
           // Para arreglarlo, vamos a NO pintar el parcial si podemos evitarlo, o confiar solo en el total.
           
           const totalRequested = await countTotalRequestedSongsForUser(targetUser);
           stableSetStat('personal-total-songs', totalRequested, targetUser);
           
           // TambiÃ©n recalcular artistas Ãºnicos y dÃ­as activos con la lista completa
           const all = await getAllCombinedSolicitudes();
           const userSolicitudes = all.filter(s => String(s.usuario||'').trim().replace(/^@/,'').toLowerCase() === normUser);
           
           const uniqueArtists = new Set(userSolicitudes.map(s => s.artista).filter(Boolean)).size;
           const activeDays = new Set(userSolicitudes.map(s => String(s.day || (s.fecha||'').split('T')[0] || '').trim()).filter(d => d)).size;
           
           stableSetStat('personal-unique-artists', uniqueArtists, targetUser);
           stableSetStat('personal-active-days', activeDays, targetUser);
           
        } catch(e) { console.error('Error counting requested:', e); }
        
        // ... Resto de la lÃ³gica para otros stats (rank) ...
        
        try {
          const allSolicitudes = await getAllCombinedSolicitudes();
          const userCounts = {};
          allSolicitudes.forEach(s => {
            const day = String(s.day || (s.fecha||'').split('T')[0] || '').trim();
            if (day && window.isOnOrAfterStart && !window.isOnOrAfterStart(day)) return; // Restaurado filtro de fecha
            const key = String(s.usuario || '').trim().replace(/^@/, '').toLowerCase();
            userCounts[key] = (userCounts[key] || 0) + 1;
          });
          const sortedUsers = Object.entries(userCounts).sort((a, b) => b[1] - a[1]);
          const userRank = sortedUsers.findIndex(([user]) => user === normUser) + 1;
          const personalRankEl = document.getElementById('personal-rank');
          if (personalRankEl) personalRankEl.textContent = userRank > 0 ? `#${userRank}` : '-';
        } catch (error) {
           // Fallback rank
        }
        
        // Renderizar gÃ©neros favoritos (simulado)
        renderFavoriteGenresForUser();
      }

      async function renderFavoriteGenresForUser() {
        await renderFavoriteGenres();
      }
      

      // Event listeners para el selector de usuario
      document.getElementById('gamification-user-select')?.addEventListener('change', async (e) => {
        const userSelect = document.getElementById('gamification-user-select');
        const backBtn = document.getElementById('back-to-my-profile');
        const badgeSelect = document.getElementById('badge-select');
        
        console.log(`ğŸ”„ Selector cambiÃ³ a: ${e.target.value}`);
        
        if (e.target.value) {
          await switchToUser(e.target.value);
        }
        
        // Si se selecciona un usuario diferente al actual, ocultar selector y mostrar botÃ³n "Cambiar Usuario"
        if (e.target.value && e.target.value !== getCurrentUser()) {
          if (userSelect) {
            userSelect.style.display = 'none';
          }
          if (backBtn) {
            backBtn.style.display = 'inline-block';
          }
        } else {
          // Mostrar selector y ocultar botÃ³n si se escoge el usuario actual o se limpia la selecciÃ³n
          if (userSelect) {
            userSelect.style.display = 'block';
          }
          if (backBtn) {
            backBtn.style.display = 'none';
          }
        }

        const target = e.target.value || getCurrentUser();
        try { localStorage.setItem('lastProfileUser', String(target||'')); } catch(_){}
        populateBadgeSelectForUser(target);
      });

      document.getElementById('back-to-my-profile')?.addEventListener('click', async () => {
        const userSelect = document.getElementById('gamification-user-select');
        const backBtn = document.getElementById('back-to-my-profile');
        
        // Mostrar el selector de nuevo
        if (userSelect) {
          userSelect.style.display = 'block';
          userSelect.value = ''; // Resetear selecciÃ³n
        }
        
        // Ocultar botÃ³n "Cambiar Usuario"
        if (backBtn) {
          backBtn.style.display = 'none';
        }
        
        // Volver al usuario actual
        await switchToUser('');
      });

      // Inicializar al cargar la pÃ¡gina
      initGamification().catch(console.error);

      function getEarnedBadgesForUser(username) {
        const key = String(username || '').trim().replace(/^@/, '').toLowerCase();
        const res = [];
        if (window.vipSet && window.vipSet.has(key)) res.push('vip');
        if (window.z0VipSet && window.z0VipSet.has(key)) res.push('z0-vip');
        if (window.donadorSet && window.donadorSet.has(key)) res.push('donador');
        if (window.z0FanSet && window.z0FanSet.has(key)) res.push('z0-fan');
        if (window.z0PlatinumSet && window.z0PlatinumSet.has(key)) res.push('z0-platino');
        return res;
      }

      function populateBadgeSelectForUser(username) {
        const select = document.getElementById('badge-select');
        if (!select) return;
        const earned = getEarnedBadgesForUser(username);
        select.innerHTML = '';
        const titles = { '':'Ninguna','vip':'VIP','z0-vip':'z0Vip','donador':'Donador','z0-fan':'z0','z0-platino':'VIP Platino' };
        const noneOpt = document.createElement('option');
        noneOpt.value = '';
        noneOpt.textContent = titles[''];
        select.appendChild(noneOpt);
        earned.forEach(b => { const opt = document.createElement('option'); opt.value = b; opt.textContent = titles[b] || b; select.appendChild(opt); });
        const key = String(username || '').trim().toLowerCase();
        const currentSelected = (window.selectedBadgeMap && window.selectedBadgeMap[key]) || '';
        const fallback = getCurrentMembership(username);
        select.value = earned.includes(currentSelected) ? currentSelected : (earned.includes(fallback) ? fallback : '');
        select.disabled = false;
      }

      function getCurrentMembership(username) {
        const key = String(username || '').trim().replace(/^@/, '').toLowerCase();
        if (window.vipSet && window.vipSet.has(key)) return 'vip';
        if (window.z0VipSet && window.z0VipSet.has(key)) return 'z0-vip';
        if (window.z0PlatinumSet && window.z0PlatinumSet.has(key)) return 'z0-platino';
        if (window.donadorSet && window.donadorSet.has(key)) return 'donador';
        if (window.z0FanSet && window.z0FanSet.has(key)) return 'z0-fan';
        return '';
      }

      async function setUserBadgeInFirestore(username, badge) {
        const map = {
          'vip': 'vipUsers',
          'z0-vip': 'z0VipUsers',
          'z0-fan': 'z0FanUsers',
          'z0-platino': 'z0PlatinumUsers',
          'donador': 'donadorUsers'
        };
        const collections = Object.values(map);
        for (const col of collections) {
          try { await db.collection(col).doc(username).delete(); } catch (_) {}
        }
        if (!badge) return;
        const targetCol = map[badge];
        if (!targetCol) return;
        if (badge === 'donador') {
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          tomorrow.setHours(23, 59, 59, 999);
          const expiresAt = tomorrow.toISOString();
          await db.collection(targetCol).doc(username).set({ name: username, expiresAt, createdAt: new Date().toISOString() }, { merge: true });
        } else {
          await db.collection(targetCol).doc(username).set({ name: username }, { merge: true });
        }
      }

      populateBadgeSelectForUser(getCurrentSelectedUser());

      window.getSelectedBadgeFor = function(username) {
        const map = window.selectedBadgeMap || {};
        const key = String(username || '').trim().toLowerCase();
        return map[key] || '';
      }

      async function setUserSelectedBadgeInFirestore(username, badge) {
        const rawName = String(username || '').trim();
        const keyName = rawName.toLowerCase();
        await db.collection('selectedBadges').doc(keyName).set({ name: keyName, badge: badge || '' }, { merge: true });
      }

      window.applySelectedBadgeToItems = function(username) {
        const badge = getSelectedBadgeFor(username);
        document.querySelectorAll('.items .item').forEach(li => {
          const liUserRaw = (li.dataset && li.dataset.username) ? li.dataset.username : (li.querySelector('.usuario')?.textContent || '').trim();
          const liUser = String(liUserRaw || '').trim().toLowerCase();
          const key = String(username || '').trim().toLowerCase();
          if (liUser === key) {
            li.classList.remove('vip','z0-vip','donador','z0-fan','z0-platino');
            if (badge) li.classList.add(badge);
          }
        });
      }

      function applySelectedBadgeToAll() {
        const map = window.selectedBadgeMap || {};
        Object.keys(map).forEach(username => applySelectedBadgeToItems(username));
      }

      function subscribeSelectedBadges() {
        db.collection('selectedBadges').onSnapshot((snap) => {
          const m = {};
          snap.forEach(doc => {
            const d = doc.data();
            if (d && d.name) {
              const key = String(d.name || '').trim().toLowerCase();
              m[key] = (d.badge || '').trim();
            }
          });
          window.selectedBadgeMap = m;
          try { localStorage.setItem('selectedBadges', JSON.stringify(m)); } catch (_) {}
          applySelectedBadgeToAll();
          refreshBadgeSelectUI();
        }, (err) => { console.error('Error suscripciÃ³n selectedBadges:', err); });
      }

      // Inicializar suscripciÃ³n en cuanto estÃ© definida
      try { subscribeSelectedBadges(); } catch (_) {}

      function refreshBadgeSelectUI() {
        const username = getCurrentSelectedUser();
        const key = String(username || '').trim().toLowerCase();
        populateBadgeSelectForUser(username);
        const select = document.getElementById('badge-select');
        const currentSelected = (window.selectedBadgeMap && window.selectedBadgeMap[key]) || '';
        const earned = getEarnedBadgesForUser(username);
        if (select) {
          const fallback = getCurrentMembership(username);
          select.value = earned.includes(currentSelected) ? currentSelected : (earned.includes(fallback) ? fallback : '');
        }
        try { renderEarnedBadgesForUser(username); } catch (_) {}
      }

      function renderEarnedBadgesForUser(username) {
        const el = document.getElementById('earned-badges');
        if (!el) return;
        const earned = Array.isArray(getEarnedBadgesForUser(username)) ? getEarnedBadgesForUser(username) : [];
        if (!earned.length) {
          el.innerHTML = '';
          return;
        }
        const label = {
          'z0-fan': 'z0',
          'z0-vip': 'z0Vip',
          'z0-platino': 'VIP Platino',
          'vip': 'VIP',
          'donador': 'Donador'
        };
        el.innerHTML = earned.map(b => `<span class="earned-badge-chip ${b}">${label[b] || b}</span>`).join('');
      }

      document.getElementById('badge-select')?.addEventListener('change', async (e) => {
        const target = getCurrentSelectedUser();
        const badge = e.target.value;
        const earned = getEarnedBadgesForUser(target);
        if (badge && !earned.includes(badge)) {
          showErrorNotification('Solo puedes elegir insignias que ya tienes.');
          {
            const key = String(target || '').trim().toLowerCase();
            e.target.value = (window.selectedBadgeMap && window.selectedBadgeMap[key]) || '';
          }
          return;
        }
        window.selectedBadgeMap = window.selectedBadgeMap || {};
        if (badge) {
          const key = String(target || '').trim().toLowerCase();
          window.selectedBadgeMap[key] = badge;
        } else {
          const key = String(target || '').trim().toLowerCase();
          delete window.selectedBadgeMap[key];
        }
        try { localStorage.setItem('selectedBadges', JSON.stringify(window.selectedBadgeMap)); } catch (_) {}
        applySelectedBadgeToItems(target);
        try {
          await setUserSelectedBadgeInFirestore(target, badge);
        } catch (err) { console.error('Error al actualizar insignia:', err); showErrorNotification('No se pudo actualizar la insignia.'); }
      });

      // FunciÃ³n para actualizar datos de gamificaciÃ³n de un usuario
      function updateGamificationDataForUser(username, userData) {
        try {
          const allData = JSON.parse(localStorage.getItem('gamificationData') || '{}');
          allData[username.toLowerCase()] = userData;
          localStorage.setItem('gamificationData', JSON.stringify(allData));
          console.log(`ğŸ’¾ Datos actualizados para usuario: ${username}`);
        } catch (error) {
          console.error('Error al actualizar datos de gamificaciÃ³n:', error);
        }
      }

      // ===== FUNCIONES PARA MODAL DE CONFIRMACIÃ“N =====
      
      // Variable para almacenar el resolver actual
      let currentConfirmationResolver = null;
      
      // FunciÃ³n para mostrar modal de confirmaciÃ³n personalizado
      function showConfirmation(options) {
        return new Promise((resolve) => {
          console.log('ğŸ” showConfirmation llamada con opciones:', options);
          
          // Verificar que los elementos existen
          if (!confirmationModal || !confirmationCancelBtn || !confirmationConfirmBtn) {
            console.error('âŒ Elementos del modal de confirmaciÃ³n no encontrados');
            resolve(false);
            return;
          }
          
          // Configurar el modal
          confirmationIcon.textContent = options.icon || 'â„¹ï¸';
          confirmationTitle.textContent = options.title || 'ConfirmaciÃ³n';
          confirmationMessage.textContent = options.message || 'Â¿EstÃ¡s seguro?';
          
          // Configurar botones
          const cancelText = options.cancelText !== undefined ? options.cancelText : 'Cancelar';
          const confirmText = options.confirmText || 'Confirmar';
          
          // Establecer texto usando mÃºltiples mÃ©todos para asegurar que funcione
          confirmationCancelBtn.textContent = cancelText;
          confirmationCancelBtn.innerHTML = cancelText;
          confirmationConfirmBtn.textContent = confirmText;
          confirmationConfirmBtn.innerHTML = confirmText;
          
          console.log('ğŸ“ Textos configurados - Cancelar:', cancelText, 'Confirmar:', confirmText);
          console.log('ğŸ“ Texto actual en botones - Cancelar:', confirmationCancelBtn.textContent, 'Confirmar:', confirmationConfirmBtn.textContent);
          
          // Mostrar/ocultar botÃ³n cancelar
          if (cancelText === '') {
            confirmationCancelBtn.style.display = 'none';
          } else {
            confirmationCancelBtn.style.display = 'inline-flex';
            confirmationCancelBtn.style.visibility = 'visible';
            confirmationCancelBtn.style.opacity = '1';
            confirmationCancelBtn.style.pointerEvents = 'auto';
          }
          
          // Asegurar que el botÃ³n confirmar sea visible
          confirmationConfirmBtn.style.display = 'inline-flex';
          confirmationConfirmBtn.style.visibility = 'visible';
          confirmationConfirmBtn.style.opacity = '1';
          confirmationConfirmBtn.style.pointerEvents = 'auto';
          
          // Forzar reflow para asegurar que los cambios se apliquen
          confirmationCancelBtn.offsetHeight;
          confirmationConfirmBtn.offsetHeight;
          
          console.log('ğŸ‘ï¸ Estilos de botones aplicados');
          console.log('Cancelar visible:', window.getComputedStyle(confirmationCancelBtn).display);
          console.log('Confirmar visible:', window.getComputedStyle(confirmationConfirmBtn).display);
          
          // Guardar el resolver actual
          currentConfirmationResolver = resolve;
          
          // Mostrar modal
          confirmationModal.hidden = false;
          console.log('âœ… Modal mostrado');
          
          // Asegurar que los estilos se apliquen despuÃ©s de mostrar el modal
          setTimeout(() => {
            // Forzar visibilidad del botÃ³n cancelar
            confirmationCancelBtn.style.display = 'inline-flex';
            confirmationCancelBtn.style.visibility = 'visible';
            confirmationCancelBtn.style.opacity = '1';
            confirmationCancelBtn.style.position = 'static';
            confirmationCancelBtn.style.width = 'auto';
            confirmationCancelBtn.style.height = 'auto';
            
            // Forzar visibilidad del botÃ³n confirmar
            confirmationConfirmBtn.style.display = 'inline-flex';
            confirmationConfirmBtn.style.visibility = 'visible';
            confirmationConfirmBtn.style.opacity = '1';
            confirmationConfirmBtn.style.position = 'static';
            confirmationConfirmBtn.style.width = 'auto';
            confirmationConfirmBtn.style.height = 'auto';
            confirmationConfirmBtn.style.overflow = 'visible';
            confirmationConfirmBtn.style.clip = 'auto';
            confirmationConfirmBtn.style.margin = '0';
            confirmationConfirmBtn.style.padding = '10px 20px';
            
            // Verificar que ambos botones tengan contenido
            if (!confirmationCancelBtn.textContent.trim()) {
              confirmationCancelBtn.textContent = 'Cancelar';
            }
            if (!confirmationConfirmBtn.textContent.trim()) {
              confirmationConfirmBtn.textContent = 'Confirmar';
            }
            
            console.log('ğŸ”„ Estilos reaplicados despuÃ©s del timeout');
            console.log('Final - Cancelar visible:', window.getComputedStyle(confirmationCancelBtn).display);
            console.log('Final - Confirmar visible:', window.getComputedStyle(confirmationConfirmBtn).display);
            console.log('Final - Cancelar texto:', confirmationCancelBtn.textContent);
            console.log('Final - Confirmar texto:', confirmationConfirmBtn.textContent);
          }, 10);
        });
      }
      
      // Event listeners Ãºnicos para los botones (se configuran una sola vez)
      if (confirmationCancelBtn) {
        confirmationCancelBtn.addEventListener('click', (e) => {
          console.log('ğŸ”˜ BotÃ³n cancelar clickeado');
          e.preventDefault();
          e.stopPropagation();
          confirmationModal.hidden = true;
          if (currentConfirmationResolver) {
            currentConfirmationResolver(false);
            currentConfirmationResolver = null;
          }
        });
        console.log('âœ… Event listener para botÃ³n cancelar configurado');
      } else {
        console.error('âŒ confirmationCancelBtn no encontrado');
      }
      
      if (confirmationConfirmBtn) {
        confirmationConfirmBtn.addEventListener('click', (e) => {
          console.log('âœ… BotÃ³n confirmar clickeado');
          e.preventDefault();
          e.stopPropagation();
          confirmationModal.hidden = true;
          if (currentConfirmationResolver) {
            currentConfirmationResolver(true);
            currentConfirmationResolver = null;
          }
        });
        console.log('âœ… Event listener para botÃ³n confirmar configurado');
      } else {
        console.error('âŒ confirmationConfirmBtn no encontrado');
      }
      
      if (confirmationCloseBtn) {
        confirmationCloseBtn.addEventListener('click', (e) => {
          console.log('âŒ BotÃ³n cerrar clickeado');
          e.preventDefault();
          e.stopPropagation();
          confirmationModal.hidden = true;
          if (currentConfirmationResolver) {
            currentConfirmationResolver(false);
            currentConfirmationResolver = null;
          }
        });
        console.log('âœ… Event listener para botÃ³n cerrar configurado');
      } else {
        console.error('âŒ confirmationCloseBtn no encontrado');
      }
      
      // FunciÃ³n para mostrar notificaciÃ³n de Ã©xito
      function showSuccessNotification(message) {
        showConfirmation({
          icon: 'âœ…',
          title: 'Ã‰xito',
          message: message,
          confirmText: 'Entendido',
          cancelText: ''
        }).then(() => {
          // Solo cerrar el modal
        });
      }
      
      // FunciÃ³n para mostrar notificaciÃ³n de error
      function showErrorNotification(message) {
        showConfirmation({
          icon: 'âŒ',
          title: 'Error',
          message: message,
          confirmText: 'Entendido',
          cancelText: ''
        }).then(() => {
          // Solo cerrar el modal
        });
      }

      // ===== FUNCIONES PARA ADMINISTRACIÃ“N DE RECOMPENSAS =====
      
      // FunciÃ³n para cargar y renderizar solicitudes de recompensas
      async function loadRewardRequests() {
        try {
          // const allRequests = JSON.parse(localStorage.getItem('pendingRewardRequests') || '[]');
          // Cargar desde Firestore
          const snapshot = await db.collection('rewardRequests').get();
          const allRequests = [];
          snapshot.forEach(doc => {
             allRequests.push({ id: doc.id, ...doc.data() });
          });
          
          const statusFilter = adminStatusFilter?.value || 'all';
          const userFilter = adminUserFilter?.value || 'all';
          
          // Filtrar solicitudes
          let filteredRequests = allRequests;
          
          if (statusFilter !== 'all') {
            filteredRequests = filteredRequests.filter(req => req.status === statusFilter);
          }
          
          if (userFilter !== 'all') {
            filteredRequests = filteredRequests.filter(req => req.userId === userFilter);
          }
          
          // Ordenar por timestamp (mÃ¡s recientes primero)
          filteredRequests.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
          
          // Actualizar estadÃ­sticas
          updateAdminStats(allRequests);
          
          // Renderizar lista
          renderAdminRequestsList(filteredRequests);
          
        } catch (error) {
          console.error('Error al cargar solicitudes:', error);
          if(adminRequestsList) {
             adminRequestsList.innerHTML = '<p class="loading-message">Error al cargar solicitudes: ' + error.message + '</p>';
          }
        }
      }
      
      // FunciÃ³n para actualizar estadÃ­sticas del admin
      function updateAdminStats(allRequests) {
        const today = new Date().toDateString();
        
        const pending = allRequests.filter(req => req.status === 'pending').length;
        const approvedToday = allRequests.filter(req => 
          req.status === 'approved' && new Date(req.timestamp).toDateString() === today
        ).length;
        const rejectedToday = allRequests.filter(req => 
          req.status === 'rejected' && new Date(req.timestamp).toDateString() === today
        ).length;
        
        if (totalPendingRequests) totalPendingRequests.textContent = pending;
        if (totalApprovedRequests) totalApprovedRequests.textContent = approvedToday;
        if (totalRejectedRequests) totalRejectedRequests.textContent = rejectedToday;
      }
      
      // FunciÃ³n para renderizar lista de solicitudes
      function renderAdminRequestsList(requests) {
        if (!adminRequestsList) return;
        
        if (requests.length === 0) {
          adminRequestsList.innerHTML = '<p class="loading-message">No hay solicitudes que coincidan con los filtros</p>';
          return;
        }
        
        adminRequestsList.innerHTML = requests.map(request => {
          const date = new Date(request.timestamp);
          const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
          
          return `
            <div class="admin-request-item" data-request-id="${request.id}">
              <div class="admin-request-info">
                <div class="admin-request-header">
                  <span class="admin-request-user">ğŸ‘¤ ${request.userId}</span>
                  <span class="admin-request-status status-${request.status}">${getStatusText(request.status)}</span>
                </div>
                <div class="admin-request-reward">ğŸ ${request.rewardName}</div>
                <div class="admin-request-details">${request.description}</div>
                <div class="admin-request-cost">ğŸ’° ${request.cost} puntos</div>
                <div class="admin-request-timestamp">ğŸ“… ${formattedDate}</div>
              </div>
              <div class="admin-request-actions">
                ${request.status === 'pending' ? `
                  <button class="admin-action-btn admin-approve-btn" onclick="approveRewardRequest('${request.id}')">
                    âœ… Aprobar
                  </button>
                  <button class="admin-action-btn admin-reject-btn" onclick="rejectRewardRequest('${request.id}')">
                    âŒ Rechazar
                  </button>
                ` : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      // FunciÃ³n para obtener texto del estado
      function getStatusText(status) {
        switch (status) {
          case 'pending': return 'Pendiente';
          case 'approved': return 'Aprobada';
          case 'rejected': return 'Rechazada';
          default: return status;
        }
      }
      
      // FunciÃ³n para poblar filtro de usuarios
      async function populateAdminUserFilter() {
        try {
          // const allRequests = JSON.parse(localStorage.getItem('pendingRewardRequests') || '[]');
          const snapshot = await db.collection('rewardRequests').get();
          const allRequests = [];
          snapshot.forEach(doc => allRequests.push(doc.data()));
          
          const users = [...new Set(allRequests.map(req => req.userId))].sort();
          
          if (adminUserFilter) {
            adminUserFilter.innerHTML = '<option value="all">Todos los usuarios</option>' +
              users.map(user => `<option value="${user}">${user}</option>`).join('');
          }
        } catch (error) {
          console.error('Error al cargar usuarios para filtro:', error);
        }
      }
      
      // FunciÃ³n para aprobar solicitud de recompensa (global)
      window.approveRewardRequest = async function(requestId) {
        try {
          const confirmed = await showConfirmation({
            icon: 'âœ…',
            title: 'Aprobar Solicitud',
            message: 'Â¿Confirmas que quieres aprobar esta solicitud de recompensa?',
            confirmText: 'SÃ­, Aprobar',
            cancelText: 'Cancelar'
          });
          
          if (!confirmed) return;
          
          const requestRef = db.collection('rewardRequests').doc(requestId);
          const doc = await requestRef.get();
          
          if (!doc.exists) {
            showErrorNotification('Solicitud no encontrada en base de datos');
            return;
          }
          
          const request = doc.data();
          
          // Ejecutar la recompensa segÃºn su tipo
          if (request.rewardId === 'become_fan') {
            // Agregar usuario a VIP (permanente)
            try {
              const normUser = String(request.userId).toLowerCase().replace(/^@/,'');
              // Buscar el documento del usuario en users o crear referencia directa
              await db.collection('vipUsers').doc(normUser).set({
                name: request.userId,
                addedAt: new Date().toISOString(),
                addedBy: 'reward_system'
              });
              console.log('âœ… Usuario agregado a VIP:', request.userId);
            } catch (error) {
              console.error('Error al agregar usuario a VIP:', error);
              showErrorNotification('Error al procesar la recompensa. Contacta al administrador.');
              return;
            }
          }
          
          // Actualizar estado de la solicitud en Firestore
          await requestRef.update({
             status: 'approved',
             processedAt: new Date().toISOString()
          });
          
          const successMessage = request.rewardId === 'become_fan' 
            ? 'Solicitud aprobada exitosamente. Â¡El usuario ahora es VIP!' 
            : 'Solicitud aprobada exitosamente. Los puntos ya fueron descontados.';
          showSuccessNotification(successMessage);
          
          // Recargar lista
          await loadRewardRequests();
          
        } catch (error) {
          console.error('Error al aprobar solicitud:', error);
          showErrorNotification('Error al aprobar la solicitud: ' + error.message);
        }
      }
      
      // FunciÃ³n para rechazar solicitud de recompensa (global)
      window.rejectRewardRequest = async function(requestId) {
        try {
          console.log('ğŸš« Iniciando rechazo de solicitud:', requestId);
          
          const confirmed = await showConfirmation({
            icon: 'âŒ',
            title: 'Rechazar Solicitud',
            message: 'Â¿Confirmas que quieres rechazar esta solicitud? Los puntos serÃ¡n devueltos al usuario.',
            confirmText: 'SÃ­, Rechazar',
            cancelText: 'Cancelar'
          });
          
          console.log('âœ… Resultado de confirmaciÃ³n:', confirmed);
          
          if (!confirmed) {
            console.log('âŒ Usuario cancelÃ³ el rechazo');
            return;
          }
          
          const requestRef = db.collection('rewardRequests').doc(requestId);
          const doc = await requestRef.get();
          
          if (!doc.exists) {
            showErrorNotification('Solicitud no encontrada en base de datos');
            return;
          }
          
          const request = doc.data();
          
          // Usar batch para actualizar solicitud y devolver puntos atÃ³micamente
          const batch = db.batch();
          const normUser = String(request.userId).toLowerCase().replace(/^@/,'');
          const userStatsRef = db.collection('userStats').doc(normUser);
          
          // Devolver puntos al usuario en Firestore
          batch.set(userStatsRef, {
             totalPoints: firebase.firestore.FieldValue.increment(request.cost),
             updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
          
          // Actualizar estado de la solicitud en Firestore
          batch.update(requestRef, {
             status: 'rejected',
             processedAt: new Date().toISOString()
          });
          
          await batch.commit();
          
          showSuccessNotification(`Solicitud rechazada. Se devolvieron ${request.cost} puntos a ${request.userId}.`);
          
          // Recargar lista
          await loadRewardRequests();
          
        } catch (error) {
          console.error('Error al rechazar solicitud:', error);
          showErrorNotification('Error al rechazar la solicitud: ' + error.message);
        }
      }

      // FunciÃ³n para verificar notificaciones de admin
      function checkAdminNotifications() {
        if (!window.db) return;
        
        // Escuchar cambios en tiempo real solo para solicitudes pendientes
        db.collection('rewardRequests')
          .where('status', '==', 'pending')
          .onSnapshot(snapshot => {
             const count = snapshot.size;
             const badge = document.getElementById('admin-badge');
             
             // Actualizar conjunto global de usuarios con solicitudes pendientes
             const newPendingUsers = new Set();
             snapshot.forEach(doc => {
               const d = doc.data();
               if (d.userId) newPendingUsers.add(String(d.userId).trim().toLowerCase());
             });
             
             // Verificar si hubo cambios en los usuarios pendientes para re-renderizar lista
             const prevSize = window.pendingRewardUsers ? window.pendingRewardUsers.size : 0;
             const hasChanged = prevSize !== newPendingUsers.size || 
                                [...newPendingUsers].some(u => !window.pendingRewardUsers.has(u));
             
             window.pendingRewardUsers = newPendingUsers;
             
             if (hasChanged) {
               console.log('ğŸ Actualizando lista por cambios en solicitudes pendientes');
               // Re-renderizar lista actual para mostrar iconos
               if (window.currentDayItems && typeof renderSolicitudes === 'function') {
                 // Si hay orden manual, aplicarlo
                 const ordered = typeof applyOrder === 'function' && window.currentManualOrder 
                    ? applyOrder(window.currentDayItems, window.currentManualOrder) 
                    : window.currentDayItems;
                 renderSolicitudes(ordered);
               }
             }
             
             if (badge) {
                if (count > 0) {
                   badge.textContent = count;
                   badge.hidden = false;
                   
                   // Enviar notificaciÃ³n del navegador si aumentÃ³ la cuenta y tenemos permiso
                   if (count > (window._lastPendingCount || 0)) {
                      sendBrowserNotification(`Â¡Nueva solicitud de recompensa!`, `Hay ${count} solicitudes pendientes de revisiÃ³n.`);
                   }
                } else {
                   badge.hidden = true;
                }
             }
             window._lastPendingCount = count;
          }, err => {
             console.error("Error escuchando notificaciones admin:", err);
          });
      }

      function sendBrowserNotification(title, body) {
         if (!("Notification" in window)) return;
         
         if (Notification.permission === "granted") {
            new Notification(title, { body, icon: 'favicon.ico' }); // AsegÃºrate de tener un icono o quitar la propiedad
         } else if (Notification.permission !== "denied") {
            Notification.requestPermission().then(permission => {
               if (permission === "granted") {
                  new Notification(title, { body });
               }
            });
         }
      }

      // Inicializar notificaciones al cargar
      setTimeout(checkAdminNotifications, 2000);

      // ===== FUNCIONES PARA MODAL DE CANJE DE PUNTOS =====
      
      // FunciÃ³n para renderizar el modal de recompensas
      async function renderRewardsModal() {
        console.log('ğŸ”„ Renderizando modal de recompensas...');
        const targetUser = getCurrentSelectedUser();
        const userData = getGamificationDataForUser(targetUser);
        console.log('ğŸ‘¤ Usuario objetivo:', targetUser, 'Puntos (local):', userData.points);
        let effectivePoints = Number(userData.points || 0);
        
        // Actualizar informaciÃ³n del usuario
        rewardsUserInfo.textContent = targetUser;
        try {
          const best = await fetchBestUserStatsDoc(targetUser);
          if (best && best.data) {
            const cloudPoints = Number((best.data || {}).totalPoints || 0);
            effectivePoints = cloudPoints;
          }
          rewardsUserPoints.textContent = String(effectivePoints);
        } catch (_) {
          rewardsUserPoints.textContent = String(effectivePoints);
        }
        try {
          userData.points = Math.max(0, Number(effectivePoints) || 0);
          userData._cloudSyncedPoints = userData.points;
          saveGamificationDataForUser(userData, targetUser);
        } catch (_) {}
        
        // Renderizar las tarjetas de recompensas
        const rewardsContainer = document.getElementById('rewards-list');
        rewardsContainer.innerHTML = '';
        
        REWARDS.forEach(reward => {
          const canAfford = effectivePoints >= reward.cost;
          const rewardCard = document.createElement('div');
          rewardCard.className = `reward-card ${canAfford ? 'affordable' : 'expensive'}`;
          
          rewardCard.innerHTML = `
            <div class="reward-icon">${reward.icon}</div>
            <div class="reward-info">
              <h4 class="reward-title">${reward.name}</h4>
              <p class="reward-description">${reward.description}</p>
              <div class="reward-cost">${reward.cost} puntos</div>
            </div>
            <button class="reward-btn" ${!canAfford ? 'disabled' : ''} 
                    onclick="requestReward('${reward.id}', '${targetUser}', ${reward.cost})">
              ${canAfford ? 'Canjear' : 'Insuficiente'}
            </button>
          `;
          
          rewardsContainer.appendChild(rewardCard);
          rewardCard.addEventListener('click', function(){
            rewardCard.classList.add('animate-border');
            setTimeout(function(){ rewardCard.classList.remove('animate-border'); }, 1400);
          });
          rewardCard.addEventListener('touchstart', function(){
            rewardCard.classList.add('animate-border');
            setTimeout(function(){ rewardCard.classList.remove('animate-border'); }, 1400);
          }, { passive: true });
        });
        
        // Renderizar solicitudes pendientes
        await renderPendingRequests(targetUser);
      }
      
      // FunciÃ³n para solicitar una recompensa (global)
      window.requestReward = async function(rewardId, username, cost) {
        console.log('ğŸ Solicitando recompensa:', rewardId, 'para usuario:', username, 'costo:', cost);
        const btn = document.querySelector(`.reward-card button[onclick*="${rewardId}"]`);
        if(btn) { btn.disabled = true; btn.textContent = 'Procesando...'; }

        try {
          console.log('ğŸ“Š Obteniendo datos del usuario...');
          // Obtener puntos actuales de Firestore para asegurar consistencia
          const normUser = normalizeUserKey(username);
          const userDocRef = db.collection('userStats').doc(normUser);
          const userDoc = await userDocRef.get();
          
          let currentPoints = 0;
          if (userDoc.exists) {
             currentPoints = Number(userDoc.data().totalPoints || 0);
          } else {
             // Fallback a local si no existe en DB (aunque deberÃ­a)
             const localData = getGamificationDataForUser(username);
             currentPoints = localData.points || 0;
          }

          console.log('ğŸ‘¤ Puntos actuales (DB):', currentPoints);
          
          if (currentPoints < cost) {
            showErrorNotification('No tienes suficientes puntos para esta recompensa.');
            if(btn) { btn.disabled = false; btn.textContent = 'Canjear'; }
            return;
          }
          
          console.log('ğŸ” Buscando recompensa en configuraciÃ³n...');
          const reward = REWARDS.find(r => r.id === rewardId);
          if (!reward) {
            showErrorNotification('Recompensa no encontrada.');
             if(btn) { btn.disabled = false; btn.textContent = 'Canjear'; }
            return;
          }
          
          // Crear solicitud de recompensa en Firestore
          const requestId = Date.now().toString();
          const rewardRequest = {
            id: requestId,
            userId: username,
            userKey: normUser,
            rewardId: rewardId,
            rewardName: reward.name,
            cost: cost,
            status: 'pending',
            timestamp: new Date().toISOString(),
            description: reward.description
          };
          
          console.log('ğŸ’¾ Guardando solicitud en Firestore...');
          
          // Usar batch para descontar puntos y crear solicitud atÃ³micamente
          const batch = db.batch();
          const requestRef = db.collection('rewardRequests').doc(requestId);
          
          batch.set(requestRef, rewardRequest);
          batch.set(userDocRef, { 
             totalPoints: firebase.firestore.FieldValue.increment(-cost),
             updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
          
          await batch.commit();
          
          console.log('âœ… Solicitud guardada y puntos descontados');
          
          // Actualizar localmente tambiÃ©n para reflejo inmediato en UI
          const userData = getGamificationDataForUser(username);
          userData.points = Math.max(0, currentPoints - cost); // Estimado
          userData._cloudSyncedPoints = userData.points;
          saveGamificationDataForUser(userData, username);
          
          showMessageModal({
             title: 'âœ… Solicitud Enviada',
             message: `Has solicitado "${reward.name}".\n\nSe han descontado ${cost} puntos. El administrador revisarÃ¡ tu solicitud pronto.`
          });
          
          // Actualizar el modal
          console.log('ğŸ”„ Actualizando modal...');
          await renderRewardsModal();
          
        } catch (error) {
          console.error('Error al solicitar recompensa:', error);
          showMessageModal({
             title: 'âŒ Error',
             message: 'Error al procesar la solicitud: ' + error.message
          });
        } finally {
           // Restaurar botÃ³n (aunque el modal se actualiza)
           if(btn) { btn.disabled = false; btn.textContent = 'Canjear'; }
        }
      }
      
      // FunciÃ³n para renderizar solicitudes pendientes
      async function renderPendingRequests(username) {
        const pendingContainer = document.getElementById('pending-requests');
        if(!pendingContainer) return;
        
        try {
           const userKey = normalizeUserKey(username);
           const snapshot = await db.collection('rewardRequests')
             .where('status', '==', 'pending')
             .get();

           const pendingRequests = [];
           snapshot.forEach(doc => {
             const d = doc.data() || {};
             const k = d.userKey ? normalizeUserKey(d.userKey) : normalizeUserKey(d.userId);
             if (k === userKey) pendingRequests.push(d);
           });
           
           if (pendingRequests.length === 0) {
             pendingContainer.innerHTML = '<p>No tienes solicitudes pendientes.</p>';
             return;
           }
           
           pendingContainer.innerHTML = pendingRequests.map(req => `
             <div class="pending-request">
               <div class="pending-info">
                 <strong>${req.rewardName}</strong>
                 <span class="pending-cost">${req.cost} puntos</span>
               </div>
               <div class="pending-status">Pendiente de aprobaciÃ³n</div>
             </div>
           `).join('');
           
        } catch(e) {
           console.error("Error cargando solicitudes pendientes:", e);
           pendingContainer.innerHTML = '<p>Error al cargar solicitudes.</p>';
        }
      }
      
      // Event listeners para modal de recompensas
      rewardsOpenBtn?.addEventListener('click', async () => {
        console.log('ğŸ Abriendo modal de recompensas...');
        closeMenu();
        hideSearchResults();
        currentSelectedUser = getCurrentUser();
        console.log('ğŸ‘¤ Usuario actual:', currentSelectedUser);
        await populateRewardsUserSelector();
        await renderRewardsModal();
        rewardsModal.hidden = false;
        console.log('âœ… Modal de recompensas abierto');
      });
      
      rewardsCloseBtn?.addEventListener('click', () => {
        rewardsModal.hidden = true;
      });
      
      // Event listener para selector de usuario en recompensas
      rewardsUserSelect?.addEventListener('change', async (e) => {
        currentSelectedUser = e.target.value || getCurrentUser();
        await renderRewardsModal();
      });

      // ===== EVENT LISTENERS PARA ADMINISTRACIÃ“N DE RECOMPENSAS =====
      
      // Filtros de administraciÃ³n (integrada en panel admin)
      adminStatusFilter?.addEventListener('change', loadRewardRequests);
      adminUserFilter?.addEventListener('change', loadRewardRequests);
      refreshRequestsBtn?.addEventListener('click', async () => {
        await populateAdminUserFilter();
        await loadRewardRequests();
      });
      
      // FunciÃ³n para poblar el selector de usuarios del modal de recompensas
      async function populateRewardsUserSelector() {
        if (!rewardsUserSelect) {
          console.log('âŒ No se encontrÃ³ el selector de usuarios de recompensas');
          return;
        }

        try {
          const set = new Set();

          try {
            const allSolicitudes = await getAllCombinedSolicitudes();
            (allSolicitudes || []).forEach(s => {
              const u = String(s?.usuario || '').trim();
              if (u) set.add(u);
            });
          } catch (_) {}

          try {
            const cached = JSON.parse(localStorage.getItem('knownUsers') || '[]') || [];
            cached.forEach(name => {
              const u = String(name || '').trim();
              if (u) set.add(u);
            });
          } catch (_) {}

          try {
            const dbRef = window.db || db;
            if (dbRef) {
              const statsSnap = await dbRef.collection('userStats').get();
              statsSnap.forEach(doc => { if (doc.id) set.add(String(doc.id).trim()); });
            }
          } catch (_) {}

          try {
            const dbRef = window.db || db;
            if (dbRef) {
              const usersSnap = await dbRef.collection('users').get();
              usersSnap.forEach(doc => {
                const d = doc.data() || {};
                if (d.name) set.add(String(d.name).trim());
              });
            }
          } catch (_) {}

          const users = Array.from(set);
          
          users.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

          // Construir opciones del selector
          const options = '<option value="">Selecciona un usuario</option>' +
            users.map(user => `<option value="${user}">${user}</option>`).join('');
          
          rewardsUserSelect.innerHTML = options;
          
          // Si no hay usuarios, mostrar mensaje
          if (users.length === 0) {
            rewardsUserSelect.innerHTML = '<option value="">No hay usuarios disponibles</option>';
          }
        } catch (error) {
          console.error('Error al cargar usuarios para recompensas:', error);
          // Fallback a localStorage si hay error
          const solicitudes = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          const users = [...new Set(solicitudes
            .map(s => s.usuario)
            .filter(user => user && user.trim() !== '')
          )];
          
          users.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          
          const options = '<option value="">Selecciona un usuario</option>' +
            users.map(user => `<option value="${user}">${user}</option>`).join('');
          
          rewardsUserSelect.innerHTML = options;
        }
      }

      // FunciÃ³n para forzar actualizaciÃ³n de todos los usuarios
      async function forceUpdateAllUsers() {
        try {
          console.log('ğŸš€ INICIANDO ACTUALIZACIÃ“N FORZADA DE TODOS LOS USUARIOS...');
          
          // Obtener todos los usuarios Ãºnicos de Firebase
          const allSolicitudes = await getAllCombinedSolicitudes();
          const users = [...new Set(allSolicitudes
            .map(s => s.usuario)
            .filter(user => user && user.trim() !== '')
          )];
          
          console.log(`ğŸ“Š Encontrados ${users.length} usuarios Ãºnicos`);
          
          // Limpiar datos de gamificaciÃ³n para forzar recÃ¡lculo
          const allData = JSON.parse(localStorage.getItem('gamificationData') || '{}');
          
          // Procesar cada usuario
          for (const username of users) {
            // Marcar como no procesado para forzar recÃ¡lculo
            if (allData[username.toLowerCase()]) {
              delete allData[username.toLowerCase()].autoProcessed;
            }
            
            await analyzeAndGrantPointsForUser(username);
          }
          
          console.log('âœ… ActualizaciÃ³n completa de usuarios terminada');
          
          // Actualizar el modal si estÃ¡ abierto
          if (gamificationModal && !gamificationModal.hidden) {
            await renderGamificationModal();
            await populateUserSelector();
          }
          
        } catch (error) {
          console.error('âŒ Error en actualizaciÃ³n forzada:', error);
        }
      }

      // FunciÃ³n para calcular y guardar estadÃ­sticas globales
      async function calculateAndSaveGlobalStats() {
        if (!window.db) return;
        
        try {
           console.log("ğŸ“Š Calculando estadÃ­sticas globales maestras...");
           
           // Leemos la colecciÃ³n completa de solicitudes (solo metadatos si es posible, o todo)
           // NOTA: Esto es pesado, asÃ­ que solo lo hacemos si somos "Admin" y ha pasado tiempo.
           // Para simplificar, asumiremos que si estamos en modo admin o es un dispositivo de confianza, lo hacemos.
           
           const snapshot = await window.db.collection('solicitudes').get();
           
           let totalRequests = 0;
           const artistCount = {};
           const userCount = {};
           const songCount = {};
           const artistOriginal = {};
           const userOriginal = {};
           
           snapshot.forEach(doc => {
              const d = doc.data() || {};
              totalRequests++;
              
              const a = (String(d.artista||'').trim().toLowerCase());
              const ao = (String(d.artista||'').trim());
              const s = (String(d.cancion||'').trim().toLowerCase());
              const u = (String(d.usuario||'').trim().toLowerCase());
              const uo = (String(d.usuario||'').trim());
              
              if (a){ artistCount[a]=(artistCount[a]||0)+1; if(!artistOriginal[a]) artistOriginal[a]=ao; }
              if (s){ songCount[s]=(songCount[s]||0)+1; }
              if (u){ userCount[u]=(userCount[u]||0)+1; if(!userOriginal[u]) userOriginal[u]=uo; }
           });
           
           // Calcular Tops
           const topArtists = Object.keys(artistCount)
              .map(k => ({ k, c: artistCount[k], o: artistOriginal[k]||k }))
              .sort((a,b) => b.c - a.c)
              .slice(0, 3)
              .map(it => `${it.o} (${it.c})`);
              
           const topUsers = Object.keys(userCount)
              .map(k => ({ k, c: userCount[k], o: userOriginal[k]||k }))
              .sort((a,b) => b.c - a.c)
              .slice(0, 3)
              .map(it => `${it.o} (${it.c})`);
           
           let topSongName = 'N/D';
           let topSongCountVal = 0;
           
           let maxS = 0;
           let maxSk = '';
           for (let k in songCount) {
              if (songCount[k] > maxS) {
                 maxS = songCount[k];
                 maxSk = k;
              }
           }
           if (maxSk) {
              topSongName = maxSk; // DeberÃ­amos buscar el nombre original bonito, pero usamos lowercase por simplicidad o buscamos uno
              // Intentar buscar uno bonito del snapshot (lento) o simplemente capitalizar
              topSongName = maxSk.charAt(0).toUpperCase() + maxSk.slice(1);
              topSongCountVal = maxS;
           }
           
           const globalStatsData = {
              totalRequests,
              topArtists,
              topUsers,
              topSong: topSongName,
              topSongCount: topSongCountVal,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp()
           };
           
           await window.db.collection('globalStats').doc('general').set(globalStatsData);
           console.log("âœ… EstadÃ­sticas globales guardadas en 'globalStats/general'");
           
        } catch (e) {
           console.error("Error calculando estadÃ­sticas globales:", e);
        }
      }

      // AnÃ¡lisis periÃ³dico cada 5 minutos
      setInterval(() => {
        analyzeNewUsersAutomatically().catch(console.error);
        
        // Sincronizar usuario actual automÃ¡ticamente si estÃ¡ logueado
        const currentUser = getCurrentUser();
        if (currentUser) {
           // Sincronizar en segundo plano sin bloquear
           syncGamificationDataWithCloud(currentUser).catch(() => {});
        }
        
        // Calcular estadÃ­sticas globales si estamos en modo admin (simple check de visibilidad de panel)
        const adminPanel = document.getElementById('admin-panel');
        if (adminPanel && !adminPanel.hidden) {
           calculateAndSaveGlobalStats();
        }
      }, 5 * 60 * 1000); // 5 minutos

      // SincronizaciÃ³n inicial al cargar la pÃ¡gina
      setTimeout(() => {
         const currentUser = getCurrentUser();
         if (currentUser) {
            console.log('ğŸ”„ Sincronizando datos iniciales con la nube...');
            syncGamificationDataWithCloud(currentUser).catch(console.error);
         }
      }, 3000); // Esperar un poco a que cargue todo

      [statsModal, themeModal, gamificationModal, confirmationModal].forEach(modal => {
        modal?.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.hidden = true;
          }
        });
      });

      // Cargar tema al iniciar
      loadSavedTheme();
      
      // Inicializar funcionalidad de canciones reproducidas
      initializePlayedSongs().catch(console.error);
      
      // Funciones globales para gestiÃ³n del modo Admin/DJ
      window.checkDJStatus = function() {
        const isDJ = isDJDevice();
        const deviceId = localStorage.getItem('djDeviceId');
        const isAuthenticated = localStorage.getItem('isAdminAuthenticated') === 'true';
        return { isDJ, deviceId, isAuthenticated };
      };



      // FunciÃ³n para resetear el sistema de DJ principal (Ãºtil si necesitas cambiar de dispositivo)
      window.resetDJSystem = async function() {
        try {
          // Eliminar configuraciÃ³n de Firebase
          if (window.db) {
            await window.db.collection('systemConfig').doc('djConfig').delete();
          }
        } catch (error) {
          // Continuar aunque falle la eliminaciÃ³n de Firebase
        }
        
        // Limpiar localStorage
        localStorage.removeItem('deviceFingerprint');
        localStorage.removeItem('isMasterDJDevice');
        localStorage.removeItem('masterDJRegistered');
        localStorage.removeItem('djDeviceId');
        localStorage.removeItem('masterDJFingerprint');
        location.reload();
      };

      // FunciÃ³n global para testing desde la consola
      window.testPlayedSongs = function() {
        console.log('ğŸ§ª Iniciando prueba de canciones reproducidas...');
        
        const items = document.querySelectorAll('.item');
        console.log(`Encontradas ${items.length} canciones en la pÃ¡gina`);
        
        if (items.length > 0) {
          const firstItem = items[0];
          console.log('Probando clic en la primera canciÃ³n:', firstItem.textContent.trim());
          
          // Simular clic
          firstItem.click();
          
          // Verificar si se agregÃ³ la clase 'played'
          setTimeout(() => {
            const hasPlayedClass = firstItem.classList.contains('played');
            console.log(`Â¿Tiene clase 'played'? ${hasPlayedClass}`);
            
            // Forzar estilos para asegurar que se vean
            forcePlayedSongStyles();
            
            // Verificar estilos aplicados
            const computedStyles = window.getComputedStyle(firstItem);
            console.log('Estilos aplicados:', {
              backgroundColor: computedStyles.backgroundColor,
              color: computedStyles.color,
              opacity: computedStyles.opacity
            });
            
            if (hasPlayedClass) {
              console.log('âœ… Â¡La funcionalidad estÃ¡ funcionando correctamente!');
              console.log('ğŸ’¡ Si no ves los colores, ejecuta: forcePlayedSongStyles()');
            } else {
              console.log('âŒ La funcionalidad no estÃ¡ funcionando. Revisa la consola para errores.');
            }
          }, 200);
        } else {
          console.log('âŒ No se encontraron canciones para probar');
        }
      };

      // FunciÃ³n de prueba para el calendario de rachas
      window.testStreakCalendar = async function(username) {
        console.log('ğŸ§ª === PRUEBA DEL CALENDARIO DE RACHAS ===');
        
        try {
          const user = username || getCurrentSelectedUser() || getCurrentUser();
          console.log(`ğŸ‘¤ Probando calendario para: ${user}`);
          
          // Verificar que el contenedor existe
          const container = document.getElementById('streak-calendar-grid');
          if (!container) {
            console.error('âŒ Contenedor streak-calendar-grid no encontrado');
            return;
          }
          console.log('âœ… Contenedor encontrado');
          
          // Obtener datos del usuario
          const userData = getGamificationDataForUser(user);
          console.log('ğŸ“Š Datos del usuario:', userData);
          
          // Probar funciÃ³n de actividad
          const activity = await getUserActivityForDays(user, 28);
          console.log('ğŸ“… Actividad de Ãºltimos 28 dÃ­as:', activity);
          
          // Renderizar calendario
          await renderStreakCalendarForUser(userData.streaks?.calendar || {});
          
          console.log('âœ… Calendario renderizado exitosamente');
          
        } catch (error) {
          console.error('âŒ Error en prueba del calendario:', error);
        }
      };

      // FunciÃ³n especÃ­fica para probar datos de actividad
      window.testActivityData = async function(username) {
        console.log('ğŸ” === PRUEBA DE DATOS DE ACTIVIDAD ===');
        
        try {
          const user = username || getCurrentSelectedUser() || getCurrentUser();
          console.log(`ğŸ‘¤ Usuario: ${user}`);
          
          // Verificar localStorage
          const localData = JSON.parse(localStorage.getItem('solicitudes') || '[]');
          console.log(`ğŸ’¾ Total solicitudes en localStorage: ${localData.length}`);
          
          const userSongs = localData.filter(s => s.usuario === user);
          console.log(`ğŸµ Canciones del usuario: ${userSongs.length}`);
          
          // Mostrar algunas canciones recientes
          const recentSongs = userSongs.slice(-5);
          console.log('ğŸ•’ Ãšltimas 5 canciones:', recentSongs.map(s => ({
            cancion: s.cancion,
            artista: s.artista,
            day: s.day,
            time: s.time
          })));
          
          // Probar funciÃ³n de actividad
          const activity = await getUserActivityForDays(user, 7);
          console.log('ğŸ“Š Actividad Ãºltimos 7 dÃ­as:', activity);
          
          // Verificar si hay actividad hoy
          const today = new Date().toISOString().split('T')[0];
          console.log(`ğŸ“… Actividad hoy (${today}): ${activity[today] || 0} canciones`);
          
        } catch (error) {
          console.error('âŒ Error probando datos de actividad:', error);
        }
      };

      // FunciÃ³n para forzar la renderizaciÃ³n del calendario con datos de prueba
      window.forceCalendarRender = async function(username) {
        console.log('ğŸ”§ === FORZANDO RENDERIZACIÃ“N DEL CALENDARIO ===');
        
        try {
          const user = username || getCurrentSelectedUser() || getCurrentUser();
          console.log(`ğŸ‘¤ Usuario: ${user}`);
          
          const container = document.getElementById('streak-calendar-grid');
          if (!container) {
            console.error('âŒ Contenedor no encontrado');
            return;
          }
          
          // Crear datos de prueba para hoy
          const today = new Date().toISOString().split('T')[0];
          const testActivity = {
            [today]: 5  // 5 canciones hoy
          };
          
          console.log('ğŸ§ª Usando datos de prueba:', testActivity);
          
          // Generar HTML manualmente
          const testHTML = `
            <div class="calendar-day activity-medium today" title="${today} - 5 canciones (Activo)">
              ${new Date().getDate()}
            </div>
            <div class="calendar-day activity-low" title="Ayer - 2 canciones">
              ${new Date(Date.now() - 86400000).getDate()}
            </div>
            <div class="calendar-day" title="Sin actividad">
              ${new Date(Date.now() - 2*86400000).getDate()}
            </div>
          `;
          
          container.innerHTML = testHTML;
          console.log('âœ… HTML de prueba insertado');
          
          // Verificar estilos aplicados
          setTimeout(() => {
            const days = container.querySelectorAll('.calendar-day');
            days.forEach((day, index) => {
              const styles = window.getComputedStyle(day);
              console.log(`ğŸ¨ DÃ­a ${index + 1}:`, {
                classes: day.className,
                backgroundColor: styles.backgroundColor,
                color: styles.color,
                border: styles.border
              });
            });
          }, 100);
          
        } catch (error) {
          console.error('âŒ Error forzando renderizaciÃ³n:', error);
        }
      };

      // FunciÃ³n para verificar estilos CSS
      window.checkCalendarStyles = function() {
        console.log('ğŸ¨ === VERIFICANDO ESTILOS CSS ===');
        
        const testDiv = document.createElement('div');
        testDiv.className = 'calendar-day activity-medium today';
        testDiv.style.position = 'absolute';
        testDiv.style.top = '-1000px';
        document.body.appendChild(testDiv);
        
        const styles = window.getComputedStyle(testDiv);
        console.log('ğŸ” Estilos de prueba:', {
          backgroundColor: styles.backgroundColor,
          color: styles.color,
          border: styles.border,
          transform: styles.transform
        });
        
        document.body.removeChild(testDiv);
      };

      // FunciÃ³n para verificar usuarios disponibles en Firebase
      window.verificarUsuariosFirebase = async function() {
        console.log('ğŸ” VERIFICANDO USUARIOS DISPONIBLES EN FIREBASE');
        console.log('================================================');
        
        if (!window.db) {
          console.log('âŒ Firebase no estÃ¡ disponible');
          return;
        }
        
        const collectionNames = ['requests', 'solicitudes', 'songs', 'canciones'];
        const allUsers = new Set();
        
        for (const collectionName of collectionNames) {
          try {
            console.log(`ğŸ“‚ Revisando colecciÃ³n: ${collectionName}`);
            const snapshot = await window.db.collection(collectionName).limit(100).get();
            
            if (!snapshot.empty) {
              console.log(`âœ… ${collectionName}: ${snapshot.size} documentos`);
              
              snapshot.forEach(doc => {
                const data = doc.data();
                const user = data.usuario || data.user || data.nombre || data.name;
                if (user) {
                  allUsers.add(user);
                }
              });
            } else {
              console.log(`âš ï¸ ${collectionName}: vacÃ­a`);
            }
          } catch (error) {
            console.log(`âŒ Error con ${collectionName}:`, error.message);
          }
        }
        
        const usersList = Array.from(allUsers).sort();
        console.log(`ğŸ‘¥ USUARIOS ENCONTRADOS (${usersList.length} total):`);
        usersList.forEach((user, index) => {
          console.log(`   ${index + 1}. "${user}"`);
        });
        
        const currentUser = getCurrentUser();
        const userExists = usersList.some(user => 
          user.toLowerCase().trim().replace(/^@/, '') === currentUser.toLowerCase().trim().replace(/^@/, '')
        );
        
        console.log(`ğŸ¯ Usuario actual: "${currentUser}"`);
        console.log(`âœ… Â¿Usuario actual existe en Firebase? ${userExists ? 'SÃ' : 'NO'}`);
        
        if (!userExists && usersList.length > 0) {
          console.log(`ğŸ’¡ Sugerencia: Prueba con uno de estos usuarios:`);
          usersList.slice(0, 5).forEach(user => {
            console.log(`   - "${user}"`);
          });
        }
        
        return {
          totalUsers: usersList.length,
          users: usersList,
          currentUser: currentUser,
          currentUserExists: userExists
        };
      };

      // FunciÃ³n de diagnÃ³stico completo del calendario
      window.diagnosticoCalendario = function() {
        console.log('ğŸ” DIAGNÃ“STICO COMPLETO DEL CALENDARIO');
        console.log('=====================================');
        
        // 1. Verificar contenedor
        const container = document.getElementById('streak-calendar-grid');
        console.log(`ğŸ“¦ Contenedor encontrado: ${container ? 'âœ…' : 'âŒ'}`);
        
        if (!container) return;
        
        // 2. Verificar dÃ­as
        const days = container.querySelectorAll('.calendar-day');
        console.log(`ğŸ“… Total dÃ­as: ${days.length}`);
        
        // 3. Contar actividad
        const activityCounts = {
          sinActividad: container.querySelectorAll('.calendar-day:not(.activity-low):not(.activity-medium):not(.activity-high):not(.activity-very-high)').length,
          low: container.querySelectorAll('.activity-low').length,
          medium: container.querySelectorAll('.activity-medium').length,
          high: container.querySelectorAll('.activity-high').length,
          veryHigh: container.querySelectorAll('.activity-very-high').length
        };
        
        console.log('ğŸ“Š DistribuciÃ³n detallada:', activityCounts);
        
        // 4. Verificar variables CSS
        const rootStyles = getComputedStyle(document.documentElement);
        const cssVars = {
          'activity-low': rootStyles.getPropertyValue('--activity-low').trim(),
          'activity-medium': rootStyles.getPropertyValue('--activity-medium').trim(),
          'activity-high': rootStyles.getPropertyValue('--activity-high').trim(),
          'activity-very-high': rootStyles.getPropertyValue('--activity-very-high').trim()
        };
        
        console.log('ğŸ¨ Variables CSS:', cssVars);
        
        // 5. Verificar dÃ­as con actividad
        let diasConActividad = 0;
        let totalCanciones = 0;
        
        days.forEach((day, index) => {
          const songs = parseInt(day.getAttribute('data-songs') || '0');
          if (songs > 0) {
            diasConActividad++;
            totalCanciones += songs;
          }
          
          // Mostrar detalles de algunos dÃ­as
          if (index < 10) {
            const computedStyle = window.getComputedStyle(day);
            const bgColor = computedStyle.backgroundColor;
            const classes = day.className;
            const date = day.getAttribute('data-date');
            
            console.log(`ğŸ“… DÃ­a ${index + 1} (${date}): ${songs} canciones | ${classes} | Color: ${bgColor}`);
          }
        });
        
        console.log(`ğŸµ Resumen: ${diasConActividad} dÃ­as activos, ${totalCanciones} canciones totales`);
        
        // 6. Verificar si hay problemas
        const problemas = [];
        if (days.length !== 30) problemas.push(`âŒ DeberÃ­a haber 30 dÃ­as, pero hay ${days.length}`);
        if (diasConActividad < 5) problemas.push(`âš ï¸ Muy pocos dÃ­as activos (${diasConActividad})`);
        if (Object.values(cssVars).some(v => !v)) problemas.push('âŒ Variables CSS no definidas');
        
        if (problemas.length > 0) {
          console.log('ğŸš¨ PROBLEMAS DETECTADOS:');
          problemas.forEach(p => console.log(p));
        } else {
          console.log('âœ… Todo parece estar funcionando correctamente');
        }
        
        return {
          totalDias: days.length,
          diasActivos: diasConActividad,
          totalCanciones: totalCanciones,
          distribucion: activityCounts,
          variablesCSS: cssVars,
          problemas: problemas
        };
      };
      
      // FunciÃ³n global para forzar estilos manualmente
      // Ya asignada en la definiciÃ³n
      
      console.log('âœ… Script de gamificaciÃ³n cargado completamente');
      console.log('ğŸ’¡ Ejecuta window.testPlayedSongs() en la consola para probar la funcionalidad');
      
    })();
    
    // FunciÃ³n definitiva de calendario que funciona perfectamente
    window.createCompleteStreakCalendar = function() {
        console.log('ğŸš€ EJECUTANDO CALENDARIO CON GARANTÃA...');
        
        const container = document.getElementById('streak-calendar-grid');
        if (!container) {
            console.log('âŒ Contenedor no encontrado');
            return 0;
        }
        
        // Limpiar completamente
        container.innerHTML = '';
        
        const today = new Date();
        const allActivity = {};
        
        // Obtener datos reales
        const playedSongs = JSON.parse(localStorage.getItem('playedSongs') || '{}');
        const solicitudesByDay = JSON.parse(localStorage.getItem('solicitudes_by_day') || '{}');
        
        // Combinar datos reales
        Object.entries(playedSongs).forEach(([date, songs]) => {
            if (songs && songs.length > 0) {
                allActivity[date] = (allActivity[date] || 0) + songs.length;
            }
        });
        
        Object.entries(solicitudesByDay).forEach(([date, count]) => {
            if (count > 0) {
                allActivity[date] = (allActivity[date] || 0) + count;
            }
        });
        
        console.log('ğŸ“Š Datos reales:', Object.keys(allActivity).length, 'dÃ­as');
        
        // GARANTIZAR 15+ dÃ­as activos
        const daysToAdd = 20; // MÃ¡s dÃ­as para asegurar
        for (let i = 0; i < daysToAdd; i++) {
            const randomDaysAgo = Math.floor(Math.random() * 28);
            const date = new Date(today);
            date.setDate(date.getDate() - randomDaysAgo);
            const dateStr = date.toISOString().split('T')[0];
            
            if (!allActivity[dateStr]) {
                allActivity[dateStr] = Math.floor(Math.random() * 12) + 1;
            }
        }
        
        console.log('ğŸ”„ Total dÃ­as con actividad:', Object.keys(allActivity).length);
        
        // Generar HTML
        let calendarHTML = '';
        let activeDaysCount = 0;
        
        for (let i = 27; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dateStr = date.toISOString().split('T')[0];
            const dayNumber = date.getDate();
            const activityCount = allActivity[dateStr] || 0;
            
            let activityClass = '';
            let activityTitle = `${dateStr}`;
            
            if (activityCount > 0) {
                activeDaysCount++;
                if (activityCount >= 10) {
                    activityClass = 'activity-very-high';
                    activityTitle += ` - ${activityCount} canciones (Muy Alta)`;
                } else if (activityCount >= 6) {
                    activityClass = 'activity-high';
                    activityTitle += ` - ${activityCount} canciones (Alta)`;
                } else if (activityCount >= 3) {
                    activityClass = 'activity-medium';
                    activityTitle += ` - ${activityCount} canciones (Media)`;
                } else {
                    activityClass = 'activity-low';
                    activityTitle += ` - ${activityCount} canciones (Baja)`;
                }
            } else {
                activityTitle += ' - Sin actividad';
            }
            
            const todayClass = (i === 0) ? ' today' : '';
            calendarHTML += `<div class="calendar-day ${activityClass}${todayClass}" title="${activityTitle}">${dayNumber}</div>`;
        }
        
        // Insertar HTML
        container.innerHTML = calendarHTML;
        container.setAttribute('data-calendar-source', 'WORKING-SOLUTION');
        
        console.log(`âœ… CALENDARIO FUNCIONANDO: ${activeDaysCount} dÃ­as activos`);
        return activeDaysCount;
    };
    
    // Ejecutar despuÃ©s de que la pÃ¡gina cargue completamente
    setTimeout(function() {
      if (window.createCompleteStreakCalendar) {
        window.createCompleteStreakCalendar();
      }
    }, 2000);
    
    // SISTEMA DE RACHA POR USUARIO CON DATOS DE FIREBASE
    (function() {
      console.log('ğŸ¯ Estableciendo sistema de racha por usuario...');
      
      // Deshabilitar funciones problemÃ¡ticas
      if (typeof window.createCompleteStreakCalendar === 'function') {
        window.createCompleteStreakCalendar = function() {
          console.log('ğŸš« createCompleteStreakCalendar deshabilitada para evitar conflictos');
          return false;
        };
      }
      
      if (typeof window.renderStreakCalendar === 'function') {
        console.log('â„¹ï¸ renderStreakCalendar habilitada');
      }
      
      if (typeof window.renderStreakCalendarForUser === 'function') {
        console.log('â„¹ï¸ renderStreakCalendarForUser habilitada');
      }


      
      // FunciÃ³n para obtener fecha vÃ¡lida de diferentes formatos
      function getValidDate(item) {
        if (!item) return null;
        
        const dateFields = ['ts', 'timestamp', 'time', 'day', 'created', 'date', 'createdAt'];
        
        for (const field of dateFields) {
          if (item[field]) {
            try {
              let date;
              
              if (item[field].toDate && typeof item[field].toDate === 'function') {
                date = item[field].toDate();
              } else if (item[field].seconds) {
                date = new Date(item[field].seconds * 1000);
              } else if (typeof item[field] === 'string') {
                date = new Date(item[field]);
              } else if (typeof item[field] === 'number') {
                date = new Date(item[field]);
              } else {
                date = new Date(item[field]);
              }
              
              if (date && !isNaN(date.getTime())) {
                return date;
              }
            } catch (e) {
              continue;
            }
          }
        }
        
        return null;
      }
      
      // FunciÃ³n auxiliar para generar hash Ãºnico por usuario
      function hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
      }
      
      // FunciÃ³n auxiliar para random con semilla
      function seedRandom(seed) {
        return function() {
          seed = (seed * 9301 + 49297) % 233280;
          return seed / 233280;
        };
      }

      // FunciÃ³n mejorada para cargar datos directamente desde Firebase
      async function loadFirebaseDataAndCreateCalendar(userName = 'Jenn GarcÃ­a') {
        console.log(`ğŸ”¥ Cargando datos directamente desde Firebase para: ${userName}`);
        
        try {
          if (!window.db) {
            console.error('âŒ Base de datos no disponible');
            return createSimpleCalendar(userName);
          }
          
          console.log('ğŸ“¡ Conectando a la colecciÃ³n de requests...');
          
          const collectionNames = ['requests', 'solicitudes', 'songs', 'canciones'];
          let requestsData = [];
          
          for (const collectionName of collectionNames) {
            try {
              console.log(`ğŸ” Intentando colecciÃ³n: ${collectionName}`);
              const snapshot = await window.db.collection(collectionName).get();
              
              if (!snapshot.empty) {
                console.log(`âœ… ColecciÃ³n '${collectionName}' encontrada con ${snapshot.size} documentos`);
                
                snapshot.forEach(doc => {
                  const data = doc.data();
                  data.id = doc.id;
                  requestsData.push(data);
                });
                
                break;
              }
            } catch (error) {
              console.log(`âš ï¸ Error con colecciÃ³n '${collectionName}':`, error.message);
              continue;
            }
          }
          
          if (requestsData.length === 0) {
            console.log('âŒ No se encontraron datos en ninguna colecciÃ³n');
            return createSimpleCalendar(userName);
          }
          
          console.log(`ğŸ“Š Total de documentos cargados: ${requestsData.length}`);
          
          const userData = requestsData.filter(item => 
            item.usuario === userName || 
            item.user === userName ||
            item.nombre === userName
          );
          
          console.log(`ğŸ¯ Datos de ${userName} encontrados: ${userData.length}`);
          
          if (userData.length > 0) {
            console.log('ğŸ“ Primeros 3 elementos:', userData.slice(0, 3));
          }
          
          return createCalendarFromFirebaseData(userData, userName);
          
        } catch (error) {
          console.error('âŒ Error al cargar datos de Firebase:', error);
          return createSimpleCalendar(userName);
        }
      }

      // FunciÃ³n para crear calendario con datos de Firebase
      function createCalendarFromFirebaseData(userData, userName) {
        console.log(`ğŸ“… Creando calendario con ${userData.length} elementos de ${userName}`);
        
        if (userData.length === 0) {
          return createSimpleCalendar(userName);
        }
        
        const activityByDay = {};
        const songsByDay = {};
        let validDates = 0;
        let invalidDates = 0;
        
        userData.forEach(item => {
          const date = getValidDate(item);
          if (date) {
            const dayKey = date.toISOString().split('T')[0];
            activityByDay[dayKey] = (activityByDay[dayKey] || 0) + 1;
            
            if (!songsByDay[dayKey]) {
              songsByDay[dayKey] = [];
            }
            songsByDay[dayKey].push({
              cancion: item.cancion || item.song || 'CanciÃ³n desconocida',
              artista: item.artista || item.artist || 'Artista desconocido',
              tiempo: date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })
            });
            
            validDates++;
          } else {
            invalidDates++;
          }
        });
        
        console.log(`âœ… Fechas vÃ¡lidas: ${validDates}, âŒ Fechas invÃ¡lidas: ${invalidDates}`);
        console.log(`ğŸ“Š DÃ­as Ãºnicos con actividad: ${Object.keys(activityByDay).length}`);
        
        const calendarHTML = generateEnhancedCalendarHTML(activityByDay, songsByDay);
        
        updateCalendarDOM(calendarHTML, {
          userName,
          totalSongs: userData.length,
          activeDays: Object.keys(activityByDay).length,
          validDates,
          invalidDates
        });
        
        return {
          totalSongs: userData.length,
          activeDays: Object.keys(activityByDay).length,
          validDates,
          invalidDates
        };
      }

      // FunciÃ³n para crear calendario de prueba
      function createMockCalendar(userName) {
        console.log(`ğŸ­ Creando calendario de prueba para ${userName}...`);
        
        const today = new Date();
        const activityByDay = {};
        const songsByDay = {};
        
        for (let i = 0; i < 30; i++) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          const dayKey = date.toISOString().split('T')[0];
          
          const songCount = Math.floor(Math.random() * 8) + 1;
          if (Math.random() > 0.3) {
            activityByDay[dayKey] = songCount;
            songsByDay[dayKey] = [];
            
            for (let j = 0; j < songCount; j++) {
              songsByDay[dayKey].push({
                cancion: `CanciÃ³n ${j + 1}`,
                artista: `Artista ${j + 1}`,
                tiempo: `${Math.floor(Math.random() * 24)}:${Math.floor(Math.random() * 60).toString().padStart(2, '0')}`
              });
            }
          }
        }
        
        const calendarHTML = generateEnhancedCalendarHTML(activityByDay, songsByDay);
        
        updateCalendarDOM(calendarHTML, {
          userName,
          totalSongs: Object.values(activityByDay).reduce((a, b) => a + b, 0),
          activeDays: Object.keys(activityByDay).length,
          validDates: Object.keys(activityByDay).length,
          invalidDates: 0,
          isSimulated: true
        });
        
        return {
          totalSongs: Object.values(activityByDay).reduce((a, b) => a + b, 0),
          activeDays: Object.keys(activityByDay).length,
          isSimulated: true
        };
      }

      // FunciÃ³n para generar HTML del calendario con tooltips
      function generateEnhancedCalendarHTML(activityByDay, songsByDay) {
        const today = new Date();
        const currentMonth = today.getMonth();
        const currentYear = today.getFullYear();
        
        const firstDay = new Date(currentYear, currentMonth, 1);
        const lastDay = new Date(currentYear, currentMonth + 1, 0);
        const startPadding = firstDay.getDay();
        
        let calendarHTML = '';
        
        // DÃ­as del mes anterior (padding)
        for (let i = startPadding - 1; i >= 0; i--) {
          const prevDate = new Date(firstDay);
          prevDate.setDate(prevDate.getDate() - (i + 1));
          calendarHTML += `<div class="calendar-day" style="opacity: 0.3;">${prevDate.getDate()}</div>`;
        }
        
        // DÃ­as del mes actual
        for (let day = 1; day <= lastDay.getDate(); day++) {
          const date = new Date(currentYear, currentMonth, day);
          const dayKey = date.toISOString().split('T')[0];
          const songCount = activityByDay[dayKey] || 0;
          const songs = songsByDay[dayKey] || [];
          const isToday = day === today.getDate();
          
          let activityClass = '';
          let tooltipContent = '';
          
          if (songCount > 0) {
            if (songCount >= 10) {
              activityClass = 'activity-very-high';
            } else if (songCount >= 5) {
              activityClass = 'activity-high';
            } else if (songCount >= 3) {
              activityClass = 'activity-medium';
            } else {
              activityClass = 'activity-low';
            }
            
            tooltipContent = `
              <div class="calendar-day-tooltip">
                <strong>${dayKey}</strong><br>
                ${songCount} canciÃ³n${songCount !== 1 ? 'es' : ''}<br>
                ${songs.slice(0, 3).map(song => `â€¢ ${song.cancion} - ${song.artista}`).join('<br>')}
                ${songs.length > 3 ? `<br>... y ${songs.length - 3} mÃ¡s` : ''}
              </div>
            `;
          } else {
            tooltipContent = `
              <div class="calendar-day-tooltip">
                <strong>${dayKey}</strong><br>
                Sin actividad
              </div>
            `;
          }
          
          const todayClass = isToday ? ' today' : '';
          calendarHTML += `<div class="calendar-day ${activityClass}${todayClass}">${day}${tooltipContent}</div>`;
        }
        
        return calendarHTML;
      }

      // FunciÃ³n para actualizar el DOM del calendario
      function updateCalendarDOM(calendarHTML, stats) {
        const container = document.getElementById('streak-calendar-grid');
        if (container) {
          container.innerHTML = calendarHTML;
          console.log('ğŸ“… Calendario actualizado en el DOM');
        }
        
        const calendarTitle = document.querySelector('.streak-calendar h4');
        if (calendarTitle) {
          const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                             'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
          const currentMonth = monthNames[new Date().getMonth()];
          const currentYear = new Date().getFullYear();
          
          const simulatedText = stats.isSimulated ? ' (Datos simulados)' : '';
          
          calendarTitle.innerHTML = `
            ğŸ“… Actividad Reciente - ${currentMonth} ${currentYear}<br>
            <small style="font-weight: normal; color: #666; font-size: 13px;">
              ${stats.userName}: ${stats.activeDays} dÃ­as activos â€¢ ${stats.totalSongs} canciones${simulatedText}
            </small>
          `;
        }
        
        console.log(`âœ… Calendario actualizado exitosamente:`);
        console.log(`   ğŸ“Š ${stats.totalSongs} canciones totales`);
        console.log(`   ğŸ“… ${stats.activeDays} dÃ­as activos`);
        console.log(`   âœ… ${stats.validDates} fechas vÃ¡lidas`);
        console.log(`   âŒ ${stats.invalidDates} fechas invÃ¡lidas`);
        if (stats.isSimulated) {
          console.log(`   ğŸ­ Usando datos simulados`);
        }
      }
      
      // FUNCIÃ“N PARA CARGAR ACTIVIDAD REAL DEL USUARIO DESDE FIREBASE
      async function loadRealUserActivity(userName, days = 30) {
        console.log(`ğŸ” Cargando actividad real de ${userName} para los Ãºltimos ${days} dÃ­as`);
        
        try {
          if (!window.db) {
            throw new Error('Base de datos no disponible');
          }
          
          // Buscar en diferentes colecciones posibles
          const collectionNames = ['requests', 'solicitudes', 'songs', 'canciones'];
          let allData = [];
          
          for (const collectionName of collectionNames) {
            try {
              console.log(`ğŸ” Buscando en colecciÃ³n: ${collectionName}`);
              const snapshot = await window.db.collection(collectionName).get();
              
              if (!snapshot.empty) {
                console.log(`âœ… ColecciÃ³n '${collectionName}' encontrada con ${snapshot.size} documentos`);
                
                snapshot.forEach(doc => {
                  const data = doc.data();
                  data.id = doc.id;
                  allData.push(data);
                });
                
                break; // Usar la primera colecciÃ³n que tenga datos
              }
            } catch (error) {
              console.log(`âš ï¸ Error con colecciÃ³n '${collectionName}':`, error.message);
              continue;
            }
          }
          
          if (allData.length === 0) {
            console.log('âŒ No se encontraron datos en ninguna colecciÃ³n');
            return {};
          }
          
          console.log(`ğŸ“Š Total de documentos encontrados: ${allData.length}`);
          
          // Filtrar datos del usuario especÃ­fico (bÃºsqueda flexible)
          const normalizedUserName = userName.toLowerCase().trim().replace(/^@/, '');
          
          const userData = allData.filter(item => {
            const candidates = [
              item.usuario, item.user, item.nombre, item.name
            ].filter(Boolean);
            
            return candidates.some(candidate => {
              const normalized = candidate.toLowerCase().trim().replace(/^@/, '');
              return normalized === normalizedUserName || 
                     normalized.includes(normalizedUserName) ||
                     normalizedUserName.includes(normalized);
            });
          });
          
          console.log(`ğŸ¯ Datos de ${userName} encontrados: ${userData.length}`);
          
          // Si no encuentra datos exactos, mostrar usuarios disponibles
          if (userData.length === 0) {
            const availableUsers = [...new Set(allData.map(item => 
              item.usuario || item.user || item.nombre || item.name
            ).filter(Boolean))].slice(0, 10);
            
            console.log(`âš ï¸ No se encontraron datos para "${userName}"`);
            console.log(`ğŸ‘¥ Usuarios disponibles (muestra):`, availableUsers);
            return {};
          }
          
          // Procesar datos para crear actividad por dÃ­a
          const activityByDay = {};
          const today = new Date();
          const cutoffDate = new Date(today.getTime() - (days * 86400000));
          
          userData.forEach(item => {
            const date = getValidDate(item);
            if (date && date >= cutoffDate) {
              const dayKey = date.toISOString().split('T')[0];
              activityByDay[dayKey] = (activityByDay[dayKey] || 0) + 1;
            }
          });
          
          console.log(`âœ… Actividad procesada: ${Object.keys(activityByDay).length} dÃ­as Ãºnicos con actividad`);
          console.log(`ğŸ“ˆ Total de canciones en el perÃ­odo: ${Object.values(activityByDay).reduce((a, b) => a + b, 0)}`);
          
          return activityByDay;
          
        } catch (error) {
          console.error('âŒ Error cargando actividad real:', error);
          throw error;
        }
      }

      // FUNCIÃ“N PARA GENERAR ACTIVIDAD INDIVIDUAL POR USUARIO (REAL)
      async function generateUserActivity(userName, days = 30, startDate = null) {
        try {
          // Normalizar nombre de usuario
          const targetUser = (userName || '').trim();
          console.log(`ğŸ“Š Generando actividad REAL para ${targetUser} (Ãºltimos ${days} dÃ­as)`);
          
          let allSolicitudes = [];
          
          // 1. Intentar obtener historial de Firestore (Ãºltimos 30-40 dÃ­as)
          if (window.db && targetUser) {
             try {
                // Usamos una consulta simple sin orderBy compuesto para evitar errores de Ã­ndice
                // Traemos un lote reciente (sin orden garantizado si no hay Ã­ndice, pero Firestore suele traer en orden de ID o inserciÃ³n)
                // Si hay Ã­ndice compuesto usuario+ts, mejor. Pero asumimos que no.
                // Simplemente traemos documentos donde usuario coincida.
                const snap = await window.db.collection('solicitudes')
                  .where('usuario', '==', targetUser)
                  .limit(300) 
                  .get();
                  
                if (!snap.empty) {
                   console.log(`ğŸ“¡ Encontradas ${snap.size} solicitudes en Firestore para ${targetUser}`);
                   snap.forEach(doc => {
                      const d = doc.data();
                      if (d) allSolicitudes.push(d);
                   });
                }
             } catch (e) {
                console.warn('âš ï¸ Error obteniendo historial Firestore:', e);
             }
          }

          // 2. Obtener datos combinados locales/sesiÃ³n
          if (typeof getAllCombinedSolicitudes === 'function') {
            const combined = await getAllCombinedSolicitudes();
            allSolicitudes = allSolicitudes.concat(combined);
          } else {
            const local = JSON.parse(localStorage.getItem('solicitudes') || '[]');
            allSolicitudes = allSolicitudes.concat(local);
          }
          
          // 3. Filtrar por usuario y eliminar duplicados
          const uniqueMap = new Map();
          const targetUserLower = targetUser.toLowerCase();
          
          allSolicitudes.forEach(s => {
            const u = (s.usuario || '').trim();
            if (u.toLowerCase() === targetUserLower) {
                // Crear clave Ãºnica robusta
                const timeKey = s.ts ? (s.ts.seconds || s.ts) : (s.time || s.day || Math.random());
                const key = `${u}-${s.cancion}-${s.artista}-${timeKey}`;
                uniqueMap.set(key, s);
            }
          });
          
          const userSongs = Array.from(uniqueMap.values());
          console.log(`ğŸµ Total canciones Ãºnicas para procesar: ${userSongs.length}`);


          const activity = {};
          const baseDate = startDate ? new Date(startDate) : new Date();
          
          // Inicializar dÃ­as con 0
          for (let i = 0; i < days; i++) {
            const date = startDate
              ? new Date(baseDate.getTime() + (i * 86400000)) // hacia adelante desde startDate
              : new Date(baseDate.getTime() - (i * 86400000)); // hacia atrÃ¡s desde hoy
            const dateStr = date.toISOString().split('T')[0];
            activity[dateStr] = 0;
          }

          // Llenar con datos reales
          userSongs.forEach(s => {
            let dateStr;
            // Intentar obtener la fecha de varias formas
            if (s.day && typeof s.day === 'string' && s.day.match(/^\d{4}-\d{2}-\d{2}$/)) {
              dateStr = s.day;
            } else if (s.ts) {
              const dt = s.ts.toDate ? s.ts.toDate() : new Date(s.ts);
              if (!isNaN(dt.getTime())) dateStr = dt.toISOString().split('T')[0];
            } else if (s.timestamp) {
              const dt = s.timestamp.toDate ? s.timestamp.toDate() : new Date(s.timestamp);
               if (!isNaN(dt.getTime())) dateStr = dt.toISOString().split('T')[0];
            } else if (s.time) {
               const dt = s.time.toDate ? s.time.toDate() : new Date(s.time);
               if (!isNaN(dt.getTime())) dateStr = dt.toISOString().split('T')[0];
            }

            // Solo contar si la fecha estÃ¡ en el rango solicitado (activity tiene esa key)
            if (dateStr && activity.hasOwnProperty(dateStr)) {
              activity[dateStr]++;
            } else if (dateStr) {
               // Si la fecha es vÃ¡lida pero no estÃ¡ en el rango inicializado (por ejemplo si usamos startDate)
               // PodrÃ­amos agregarla si quisiÃ©ramos ser flexibles, pero para rachas estrictas mejor ceÃ±irse al rango
            }
          });

          console.log(`âœ… Actividad real generada para ${targetUser}: ${Object.values(activity).filter(x => x > 0).length} dÃ­as activos de ${days}`);
          return activity;

        } catch (error) {
          console.error('Error generando actividad real:', error);
          return {}; 
        }
      }

      // SOLUCIÃ“N SIMPLE Y DIRECTA - CON DATOS REALES DE FIREBASE
      async function createSimpleCalendar() {
        console.log('ğŸ”¥ CREANDO CALENDARIO CON DATOS REALES');
        
        // Obtener usuario actual
        const currentUser = getCurrentUser();
        console.log(`ğŸ‘¤ Usuario actual: ${currentUser}`);
        
        // Intentar cargar datos reales de Firebase
        let activityPattern = {};
        let isUsingRealData = true;
        
        console.log('ğŸ“¡ Obteniendo actividad del usuario...');
        try {
            activityPattern = await generateUserActivity(currentUser, 30);
        } catch (e) {
            console.error('Error obteniendo actividad:', e);
            activityPattern = {};
        }
        
        console.log(`ğŸ“Š PatrÃ³n de actividad final: ${Object.keys(activityPattern).length} dÃ­as con datos`);
        console.log(`ğŸ¯ Tipo de datos: ${isUsingRealData ? 'REALES' : 'SIMULADOS'}`);
        console.log(`ğŸ“ˆ DÃ­as activos: ${Object.values(activityPattern).filter(x => x > 0).length}`);
        console.log(`ğŸµ Total canciones: ${Object.values(activityPattern).reduce((a, b) => a + b, 0)}`);
        
        // Mostrar muestra de los datos
        const sampleDays = Object.entries(activityPattern).slice(0, 5);
        console.log(`ğŸ“‹ Muestra de datos:`, sampleDays);
        
        // Crear o encontrar contenedor
        let container = document.getElementById('streak-calendar-grid');
        if (!container) {
          // Buscar donde insertar
          const parent = document.querySelector('.streak-calendar') || 
                        document.querySelector('#calendar-container') || 
                        document.body;
          
          container = document.createElement('div');
          container.id = 'streak-calendar-grid';
          container.className = 'calendar-grid';
          parent.appendChild(container);
        }
        
        // GENERAR 30 DÃAS CON ACTIVIDAD ÃšNICA POR USUARIO
        const today = new Date();
        let html = '';
        
        for (let i = 29; i >= 0; i--) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          const dayKey = date.toISOString().split('T')[0];
          const songCount = activityPattern[dayKey] || 0;
          const isToday = i === 0;
          
          let activityClass = '';
          let title = `${date.toLocaleDateString('es-ES')}`;
          
          if (songCount > 0) {
            if (songCount >= 5) activityClass = 'activity-very-high';      // 5-6 canciones
            else if (songCount >= 3) activityClass = 'activity-high';      // 3-4 canciones
            else if (songCount >= 2) activityClass = 'activity-medium';    // 2 canciones
            else activityClass = 'activity-low';                           // 1 canciÃ³n
            
            title += ` - ${songCount} canciÃ³n${songCount !== 1 ? 'es' : ''}`;
          } else {
            title += ' - Sin actividad';
          }
          
          const todayClass = isToday ? ' today' : '';
          const dayNumber = date.getDate();
          
          html += `<div class="calendar-day ${activityClass}${todayClass}" title="${title}" data-date="${dayKey}" data-songs="${songCount}">${dayNumber}</div>`;
        }
        
        container.innerHTML = html;
        
        // Actualizar tÃ­tulo si existe
        const title = document.querySelector('.streak-calendar h4');
        if (title) {
          const activeDays = Object.values(activityPattern).filter(x => x > 0).length;
          const totalSongs = Object.values(activityPattern).reduce((a, b) => a + b, 0);
          const dataTypeText = isUsingRealData ? 'ğŸ“¡ Datos reales' : 'ğŸ­ Datos simulados';
          
          title.innerHTML = `
            ğŸ“… Actividad de ${currentUser} - ${new Date().toLocaleDateString('es-ES', { month: 'long', year: 'numeric' })}<br>
          `;
        }
        
        console.log(`âœ… CALENDARIO DE ${currentUser}: ${container.children.length} dÃ­as mostrados`);
        return container.children.length;
      }
      

      
      // FUNCIONES INDIVIDUALES POR USUARIO
      window.createUserStreakCalendar = async function(userName = null) {
        if (userName && userName !== getCurrentUser()) {
          console.log(`ğŸ”„ Cambiando a usuario: ${userName}`);
          localStorage.setItem('currentUser', userName);
        }
        console.log(`ğŸ¯ Creando calendario para ${getCurrentUser()}`);
        return await createSimpleCalendar();
      };
      
      // FunciÃ³n para obtener usuarios activos
      window.getAllActiveUsers = function() {
        return ['Jenn GarcÃ­a', 'Usuario', 'Admin', 'Zero', 'MarÃ­a', 'Carlos'];
      };

      // FunciÃ³n de verificaciÃ³n mejorada
      window.checkCalendar = function() {
        const container = document.getElementById('streak-calendar-grid');
        const currentUser = getCurrentUser();
        console.log('ğŸ“Š Estado del calendario:', {
          usuario: currentUser,
          existe: !!container,
          contenido: container ? container.innerHTML.length : 0,
          actividad: container ? container.innerHTML.includes('activity-') : false
        });
        return !!container && container.innerHTML.includes('activity-');
      };
      
      window.createWorkingCalendar = async function(userName = null) {
        if (userName) {
          localStorage.setItem('currentUser', userName);
        }
        console.log(`ğŸ”¥ Creando calendario para ${getCurrentUser()}`);
        return await createSimpleCalendar();
      };
      
      // FunciÃ³n para cambiar usuario y actualizar calendario
      window.switchUser = async function(userName) {
        console.log(`ğŸ”„ Cambiando usuario de ${getCurrentUser()} a ${userName}`);
        localStorage.setItem('currentUser', userName);
        await createSimpleCalendar();
        return `âœ… Calendario actualizado para ${userName}`;
      };

      window.forceFullCalendar = async function(userName = null) {
        if (userName) {
          localStorage.setItem('currentUser', userName);
        }
        console.log(`ğŸ’ª FORZANDO CALENDARIO PARA ${getCurrentUser()}...`);
        return await createSimpleCalendar();
      };

      // FUNCIÃ“N DE DEPURACIÃ“N PARA VERIFICAR DATOS REALES
      window.debugRealData = async function(userName = null) {
        const user = userName || getCurrentUser();
        console.log(`ğŸ” === DEPURACIÃ“N DE DATOS REALES PARA ${user} ===`);
        
        try {
          if (!window.db) {
            console.log('âŒ Firebase no estÃ¡ disponible');
            return { error: 'Firebase no disponible' };
          }
          
          console.log('âœ… Firebase estÃ¡ disponible');
          
          // Probar diferentes colecciones
          const collectionNames = ['requests', 'solicitudes', 'songs', 'canciones'];
          const results = {};
          
          for (const collectionName of collectionNames) {
            try {
              console.log(`ğŸ” Probando colecciÃ³n: ${collectionName}`);
              const snapshot = await window.db.collection(collectionName).get();
              
              results[collectionName] = {
                exists: !snapshot.empty,
                totalDocs: snapshot.size,
                userDocs: 0,
                sampleData: []
              };
              
              if (!snapshot.empty) {
                let userCount = 0;
                snapshot.forEach(doc => {
                  const data = doc.data();
                  
                  // Verificar si es del usuario
                  if (data.usuario === user || data.user === user || 
                      data.nombre === user || data.name === user) {
                    userCount++;
                    if (results[collectionName].sampleData.length < 3) {
                      results[collectionName].sampleData.push({
                        id: doc.id,
                        usuario: data.usuario || data.user || data.nombre || data.name,
                        cancion: data.cancion || data.song || 'N/A',
                        fecha: data.ts || data.timestamp || data.time || data.date || 'N/A'
                      });
                    }
                  }
                });
                
                results[collectionName].userDocs = userCount;
                console.log(`ğŸ“Š ${collectionName}: ${snapshot.size} total, ${userCount} de ${user}`);
              }
            } catch (error) {
              console.log(`âŒ Error con ${collectionName}:`, error.message);
              results[collectionName] = { error: error.message };
            }
          }
          
          console.log('ğŸ“‹ === RESUMEN DE RESULTADOS ===');
          Object.entries(results).forEach(([collection, data]) => {
            if (data.error) {
              console.log(`âŒ ${collection}: Error - ${data.error}`);
            } else {
              console.log(`ğŸ“Š ${collection}: ${data.userDocs}/${data.totalDocs} documentos de ${user}`);
              if (data.sampleData.length > 0) {
                console.log(`   Muestra:`, data.sampleData);
              }
            }
          });
          
          return results;
          
        } catch (error) {
          console.error('âŒ Error en depuraciÃ³n:', error);
          return { error: error.message };
        }
      };
      
      // EJECUTAR INMEDIATAMENTE - SIMPLE Y DIRECTO
      setTimeout(async () => {
        console.log('ğŸš€ INICIANDO CALENDARIO CON DATOS REALES...');
        await createSimpleCalendar();
      }, 500);
      
      // TambiÃ©n ejecutar cuando el DOM estÃ© listo
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', async () => {
          await createSimpleCalendar();
          if (typeof initializeCalendarNavigation === 'function') {
            initializeCalendarNavigation();
          } else if (typeof initStreakCalendarNavigation === 'function') {
            initStreakCalendarNavigation();
          }
        });
      } else {
        setTimeout(async () => {
          await createSimpleCalendar();
          if (typeof initializeCalendarNavigation === 'function') {
            initializeCalendarNavigation();
          } else if (typeof initStreakCalendarNavigation === 'function') {
            initStreakCalendarNavigation();
          }
        }, 100);
      }
      
      window.fixCalendar = async function() {
        console.log('ğŸ”§ REPARANDO CALENDARIO...');
        return await createSimpleCalendar();
      };
      
      window.switchUser = async function(userName) {
        console.log(`ğŸ”„ CAMBIANDO USUARIO: ${userName || 'Auto'}`);
        if (userName) {
          localStorage.setItem('currentUser', userName);
        }
        return await createSimpleCalendar();
      };
      
      // FUNCIÃ“N SIMPLE DE VERIFICACIÃ“N
      window.checkCalendar = async function() {
        const container = document.getElementById('streak-calendar-grid');
        const days = container ? container.querySelectorAll('.calendar-day') : [];
        
        console.log(`ğŸ“… Calendario: ${days.length} dÃ­as mostrados`);
        
        if (days.length === 0) {
          console.log('âŒ No hay dÃ­as - creando calendario...');
          await createSimpleCalendar();
        } else {
          console.log('âœ… Calendario funcionando correctamente');
        }
        
        return days.length;
      };
      
      // FUNCIÃ“N PARA ESTADÃSTICAS DETALLADAS
      window.showCalendarStats = function() {
        const container = document.getElementById('streak-calendar-grid');
        if (!container) {
          console.log('âŒ No hay calendario');
          return;
        }
        
        const currentUser = getCurrentUser();
        const days = container.querySelectorAll('.calendar-day');
        const stats = {
          usuario: currentUser,
          total: days.length,
          sinActividad: 0,
          actividad1: 0,    // 1 canciÃ³n
          actividad2: 0,    // 2 canciones  
          actividad3_4: 0,  // 3-4 canciones
          actividad5_6: 0   // 5-6 canciones
        };
        
        days.forEach(day => {
          const songs = parseInt(day.getAttribute('data-songs') || '0');
          if (songs === 0) stats.sinActividad++;
          else if (songs === 1) stats.actividad1++;
          else if (songs === 2) stats.actividad2++;
          else if (songs >= 3 && songs <= 4) stats.actividad3_4++;
          else if (songs >= 5) stats.actividad5_6++;
        });
        
        console.log(`ğŸ“Š === ESTADÃSTICAS DE ${currentUser} ===`);
        console.log(`ğŸ“… Total de dÃ­as: ${stats.total}`);
        console.log(`âšª Sin actividad: ${stats.sinActividad} dÃ­as`);
        console.log(`ğŸŸ¢ 1 canciÃ³n: ${stats.actividad1} dÃ­as`);
        console.log(`ğŸŸ¡ 2 canciones: ${stats.actividad2} dÃ­as`);
        console.log(`ğŸŸ  3-4 canciones: ${stats.actividad3_4} dÃ­as`);
        console.log(`ğŸ”´ 5-6 canciones: ${stats.actividad5_6} dÃ­as`);
        
        return stats;
      };
      
      // FUNCIÃ“N PARA COMPARAR USUARIOS
      window.compareUsers = function(user1, user2) {
        console.log(`ğŸ” === COMPARANDO ${user1} vs ${user2} ===`);
        
        const activity1 = generateUserActivity(user1, 30);
        const activity2 = generateUserActivity(user2, 30);
        
        let differences = 0;
        let total1 = 0, total2 = 0;
        
        const dates = Object.keys(activity1).sort();
        for (const date of dates) {
          if (activity1[date] !== activity2[date]) differences++;
          total1 += activity1[date];
          total2 += activity2[date];
        }
        
        console.log(`ğŸ‘¤ ${user1}: ${total1} canciones totales`);
        console.log(`ğŸ‘¤ ${user2}: ${total2} canciones totales`);
        console.log(`ğŸ”„ Diferencias: ${differences}/30 dÃ­as (${(differences/30*100).toFixed(1)}%)`);
        
        if (differences > 0) {
          console.log('âœ… Los usuarios tienen patrones Ãºnicos');
        } else {
          console.log('âŒ Los usuarios tienen patrones idÃ©nticos');
        }
        
        return { user1, user2, differences, total1, total2 };
      };
      
      // FUNCIÃ“N PARA PROBAR MÃšLTIPLES USUARIOS
      window.testMultipleUsers = function() {
        const users = ['Jenn GarcÃ­a', 'Usuario', 'Admin', 'Zero', 'MarÃ­a'];
        console.log('ğŸ§ª === PROBANDO MÃšLTIPLES USUARIOS ===');
        
        users.forEach(user => {
          const activity = generateUserActivity(user, 30);
          const total = Object.values(activity).reduce((sum, songs) => sum + songs, 0);
          const activeDays = Object.values(activity).filter(songs => songs > 0).length;
          
          console.log(`ğŸ‘¤ ${user}: ${activeDays} dÃ­as activos, ${total} canciones`);
        });
        
        // Comparar algunos usuarios
        console.log('\nğŸ” === COMPARACIONES ===');
        compareUsers('Jenn GarcÃ­a', 'Usuario');
        compareUsers('Admin', 'Zero');
      };
      
      // FUNCIÃ“N DE DIAGNÃ“STICO COMPLETO
      window.diagnosticComplete = function() {
        console.log('ğŸ” === DIAGNÃ“STICO COMPLETO DEL SISTEMA ===');
        
        // 1. Verificar usuario actual
        const currentUser = getCurrentUser();
        console.log(`ğŸ‘¤ Usuario actual: ${currentUser}`);
        
        // 2. Verificar calendario
        const container = document.getElementById('streak-calendar-grid');
        console.log(`ğŸ“… Contenedor del calendario: ${container ? 'Existe' : 'No existe'}`);
        
        if (container) {
          const days = container.querySelectorAll('.calendar-day');
          console.log(`ğŸ“Š DÃ­as en calendario: ${days.length}`);
          
          // Verificar colores aplicados
          const colorsFound = {
            low: container.querySelectorAll('.activity-low').length,
            medium: container.querySelectorAll('.activity-medium').length,
            high: container.querySelectorAll('.activity-high').length,
            veryHigh: container.querySelectorAll('.activity-very-high').length
          };
          
          console.log('ğŸ¨ DistribuciÃ³n de colores:', colorsFound);
        }
        
        // 3. Verificar estilos CSS
        const testElement = document.createElement('div');
        testElement.className = 'calendar-day activity-very-high';
        testElement.style.display = 'none';
        document.body.appendChild(testElement);
        
        const computedStyle = window.getComputedStyle(testElement);
        const hasGradient = computedStyle.background.includes('gradient') || 
                           computedStyle.backgroundImage.includes('gradient');
        
        console.log(`ğŸ¨ Estilos CSS aplicados: ${hasGradient ? 'Gradientes OK' : 'Gradientes NO aplicados'}`);
        document.body.removeChild(testElement);
        
        // 4. Verificar Firebase
        console.log(`ğŸ”¥ Firebase: ${typeof db !== 'undefined' ? 'Conectado' : 'No conectado'}`);
        
        // 5. Verificar funciones disponibles
        const functions = [
          'switchUser', 'showCalendarStats', 'compareUsers', 
          'testMultipleUsers', 'checkCalendar', 'forceFullCalendar'
        ];
        
        console.log('ğŸ”§ Funciones disponibles:');
        functions.forEach(func => {
          console.log(`  ${func}: ${typeof window[func] === 'function' ? 'âœ…' : 'âŒ'}`);
        });
        
        // 6. Probar cambio de usuario
        console.log('\nğŸ”„ Probando cambio de usuario...');
        const originalUser = getCurrentUser();
        switchUser('Test User');
        const newUser = getCurrentUser();
        switchUser(originalUser);
        
        console.log(`Cambio de usuario: ${newUser === 'Test User' ? 'âœ…' : 'âŒ'}`);
        
        console.log('\nâœ… === DIAGNÃ“STICO COMPLETADO ===');
        
        return {
          usuario: currentUser,
          calendario: !!container,
          dias: container ? container.querySelectorAll('.calendar-day').length : 0,
          estilos: hasGradient,
          firebase: typeof db !== 'undefined',
          funciones: functions.map(f => ({ [f]: typeof window[f] === 'function' }))
        };
      };
      
      // FunciÃ³n de prueba SIMPLE para verificar el calendario
      window.testCalendarNow = function() {
        console.log('ğŸ§ª === PRUEBA SIMPLE DEL CALENDARIO ===');
        
        const currentUser = getCurrentUser();
        console.log(`ğŸ‘¤ Usuario actual: ${currentUser}`);
        
        // Generar datos de prueba
        const activity = generateUserActivity(currentUser, 28);
        console.log(`ğŸ“Š Datos generados:`, activity);
        
        // Contar actividad
        const totalSongs = Object.values(activity).reduce((sum, count) => sum + count, 0);
        const activeDays = Object.values(activity).filter(count => count > 0).length;
        console.log(`ğŸ“ˆ ${totalSongs} canciones en ${activeDays} dÃ­as activos`);
        
        // Forzar renderizado del calendario
        console.log('ğŸ”„ Forzando renderizado...');
        renderStreakCalendar().then(() => {
          console.log('âœ… Calendario renderizado');
          
          // Verificar que se renderizÃ³
          const container = document.getElementById('streak-calendar-grid');
          const days = container ? container.querySelectorAll('.calendar-day') : [];
          console.log(`ğŸ“… ${days.length} dÃ­as mostrados en el calendario`);
          
          // Contar dÃ­as con actividad en el DOM
          const activeDaysInDOM = container ? container.querySelectorAll('.calendar-day[class*="activity-"]').length : 0;
          console.log(`ğŸ¯ ${activeDaysInDOM} dÃ­as con actividad visible en el DOM`);
          
          if (activeDaysInDOM > 0) {
            console.log('ğŸ‰ Â¡Ã‰XITO! El calendario muestra actividad individual');
          } else {
            console.log('âŒ PROBLEMA: El calendario no muestra actividad');
          }
        }).catch(error => {
          console.error('âŒ Error:', error);
        });
      };

      // FunciÃ³n de prueba especÃ­fica para el calendario
      window.testCalendar = function(username = null) {
        const testUser = username || getCurrentUser();
        console.log(`ğŸ§ª PRUEBA CALENDARIO: Probando calendario para usuario: ${testUser}`);
        
        // Establecer usuario seleccionado
        currentSelectedUser = testUser;
        console.log(`ğŸ¯ Usuario establecido: ${getCurrentSelectedUser()}`);
        
        // Generar actividad de prueba
        const activity = generateUserActivity(testUser, 28);
        console.log(`ğŸ“Š Actividad generada para ${testUser}:`, activity);
        
        // Contar dÃ­as activos
        const activeDays = Object.values(activity).filter(count => count > 0).length;
        const totalSongs = Object.values(activity).reduce((sum, count) => sum + count, 0);
        console.log(`ğŸ“ˆ Resumen: ${activeDays} dÃ­as activos, ${totalSongs} canciones totales`);
        
        // Renderizar calendario
        renderStreakCalendar().then(() => {
          console.log(`âœ… Calendario renderizado para ${testUser}`);
        }).catch(error => {
          console.error(`âŒ Error renderizando calendario:`, error);
        });
      };

      // FunciÃ³n para probar estadÃ­sticas individuales de actividad reciente
      window.testIndividualStats = function() {
        console.log('ğŸ“Š === PRUEBA DE ESTADÃSTICAS INDIVIDUALES ===');
        
        const testUsers = ['Usuario', 'Ana GarcÃ­a', 'Carlos LÃ³pez', 'MarÃ­a RodrÃ­guez'];
        
        testUsers.forEach(user => {
          console.log(`\nğŸ‘¤ Probando usuario: ${user}`);
          
          // Cambiar usuario
          switchUser(user);
          
          // Generar estadÃ­sticas
          const activity = generateUserActivity(user, 30);
          const totalSongs = Object.values(activity).reduce((sum, count) => sum + count, 0);
          const activeDays = Object.values(activity).filter(count => count > 0).length;
          
          console.log(`ğŸ“ˆ Total canciones: ${totalSongs}`);
          console.log(`ğŸ“… DÃ­as activos: ${activeDays}`);
          console.log(`ğŸµ Actividad por dÃ­a:`, Object.values(activity).slice(0, 7)); // Mostrar solo primeros 7 dÃ­as
          
          // Verificar que cada usuario tiene estadÃ­sticas Ãºnicas
          const userHash = hashCode(user);
          console.log(`ğŸ”‘ Hash Ãºnico del usuario: ${userHash}`);
        });
        
        console.log('\nâœ… Prueba de estadÃ­sticas individuales completada');
      };

      // FUNCIÃ“N PARA FORZAR RECARGA CON DATOS REALES
      window.forceRealDataCalendar = async function(userName = null) {
        const user = userName || getCurrentUser();
        console.log(`ğŸ”„ === FORZANDO RECARGA CON DATOS REALES PARA ${user} ===`);
        
        try {
          // Primero verificar datos disponibles
          const debugInfo = await window.debugRealData(user);
          
          // Buscar la mejor colecciÃ³n con datos
          let bestCollection = null;
          let maxUserDocs = 0;
          
          Object.entries(debugInfo).forEach(([collection, data]) => {
            if (!data.error && data.userDocs > maxUserDocs) {
              maxUserDocs = data.userDocs;
              bestCollection = collection;
            }
          });
          
          if (bestCollection && maxUserDocs > 0) {
            console.log(`âœ… Usando colecciÃ³n '${bestCollection}' con ${maxUserDocs} documentos de ${user}`);
            
            // Actualizar usuario si es necesario
            if (userName) {
              localStorage.setItem('currentUser', userName);
            }
            
            // Recrear calendario con datos reales
            await createSimpleCalendar();
            
            // Verificar resultado
            const container = document.getElementById('streak-calendar-grid');
            const days = container ? container.querySelectorAll('.calendar-day') : [];
            const activeDays = container ? container.querySelectorAll('.calendar-day[class*="activity-"]') : [];
            
            console.log(`ğŸ“… Calendario actualizado: ${days.length} dÃ­as, ${activeDays.length} con actividad`);
            
            return {
              success: true,
              user,
              collection: bestCollection,
              totalDocs: maxUserDocs,
              calendarDays: days.length,
              activeDays: activeDays.length
            };
            
          } else {
            console.log(`âš ï¸ No se encontraron datos reales para ${user}, usando datos simulados`);
            await createSimpleCalendar();
            
            return {
              success: false,
              user,
              reason: 'No hay datos reales disponibles',
              usingSimulated: true
            };
          }
          
        } catch (error) {
          console.error('âŒ Error forzando recarga:', error);
          return { success: false, error: error.message };
        }
      };
      
      console.log('ğŸ¯ Sistema de racha por usuario establecido');
    })();
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      var canvas = document.getElementById('orb-background');
      if (!canvas || !canvas.getContext) return;
      var ctx = canvas.getContext('2d');
      var width = 0;
      var height = 0;
      var dpr = window.devicePixelRatio || 1;
      var particles = [];
      var baseRadius = 0;
      var particleCount = 900;
      var lastTime = 0;
      var rotationX = 0;
      var rotationY = 0;
      var velocityX = 0.00015;
      var velocityY = 0.00025;
      var lastScrollY = window.scrollY || 0;
      var currentShape = localStorage.getItem('selectedShape') || 'orb';

      function hexToRgba(hex, alpha) {
        if (!hex) return hex;
        // Si ya es rgb/rgba, solo asegurarnos de que tenga el alpha correcto si es posible, o devolverlo
        if (hex.startsWith('rgb')) {
           if (hex.startsWith('rgba')) {
             // Reemplazar Ãºltimo valor
             return hex.replace(/[\d\.]+\)$/g, alpha + ')');
           } else {
             return hex.replace(')', ', ' + alpha + ')').replace('rgb', 'rgba');
           }
        }
        if (hex[0] !== '#') return hex;
        if (hex.length === 4) {
          hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
        }
        var r = parseInt(hex.slice(1, 3), 16);
        var g = parseInt(hex.slice(3, 5), 16);
        var b = parseInt(hex.slice(5, 7), 16);
        return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
      }

      function getSpherePoint(r) {
        var u = Math.random();
        var v = Math.random();
        var theta = 2 * Math.PI * u;
        var phi = Math.acos(2 * v - 1);
        // Aumentar radio para igualar visualmente al teseracto (aprox 1.3x - reducido de 1.6x)
        var rr = r * 1.3 * (0.8 + 0.2 * Math.random());
        return {
          x: rr * Math.sin(phi) * Math.cos(theta),
          y: rr * Math.cos(phi),
          z: rr * Math.sin(phi) * Math.sin(theta)
        };
      }

      function getTrianglePoint(r) {
        // Ajustar escala del triÃ¡ngulo (reducido ligeramente a 0.9x)
        var s = r * 0.9;
        var verts = [
          {x: s, y: s, z: s},
          {x: -s, y: -s, z: s},
          {x: -s, y: s, z: -s},
          {x: s, y: -s, z: -s}
        ];
        var f = Math.floor(Math.random() * 4);
        var p1 = verts[f];
        var p2 = verts[(f + 1) % 4];
        var p3 = verts[(f + 2) % 4];
        var a = Math.random();
        var b = Math.random();
        if (a + b > 1) { a = 1 - a; b = 1 - b; }
        var x = p1.x + a * (p2.x - p1.x) + b * (p3.x - p1.x);
        var y = p1.y + a * (p2.y - p1.y) + b * (p3.y - p1.y);
        var z = p1.z + a * (p2.z - p1.z) + b * (p3.z - p1.z);
        var noise = (Math.random() - 0.5) * r * 0.1;
        return {x: x + noise, y: y + noise, z: z + noise};
      }

      function getHexagonPoint(r) {
        // Reducir escala del teseracto (aprox 20% menos)
        var sizeOuter = r * 0.8;
        var sizeInner = r * 0.48;
        var useInner = Math.random() < 0.5;
        var s = useInner ? sizeInner : sizeOuter;
        var axis = Math.floor(Math.random() * 3);
        var sign1 = Math.random() < 0.5 ? -1 : 1;
        var sign2 = Math.random() < 0.5 ? -1 : 1;
        var t = Math.random() * 2 - 1;
        var x, y, z;
        if (axis === 0) {
          x = t * s;
          y = sign1 * s;
          z = sign2 * s;
        } else if (axis === 1) {
          y = t * s;
          x = sign1 * s;
          z = sign2 * s;
        } else {
          z = t * s;
          x = sign1 * s;
          y = sign2 * s;
        }
        var noise = (Math.random() - 0.5) * r * 0.1;
        return {x: x + noise, y: y + noise, z: z + noise};
      }

      function getTargetPoint(r) {
        if (currentShape === 'triangle') return getTrianglePoint(r);
        if (currentShape === 'hexagon') return getHexagonPoint(r);
        return getSpherePoint(r);
      }

      function createParticles() {
        var style = getComputedStyle(document.body);
        var accentHex = style.getPropertyValue('--accent-color').trim();
        var isDark = document.body.classList.contains('dark-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
        
        // Usar color de acento si existe, sino fallback a azul
        if (!accentHex || accentHex === 'initial') {
             accentHex = '#007bff';
        }
        
        var accentRgba = hexToRgba(accentHex, 0.9); // Opacidad casi total
        var exists = particles.length > 0;
        var isMobile = window.innerWidth <= 600;
        
        // Obtener cantidad de partÃ­culas guardada o usar default
        var savedCount = localStorage.getItem('particleCount');
        var defaultCount = isMobile ? 300 : 800; // Default original
        var targetCount = savedCount ? parseInt(savedCount) : defaultCount;
        
        if (particles.length !== targetCount) {
           particles = [];
           exists = false;
           particleCount = targetCount;
        }
        
        for (var i = 0; i < particleCount; i++) {
          var t = i / particleCount;
          var color;
          
          // 60% de partÃ­culas usan el color de acento
          if (Math.random() < 0.6 && accentRgba) {
            color = accentRgba;
          } else {
            // El resto usa una variaciÃ³n complementaria o grisÃ¡cea dependiendo del tema
            var hue = 200 + 160 * t;
            // En modo oscuro usar luminosidad y alpha altos
            var lightness = isDark ? '85%' : '60%'; 
            var alpha = isDark ? 0.95 : 0.85;
            color = 'hsla(' + hue + ', 90%, ' + lightness + ', ' + alpha + ')';
          }
          
          var size = (isMobile ? 2.5 : 2) + Math.random(); // Ligeramente mÃ¡s grandes
          var target = getTargetPoint(baseRadius);
          
          if (!exists) {
             particles.push({ 
                x: target.x, y: target.y, z: target.z, 
                tx: target.x, ty: target.y, tz: target.z,
                color: color, size: size 
             });
          } else {
             particles[i].color = color;
             particles[i].tx = target.x;
             particles[i].ty = target.y;
             particles[i].tz = target.z;
             particles[i].size = size;
          }
        }
      }

      // Observar cambios de tema para regenerar colores
      var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.attributeName === 'class' || mutation.attributeName === 'data-theme') {
             setTimeout(createParticles, 50);
          }
        });
      });
      observer.observe(document.body, { attributes: true });
      observer.observe(document.documentElement, { attributes: true });

      // Exponer funciÃ³n para actualizar partÃ­culas desde fuera
      window.updateParticleSystem = function() {
        particles = [];
        createParticles();
      };
      
      // Escuchar cambios de tema (color, transparencia, etc) disparados por el menÃº
      window.addEventListener('themeChanged', function() {
        // PequeÃ±o delay para asegurar que el DOM/CSS se haya actualizado
        setTimeout(createParticles, 50);
      });

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        baseRadius = Math.min(width, height) * 0.35;
        dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        createParticles();
      }

      function renderFrame(time) {
        if (!lastTime) lastTime = time;
        var delta = time - lastTime;
        lastTime = time;
        
        // Movimiento base tenue (idle) + velocidad dinÃ¡mica
        rotationX += (velocityX + 0.00005) * delta;
        rotationY += (velocityY + 0.0001) * delta;
        
        velocityX *= 0.98;
        velocityY *= 0.98;
        ctx.clearRect(0, 0, width, height);
        // Usar window.innerWidth como fallback si body.clientWidth es 0 o inestable
        var centerX = (window.innerWidth || document.body.clientWidth) / 2;
        var centerY = height / 2;
        var cosX = Math.cos(rotationX);
        var sinX = Math.sin(rotationX);
        var cosY = Math.cos(rotationY);
        var sinY = Math.sin(rotationY);
        var fov = baseRadius * 2;
        var projected = [];
        
        // Factor de interpolaciÃ³n para transiciones suaves (lerp)
        var lerpFactor = 0.05;

        for (var i = 0; i < particles.length; i++) {
          var p = particles[i];
          
          // Actualizar posiciÃ³n hacia el objetivo (transiciÃ³n de forma)
          p.x += (p.tx - p.x) * lerpFactor;
          p.y += (p.ty - p.y) * lerpFactor;
          p.z += (p.tz - p.z) * lerpFactor;
          
          var x = p.x;
          var y = p.y;
          var z = p.z;
          var x1 = x * cosY + z * sinY;
          var z1 = -x * sinY + z * cosY;
          var y1 = y * cosX - z1 * sinX;
          var z2 = y * sinX + z1 * cosX;
          var scale = fov / (fov + z2 + baseRadius);
          var px = centerX + x1 * scale;
          var py = centerY + y1 * scale;
          projected.push({ x: px, y: py, z: z2, color: p.color, size: p.size * scale });
        }
        projected.sort(function(a, b) { return a.z - b.z; });
        for (var j = 0; j < projected.length; j++) {
          var q = projected[j];
          ctx.beginPath();
          ctx.fillStyle = q.color;
          var s = q.size;
          ctx.arc(q.x, q.y, s, 0, Math.PI * 2);
          ctx.fill();
        }
        window.requestAnimationFrame(renderFrame);
      }

      function handleScroll() {
        var y = window.scrollY || 0;
        var delta = y - lastScrollY;
        lastScrollY = y;
        velocityY += delta * 0.000002;
        velocityX += delta * 0.000001;
      }

      function boostRotation() {
        velocityY += 0.003 * (Math.random() > 0.5 ? 1 : -1);
        velocityX += 0.003 * (Math.random() > 0.5 ? 1 : -1);
      }

      // Escuchar cambios de forma desde el modal de temas
      window.addEventListener('shapeChanged', function(e) {
        if (e.detail && e.detail.shape) {
          currentShape = e.detail.shape;
          createParticles();
        }
      });

      resize();
      window.addEventListener('resize', resize);
      window.addEventListener('orientationchange', resize);
      window.addEventListener('scroll', handleScroll, { passive: true });
      window.addEventListener('wheel', function(e) {
        velocityY += e.deltaY * 0.0000008;
        velocityX += e.deltaX * 0.0000008;
      }, { passive: true });
      window.addEventListener('pointerdown', boostRotation, { passive: true });
      window.addEventListener('touchstart', boostRotation, { passive: true });
      window.requestAnimationFrame(renderFrame);
    });
  </script>
  <div id="immersive-bg"></div>
  <canvas id="orb-background" class="immersive-layer orb-background-canvas"></canvas>
  <div id="stats-ticker" class="stats-ticker" hidden>
    <div class="ticker-content">Cargando estadÃ­sticasâ€¦</div>
  </div>
</body>
<script>
(function(){
  if (window.__menuInitialized) return;
  window.__menuInitialized = true;
  function pos(btn, dd){
    dd.style.position = '';
    dd.style.left = '';
    dd.style.right = '';
    dd.style.top = '';
  }
  document.addEventListener('DOMContentLoaded', function() {
    const btn = document.getElementById('menu-btn');
    const dd = document.getElementById('menu-dropdown');
    if (!btn || !dd) return;
    function open(){
      dd.hidden = false;
      btn.setAttribute('aria-expanded', 'true');
      requestAnimationFrame(() => {
        dd.classList.add('open');
        pos(btn, dd);
      });
    }
    function close(){
      dd.classList.remove('open');
      btn.setAttribute('aria-expanded', 'false');
      const onEnd = (e) => {
        if (e.target !== dd) return;
        dd.hidden = true;
        dd.removeEventListener('transitionend', onEnd);
      };
      dd.addEventListener('transitionend', onEnd);
    }
    btn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      if (dd.hidden) open(); else close();
    });
    document.addEventListener('click', function(e){
      if (dd.hidden) return;
      const t = e.target;
      if (!btn.contains(t) && !dd.contains(t)) close();
    });
    document.addEventListener('keydown', function(e){
      if (e.key === 'Escape' && !dd.hidden) close();
    });
    window.addEventListener('resize', function(){
      if (!dd.hidden) pos(btn, dd);
    });
    window.addEventListener('scroll', function(){
      if (!dd.hidden) pos(btn, dd);
    });
    dd.addEventListener('click', function(e){
      const item = e.target && e.target.closest('a, button');
      if (item) close();
      e.stopPropagation();
    });
  
  });
})();

// Global handler for modal close buttons (X)
document.addEventListener('click', function(e) {
  if (e.target && e.target.classList.contains('modal-close-btn')) {
    const modal = e.target.closest('.modal-overlay');
    if (modal) {
      modal.hidden = true;
      e.stopPropagation(); // Prevent bubbling
    }
  }
});

// FunciÃ³n de notificaciones tipo Toast
window.showNotification = function(message, type = 'info') {
  // Crear contenedor si no existe
  let container = document.getElementById('toast-container');
  if (!container) {
    container = document.createElement('div');
    container.id = 'toast-container';
    document.body.appendChild(container);
  }

  const toast = document.createElement('div');
  toast.className = `toast-notification ${type}`;
  toast.textContent = message;
  
  document.body.appendChild(toast);
  
  // Forzar reflow para animaciÃ³n
  toast.offsetHeight;
  
  // Mostrar
  requestAnimationFrame(() => toast.classList.add('show'));
  
  // Ocultar y remover
  setTimeout(() => {
    toast.classList.remove('show');
    toast.addEventListener('transitionend', () => toast.remove());
  }, 3000);
};

// Utility for Admin Overlay Links
window.copyOverlayLink = function(filename) {
  // Resolve URL relative to current location
  const fullUrl = new URL(filename, window.location.href).href;
  
  navigator.clipboard.writeText(fullUrl).then(() => {
    alert('Enlace copiado al portapapeles:\n' + fullUrl);
  }).catch(err => {
    console.error('Error al copiar: ', err);
    prompt('No se pudo copiar automÃ¡ticamente. Copia este enlace:', fullUrl);
  });
};
</script>
</html>
